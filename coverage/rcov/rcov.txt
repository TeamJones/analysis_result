metric_fu shift the first line
================================================================================
 ./app/controllers/application_controller.rb
================================================================================
   class ApplicationController < ActionController::Base
   
     helper :all # include all helpers, all the time
   
     helper_method :current_user
   
     before_filter :make_available_for_exception_notification
   
     # See ActionController::RequestForgeryProtection for details
     # Uncomment the :secret if you're not using the cookie session store
     protect_from_forgery # :secret => '5e9d164f3052749a36db7a972c72915a'
   
     # Return true if the user agent is a bot.
     def robot?
       bot = /(Baidu|bot|Google|SiteUptime|Slurp|WordPress|ZIBB|ZyBorg)/i
       request.user_agent =~ bot
     end
   
     private
     def get_http_referer
!!     if request.env["HTTP_REFERER"].nil? then
!!       return ""
       else
!!       return request.env["HTTP_REFERER"].gsub('http:', 'https:')
       end
     end
   
     def get_http_host
       return request.env["HTTP_X_FORWARDED_HOST"] || request.env["HTTP_HOST"]
     end
   
     def get_twiki_http_referer
!!     if request.env["HTTP_REFERER"].nil? then
!!       return ""
       else
!!       url = request.env["HTTP_REFERER"].gsub('info.west.cmu.edu', 'info.sv.cmu.edu').gsub('https:', 'http:')
!!       url_no_query_string = url.split('?')[0]
!!       url_no_anchors = url_no_query_string.split('#')[0]
!!       return url_no_anchors
       end
     end
   
     #Temporary method until we merge person and user
     def current_person
       if current_user
!!       Person.find(current_user.id)
       else
         nil
       end
     end
   
   ##  In development, if you want to pretend to be a different user, you can set it easily here
     def current_user
       User.find_by_twiki_name 'EdKatz' #Cecile
       #User.last
     end
   
     def authenticate_user!
       if !current_user
         # This should work, but session is lost. See https://github.com/plataformatec/devise/issues/1357
         # session[:return_to] = request.fullpath
         redirect_to user_omniauth_authorize_path(:google_apps, :origin => request.fullpath)
       end
     end
   
     def user_profile_status_check
!!     if !current_user.profile_updated?
!!       if current_user.should_be_redirected?
!!         redirect_to root_path
         else
           #popup a box
         end
       end
     end
   
     #Return to the page the user was trying to access after a login
     def after_sign_in_path_for(resource)
       # This should work, but session is lost. See https://github.com/plataformatec/devise/issues/1357
       # return_to = session[:return_to]
       # session[:return_to] = nil
       return_to = request.env['omniauth.origin']
       stored_location_for(resource) || return_to || root_path
     end
   
     def store_location
!!     session[:return_to] = request.request_uri
     end
   
     def store_previous_location
!!     session[:return_to] = request.env["HTTP_REFERER"]
     end
   
     def redirect_back_or_default(default)
!!     redirect_to(session[:return_to] || default)
!!     session[:return_to] = nil
     end
   
     # level = :admin, :staff, :student
     def has_permissions_or_redirect(level, url)
       unless current_user.permission_level_of(level)
!!       flash[:error] = t(:no_permission)
         #          redirect_back_or_default(url)
!!       redirect_to(url)
!!       return false
       end
!!     return true
     end
   
     rescue_from CanCan::AccessDenied do |exception|
!!     flash[:error] = exception.message #We can remove this line when we upgrade to Rails 3.2
!!     redirect_to root_url, :error => exception.message
     end
   
     # Now in locales
     #def american_date
     #  '%m/%d/%Y'
     #end
   
     protected
     def make_available_for_exception_notification
       request.env["exception_notifier.exception_data"] = {
           :current_user => current_user
       }
     end
   
   end

================================================================================
 ./app/controllers/assignments_controller.rb
================================================================================
   class AssignmentsController < ApplicationController
     # GET /assignments
     # GET /assignments.xml
     before_filter :authenticate_user!
     before_filter :get_course
     before_filter :render_grade_book_menu
   
     layout 'cmu_sv'
   
     def get_course
!!     @course=Course.find(params[:course_id])
!!     @wording = @course.nomenclature_assignment_or_deliverable
     end
   
     def render_grade_book_menu
!!     @is_in_grade_book = true
     end
   
     def index
!!     @assignments = Assignment.all(:conditions => ["course_id = ?", @course.id])
!!     authorize! :read, Assignment
   
!!     respond_to do |format|
!!       format.html # index.html.erb
!!       format.xml { render :xml => @assignments }
       end
     end
   
     # GET /assignments/new
     # GET /assignments/new.xml
     def new
!!     @assignment = Assignment.new
!!     authorize! :update, @course
   
!!     respond_to do |format|
!!       format.html # new.html.erb
!!       format.xml { render :xml => @assignment }
       end
     end
   
     # GET /assignments/1/edit
     def edit
!!     @assignment = Assignment.find(params[:id])
!!     authorize! :update, @course
     end
   
     # POST /assignments
     # POST /assignments.xml
     def create
!!     @assignment = @course.assignments.new(params[:assignment])
!!     authorize! :update, @course
!!     @assignment.set_due_date(params[:due_date][:date], params[:due_date][:hour], params[:due_date][:minute]) if params.has_key?(:due_date)
!!     respond_to do |format|
!!       if @assignment.save
!!         format.html { redirect_to(course_assignments_path, :notice => "#{@wording}  #{@assignment.name} was successfully created.") }
!!         format.xml { render :xml => @assignment, :status => :created, :location => @assignment }
         else
!!         format.html { render :action => "new" }
!!         format.xml { render :xml => @assignment.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # PUT /assignments/1
     # PUT /assignments/1.xml
     def update
!!     @assignment = Assignment.find(params[:id])
!!     authorize! :update, @course
   
!!     @assignment.set_due_date(params[:due_date][:date], params[:due_date][:hour], params[:due_date][:minute]) if params.has_key?(:due_date)
!!     deliverable_submitted=Deliverable.find_all_by_assignment_id(@assignment.id).first
!!     deliverable_status=0;
!!     unless deliverable_submitted.nil?
!!       if @assignment.is_team_deliverable.to_s!= params[:assignment]["is_team_deliverable"]
!!         deliverable_status=1
!!         flash[:error] = "You cannot change the Type as the student(s) has already submitted for this item."
   
         end
       end
   
!!     if deliverable_status==0
!!       respond_to do |format|
!!         if @assignment.update_attributes(params[:assignment])
!!           format.html { redirect_to(course_assignments_path, :notice => "Assignment #{@assignment.name} was successfully updated.") }
!!           format.xml { head :ok }
           else
!!           format.html { render :action => "edit" }
!!           format.xml { render :xml => @assignment.errors, :status => :unprocessable_entity }
           end
         end
       else
!!       respond_to do |format|
!!         format.html { render :action => "edit" }
!!         format.xml { render :xml => @assignment.errors, :status => :unprocessable_entity }
         end
       end
   
   
     end
   
     # DELETE /assignments/1
     # DELETE /assignments/1.xml
     def destroy
!!     @assignment = Assignment.find(params[:id])
!!     authorize! :destroy, @assignment
   
!!     @assignment.destroy
!!     respond_to do |format|
!!       format.js
       end
     end
   
   
     # GET /course/assignment_reorder/1
     def show
!!     @no_pad = true
!!     @assignments = @course.assignments
!!     authorize! :read, @course
   
!!     respond_to do |format|
!!       format.html # showml.erb
       end
     end
   
     #Inspiration for this technique comes from two sources
     # A: http://awesomeful.net/posts/47-sortable-lists-with-jquery-in-rails (yield javascript, jquery ui code)
     # B: http://henrik.nyh.se/2008/11/rails-jquery-sortables#comment-17220662 (model update code)
   
     def reposition
!!     authorize! :reorder_assignments, @course
   
!!     order = params[:assignment]
!!     Rails.logger.debug(order)
!!     Assignment.reposition(order)
!!     render :text => order.inspect
     end
   
   
   end

================================================================================
 ./app/controllers/course_navigations_controller.rb
================================================================================
   class CourseNavigationsController < ApplicationController
     layout 'cmu_sv'
   
     before_filter :authenticate_user!
   
     #Inspiration for this technique comes from two sources
     # A: http://awesomeful.net/posts/47-sortable-lists-with-jquery-in-rails (yield javascript, jquery ui code)
     # B: http://henrik.nyh.se/2008/11/rails-jquery-sortables#comment-17220662 (model update code)
   
   
     # GET /course_navigations/1
     # GET /course_navigations/1.xml
     def show
!!     @no_pad = true
!!     @course = Course.find(params[:id])
!!     authorize! :update, @course
   
!!     @pages = @course.pages
   
!!     respond_to do |format|
!!       format.html # show.html.erb
!!       format.xml { render :xml => @pages }
       end
     end
   
     def reposition
!!     order = params[:page]
!!     Page.reposition(order)
!!     render :text => order.inspect
     end
   
   end

================================================================================
 ./app/controllers/course_numbers_controller.rb
================================================================================
   class CourseNumbersController < ApplicationController
     layout 'cmu_sv'
   
     before_filter :authenticate_user!
   
     # GET /course_numbers
     # GET /course_numbers.xml
     def index
!!     @courses = Course.unique_course_numbers_and_names_by_number
     end
   
   end
   
   

================================================================================
 ./app/controllers/courses_controller.rb
================================================================================
   class CoursesController < ApplicationController
     layout 'cmu_sv'
   
     before_filter :authenticate_user!
   
     # GET /courses
     # GET /courses.xml
     def index
!!     @all_courses = true
!!     @courses = Course.order("year DESC, semester DESC, number ASC").all
!!     @courses = @courses.sort_by { |c| -c.sortable_value } # note the '-' is for desc sorting
   
!!     @registered_for_these_courses_during_current_semester = current_person.registered_for_these_courses_during_current_semester
!!     @teaching_these_courses_during_current_semester = current_person.teaching_these_courses_during_current_semester
     end
   
     def index_for_semester
!!     @all_courses = false
!!     (@semester, @year) = AcademicCalendar.valid_semester_and_year(params[:semester])
   
!!     if @semester.blank? || @year.blank?
!!       current_semester = "#{AcademicCalendar.current_semester()}#{Date.today.year}"
!!       flash[:notice] = "The requested url #{request.path} does not look like /courses/semester/#{current_semester} -- Thus we brought you to the current semester."
!!       redirect_to("/courses/semester/#{current_semester}")
!!       return false
       end
   
!!     @courses = Course.for_semester(@semester, @year)
!!     @semester_length_courses = @courses.select { |course| course.mini == "Both" }
!!     @mini_a_courses = @courses.select { |course| course.mini == "A" }
!!     @mini_b_courses = @courses.select { |course| course.mini == "B" }
   
!!     index_core
     end
   
     #def current_semester
     #  #@all_courses = false
     #  @semester = AcademicCalendar.current_semester()
     #  @year = Date.today.year
     #  params[:semester] = "#{@semester}#{@year}"
     #
     #  #@courses = Course.for_semester(@semester, @year)
     #  #@semester_length_courses = @courses.select {|course| course.mini == "Both"}
     #  #@mini_a_courses = @courses.select {|course| course.mini == "A"}
     #  #@mini_b_courses = @courses.select {|course| course.mini == "B"}
     #  #
     #  #index_core
     #  index_for_semester
     #end
     #
     #def next_semester
     #  @all_courses = false
     #  @semester = AcademicCalendar.next_semester()
     #  @year = AcademicCalendar.next_semester_year()
     #
     #  @courses = Course.for_semester(@semester, @year)
     #  @semester_length_courses = @courses.select {|course| course.mini == "Both"}
     #  @mini_a_courses = @courses.select {|course| course.mini == "A"}
     #  @mini_b_courses = @courses.select {|course| course.mini == "B"}
     #
     #  index_core
     #end
   
     # GET /courses/1
     # GET /courses/1.xml
     def show
!!     @course = Course.find(params[:id])
!!     first_version_of_course = Course.first_offering_for_course_name(@course.name)
!!     @whiteboard_curriculum_page = first_version_of_course.pages[0] if first_version_of_course.pages.present?
   
!!     if (can? :teach, @course) || current_user.is_admin?
!!       @students = @course.registered_students_and_students_on_teams_hash
       end
   
!!     respond_to do |format|
!!       format.html # show.html.erb
!!       format.xml { render :xml => @course }
       end
     end
   
     def tool_support
!!     @course = Course.find(params[:id])
!!     authorize! :teach, @course
   
!!     teams = Team.where(:course_id => params[:id])
!!     @emails = []
!!     teams.each do |team|
!!       team.members.each do |user|
!!         @emails << user.email
         end
       end
     end
   
     # GET /courses/new
     # GET /courses/new.xml
     def new
!!     authorize! :create, Course
!!     @course = Course.new(:grading_rule => GradingRule.new)
!!     @course.semester = AcademicCalendar.next_semester
!!     @course.year = AcademicCalendar.next_semester_year
   
!!     respond_to do |format|
!!       format.html # new.html.erb
!!       format.xml { render :xml => @course }
       end
     end
   
     # GET /courses/1/edit
     def edit
!!     @is_in_grade_book = true
!!     store_previous_location
!!     @course = Course.find(params[:id])
!!     if @course.grading_rule.nil?
!!       @course.grading_rule = GradingRule.new
       end
!!     authorize! :update, @course
     end
   
     def configure
!!     edit
     end
   
     # POST /courses
     # POST /courses.xml
     def create
!!     authorize! :create, Course
!!     @last_offering = Course.last_offering(params[:course][:number])
!!     if @last_offering.nil?
!!       @course = Course.new(:name => "New Course", :mini => "Both", :number => params[:course][:number])
       else
!!       @course = @last_offering.copy_as_new_course
       end
   
!!     @course.year = params[:course][:year]
!!     @course.semester = params[:course][:semester]
!!     respond_to do |format|
!!       @course.updated_by_user_id = current_user.id if current_user
!!       if @course.save
   
!!         flash[:notice] = 'Course was successfully created.'
!!         format.html { redirect_to edit_course_path(@course) }
!!         format.xml { render :xml => @course, :status => :created, :location => @course }
         else
!!         format.html { render :action => "new" }
!!         format.xml { render :xml => @course.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # PUT /courses/1
     # PUT /courses/1.xml
     def update
!!     @course = Course.find(params[:id])
!!     authorize! :update, @course
   
!!     if (params[:course][:is_configured]) #The previous page was configure action
!!       if params[:course][:curriculum_url].include?("info.sv.cmu.edu")
!!         @course.twiki_url = params[:course][:curriculum_url].sub("https", "http")
         end
!!       @course.configured_by_user_id = current_user.id
       end
   
!!     params[:course][:faculty_assignments_override] = params[:teachers]
!!     respond_to do |format|
!!       @course.updated_by_user_id = current_user.id if current_user
!!       @course.attributes = params[:course]
!!       if @course.save
!!         flash[:notice] = 'Course was successfully updated.'
!!         format.html { redirect_back_or_default(course_path(@course)) }
!!         format.xml { head :ok }
         else
!!         format.html { render :action => "configure" }
!!         format.xml { render :xml => @course.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # DELETE /courses/1
     # DELETE /courses/1.xml
     def destroy
!!     if has_permissions_or_redirect(:admin, root_path)
!!       @course = Course.find(params[:id])
!!       @course.destroy
   
!!       respond_to do |format|
!!         format.html { redirect_to(courses_url) }
!!         format.xml { head :ok }
         end
       end
     end
   
     def upload
!!     require 'HUB_class_roster_handler'
   
!!     authorize! :upload, Course
!!     store_previous_location
!!     file_content = params[:file].read()
   
!!     begin
!!       changes_applied = HUBClassRosterHandler::handle(file_content)
!!       if changes_applied
!!         flash[:notice] = 'Roster file was parsed and handled successfully.'
         else
!!         flash[:notice] = 'Roster file parsed successfully, but no changes made.'
         end
       rescue Exception => ex
!!       flash[:error] = "There was a problem parsing your roster file: #{ex.message}"
       end
   
!!     respond_to do |format|
!!       format.html { redirect_back_or_default(courses_path) }
       end
     end
   
     def team_formation_tool
!!     @course = Course.find(params[:course_id])
!!     authorize! :team_formation, @course
   
!!     respond_to do |format|
!!       format.html { render :html => @teams, :layout => "cmu_sv" } # index.html.erb
!!       format.xml { render :xml => @teams }
       end
     end
   
   
     def export_to_csv
!!     @course = Course.find(params[:course_id])
!!     authorize! :team_formation, @course
   
!!     report = CSV.generate do |title|
!!       title << ['Person', 'Current Team', 'Past Teams', "Part Time", "Local/Near/Remote", "Program", "State", "Company Name"]
!!       @course.registered_students.each do |user|
!!         current_team = @course.teams.collect { |team| team if team.members.include?(user) }.compact
!!         part_time = user.is_part_time ? "PT" : "FT"
!!         title << [user.human_name, user.formatted_teams(current_team), user.formatted_teams(user.past_teams), part_time, user.local_near_remote, user.masters_program + " " + user.masters_track, user.work_state, user.organization_name]
         end
       end
!!     send_data(report, :type => 'text/csv;charset=iso-8859-1;', :filename => "past_teams_for_#{@course.display_course_name}.csv",
                 :disposition => 'attachment', :encoding => 'utf8')
     end
   
     private
     def index_core
!!     respond_to do |format|
!!       format.html { render :action => "index" }
!!       format.xml { render :xml => @courses }
       end
     end
   end

================================================================================
 ./app/controllers/delayed_system_jobs_controller.rb
================================================================================
   class DelayedSystemJobsController < ApplicationController
   
     before_filter :authenticate_user!
   
     layout 'cmu_sv'
   
   
     def index
!!     @no_pad = true
!!     if has_permissions_or_redirect(:admin, root_path)
   
!!       @delayed_system_jobs = DelayedSystemJob.all
   
!!       respond_to do |format|
!!         format.html { render :html => @delayed_system_jobs, :layout => "cmu_sv" } # index.html.erb
!!         format.js { render :js => @delayed_system_jobs, :layout => false }
!!         format.xml { render :xml => @delayed_system_jobs }
         end
       end
     end
   
     # DELETE /delayed_systems_job/1
     # DELETE /delayed_systems_job/1.xml
     def destroy
!!     if has_permissions_or_redirect(:admin, root_path)
   
!!       delayed_system_job = DelayedSystemJob.find(params[:id])
!!       delayed_system_job.destroy
   
!!       respond_to do |format|
!!         format.html { redirect_to("/delayed_system_jobs") }
!!         format.xml { head :ok }
         end
       end
     end
   end

================================================================================
 ./app/controllers/deliverables_controller.rb
================================================================================
   class DeliverablesController < ApplicationController
   
     layout 'cmu_sv'
   
     
     before_filter :render_grade_book_menu, :only => [:grading_queue_for_course, :show]
   
     def render_grade_book_menu
       @is_in_grade_book = true if (current_user.is_staff?)||(current_user.is_admin?)
     end
   
     # GET /deliverables
     # GET /deliverables.xml
     def index
!!     redirect_to my_deliverables_path(current_user)
     end
   
     def grading_queue_for_course
   
!!     @course = Course.find(params[:course_id])
   
!!     if @course.grading_rule.nil?
!!       flash[:error] = I18n.t(:no_grading_rule_for_course)
!!       redirect_to course_path(@course) and return
       end
!!     if @course.grading_rule.default_values?
!!       flash.now[:error] = I18n.t(:default_grading_rule_for_course)
       end
   
       # Retrieving assignments names for the course to be able to filter by deliverable name later on.
       # @assignments = Assignment.where(:course_id => @course.id).all
       # Team Turing: this fails when the task is nil.
!!     @assignments = Assignment.where(:course_id => @course.id).all.sort_by(&:task_number)
   
   
!!     if @course.faculty.include?(current_user)
         # Get all deliverables for this team/student
!!       @deliverables = Deliverable.get_deliverables(params[:course_id], current_user.id, {:is_my_team => 1})
   
!!       @deliverables = @deliverables.select { |deliverable| deliverable.grade_status == "ungraded" }
   
!!       @deliverables = @deliverables.sort { |a, b| b.assignment.assignment_order <=> a.assignment.assignment_order }
       else
!!       has_permissions_or_redirect(:admin, root_path)
       end
   
     end
   
     def get_deliverables
       filter_options = params[:filter_options] || Hash.new
       @deliverables = filter_deliverables(params[:course_id], filter_options)
!!     respond_to do |format|
!!       format.js
       end
     end
   
     #temporary for mel
     def team_index_for_course
!!     @course = Course.find(params[:course_id])
!!     if (current_user.is_admin? || @course.faculty.include?(current_user))
!!       @deliverables = Deliverable.where("team_id is not null").find_all_by_course_id(@course.id)
       else
!!       has_permissions_or_redirect(:admin, root_path)
       end
     end
   
     #temporary for mel
     def individual_index_for_course
!!     @course = Course.find(params[:course_id])
!!     if (current_user.is_admin? || @course.faculty.include?(current_user))
!!       @deliverables = Deliverable.where("team_id is null").find_all_by_course_id(@course.id)
       else
!!       has_permissions_or_redirect(:admin, root_path)
       end
     end
   
     def my_deliverables
       user = User.find_by_param(params[:id])
       if (current_user.id != user.id)
!!       unless (current_user.is_staff?)||(current_user.is_admin?)
!!         flash[:error] = I18n.t(:not_your_deliverable)
!!         redirect_to root_path
!!         return
         end
       end
!!     @current_deliverables = Deliverable.find_current_by_user(user)
!!     @past_deliverables = Deliverable.find_past_by_user(user)
!!     @current_assignments = Assignment.list_assignments_for_student(user.id, :current)
!!     @current_courses = user.registered_for_these_courses_during_current_semester()
!!     @past_assignments = Assignment.list_assignments_for_student(user.id, :past)
!!     @past_courses = user.registered_for_these_courses_during_past_semesters()
!!     respond_to do |format|
!!       format.html { render :action => "index" }
!!       format.xml { render :xml => @deliverables }
       end
     end
   
     # GET /deliverables/1
     # GET /deliverables/1.xml
     def show
!!     @deliverable = Deliverable.find(params[:id])
!!     @course = @deliverable.course
!!     @hostname_with_port = request.host_with_port
!!     unless @deliverable.editable?(current_user)
!!       flash[:error] = I18n.t(:not_your_deliverable)
!!       redirect_to root_path and return
       end
   
!!     if (current_user.is_admin? || @course.faculty.include?(current_user))
!!       if @course.grading_rule.nil?
!!         flash[:error] = I18n.t(:no_grading_rule_for_course)
!!         redirect_to course_path(@course) and return
         end
!!       if @course.grading_rule.default_values?
!!         flash.now[:error] = I18n.t(:default_grading_rule_for_course)
         end
       end
   
!!     respond_to do |format|
!!       if (current_user.is_admin? || @course.faculty.include?(current_user))
!!         format.html { render layout: false }
         else
!!         format.html # show.html.erb
!!         format.xml { render :xml => @deliverable }
         end
   
       end
     end
   
     # GET /deliverables/new
     # GET /deliverables/new.xml
     def new
       # If we aren't on this deliverable's team, you can't see it.
!!     @deliverable = Deliverable.new(:creator => current_user)
!!     @courses = current_user.registered_for_these_courses_during_current_semester
   
!!     if params[:course_id]
!!       @deliverable.course_id = params[:course_id]
!!       @assignments = Course.find(params[:course_id]).assignments.where(:is_submittable => true)
       else
!!       if @courses.empty?
!!         @assignments = []
         else
!!         @assignments = @courses[0].assignments.where(:is_submittable => true)
         end
       end
   
   
!!     respond_to do |format|
!!       format.html # new.html.erb
!!       format.xml { render :xml => @deliverable }
       end
     end
   
     # GET /deliverables/1/edit
     def edit
!!     @deliverable = Deliverable.find(params[:id])
   
!!     @courses = current_user.registered_for_these_courses_during_current_semester
!!     @assignments = @deliverable.course.assignments.where(:is_submittable => true)
   
!!     unless @deliverable.editable?(current_user)
!!       flash[:error] = I18n.t(:not_your_deliverable)
!!       redirect_to root_path and return
       end
     end
   
     # POST /deliverables
     # POST /deliverables.xml
     def create
       # Make sure that a file was specified
!!     @deliverable = Deliverable.new(params[:deliverable])
!!     @deliverable.creator = current_user
!!     @deliverable.is_team_deliverable ? @deliverable.update_team : @deliverable.team = nil
   
!!     if @deliverable.is_team_deliverable && @deliverable.team == nil
!!       flash[:error] = "You are not on a team in this course, so you can't submit a team deliverable"
!!       respond_to do |format|
!!         format.html { render :action => "new" }
!!         format.xml { render :xml => @deliverable.errors, :status => :unprocessable_entity }
         end
!!       return
       end
   
!!     if !params[:deliverable_attachment][:attachment]
!!       flash[:error] = 'Must specify a file to upload'
!!       respond_to do |format|
!!         format.html { render :action => "new" }
!!         format.xml { render :xml => @deliverable.errors, :status => :unprocessable_entity }
         end
!!       return
       end
!!     @attachment = DeliverableAttachment.new(params[:deliverable_attachment])
!!     @attachment.submitter = @deliverable.creator
!!     @deliverable.attachment_versions << @attachment
!!     @attachment.deliverable = @deliverable
   
!!     respond_to do |format|
!!       if @attachment.valid? and @deliverable.valid? and @deliverable.save
!!         @deliverable.send_deliverable_upload_email(url_for(@deliverable))
!!         flash[:notice] = 'Deliverable was successfully created.'
!!         format.html { redirect_to(@deliverable) }
!!         format.xml { render :xml => @deliverable, :status => :created, :location => @deliverable }
         else
!!         if not @attachment.valid?
!!           flash[:notice] = 'Attachment not valid'
           elsif not @deliverable.valid?
!!           flash[:notice] = 'Deliverable not valid'
           else
!!           flash[:notice] = 'Something else went wrong'
           end
!!         format.html { render :action => "new" }
!!         format.xml { render :xml => @deliverable.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # PUT /deliverables/1
     # PUT /deliverables/1.xml
     def update
!!     @deliverable = Deliverable.find(params[:id])
   
   #    params[:is_team_deliverable] ? @deliverable.update_team : @deliverable.team = nil
!!     @deliverable.is_team_deliverable ? @deliverable.update_team : @deliverable.team = nil
   
!!     unless @deliverable.editable?(current_user)
!!       flash[:error] = I18n.t(:not_your_deliverable)
!!       redirect_to root_path and return
       end
   
!!     there_is_an_attachment = params[:deliverable_attachment][:attachment]
!!     if there_is_an_attachment
   
!!       @attachment = DeliverableAttachment.new(params[:deliverable_attachment])
!!       @attachment.submitter = current_user
!!       @deliverable.attachment_versions << @attachment
!!       @attachment.deliverable = @deliverable
   
!!       if @attachment.valid? and @deliverable.valid? and @deliverable.update_attributes(params[:deliverable])
!!         @deliverable.send_deliverable_upload_email(url_for(@deliverable))
!!         flash[:notice] = 'Deliverable was successfully updated.'
!!         redirect_to(@deliverable)
         else
!!         render :action => "edit"
         end
       else
!!       if @deliverable.valid? and @deliverable.update_attributes(params[:deliverable])
!!         flash[:notice] = 'Deliverable was successfully updated.'
!!         redirect_to(@deliverable)
         else
!!         render :action => "edit"
         end
       end
   
   
     end
   
     # DELETE /deliverables/1
     # DELETE /deliverables/1.xml
     def destroy
!!     @deliverable = Deliverable.find(params[:id])
   
!!     unless @deliverable.editable?(current_user)
!!       flash[:error] = I18n.t(:not_your_deliverable)
!!       redirect_to root_path and return
       end
!!     @deliverable.destroy
   
!!     respond_to do |format|
!!       format.html { redirect_to(deliverables_url) }
!!       format.xml { head :ok }
       end
     end
   
     def edit_feedback
!!     if @course.grading_rule.nil?
!!       flash[:error] = I18n.t(:no_grading_rule_for_course)
!!       redirect_to course_path(@course) and return
       end
   
!!     @deliverable = Deliverable.find(params[:id])
   
   #    if !@deliverable.assignment.course.faculty.include?(current_user)
   #      flash[:error] = "Only faculty teaching this course can provide feedback on deliverables. #{current_user.human_name}"
   #      redirect_to :controller => "welcome", :action => "index"
   #      return
   #    end
     end
   
   
     def update_feedback
!!     @deliverable = Deliverable.find(params[:id])
   
!!     unless (current_user.is_admin? || @deliverable.course.faculty.include?(current_user))
!!       flash[:error] = I18n.t(:not_your_deliverable)
!!       redirect_to root_path and return
       end
   
       # check is save and email is clicked or save as draft is clicked
!!     is_student_visible=true
!!     if params[:submit]
!!       is_student_visible=true
!!       @deliverable.update_attributes(:grade_status => "graded")
       elsif params[:draft]
!!       is_student_visible=false
!!       @deliverable.update_attributes(:grade_status => "drafted")
       end
   
   
!!     flash[:error] = @deliverable.update_grade(params, is_student_visible, current_user.id)
!!     other_email = nil
!!     if params[:send_copy_to_myself] == "1"
!!       other_email = current_user.email
       end
!!     if @deliverable.update_feedback_and_notes(params[:deliverable])
!!       if is_student_visible == true
!!         @deliverable.send_deliverable_feedback_email(url_for(@deliverable), other_email)
         end
       else
!!       flash[:error] << 'Unable to save feedback'
       end
   
       #Obtain current selected filters to update the queue accordingly
!!     if params[:deliverable][:current_filter_options].present?
!!       @selected_filter_options = JSON.parse(params[:deliverable][:current_filter_options])
       else
!!       @selected_filter_options = Hash.new
       end
!!     @deliverables = filter_deliverables(@deliverable.course_id, @selected_filter_options)
   
!!     respond_to do |format|
!!       if flash[:error].blank?
!!         flash[:error] = nil
!!         flash[:notice] = 'Feedback successfully saved.'
!!         format.js
         else
!!         flash[:error] = flash[:error].join("<br>")
!!         format.html { redirect_to(@deliverable) }
         end
       end
     end
   
     #Todo: rename this method
     #get_assginemments_for_course
     #shouldn't this be in the assignments controller?
     def get_assignments_for_student
!!     unless params[:course_id].nil?
!!       @assignments = Course.find(params[:course_id]).assignments.all(:conditions => ["is_submittable = ?", true])
!!       @assignments_array = @assignments.collect { |assignment| {:assignment => assignment.attributes.merge({:name_with_type => assignment.name_with_type})} }
!!       respond_to do |format|
!!         format.json { render json: @assignments_array }
         end
       end
     end
   
     private
     def filter_deliverables (course_id, filter_options)
       @course = Course.find_by_id(course_id)
   
       # Prepare filter options according to what users select on the page
       options = {}
       if filter_options[:search_box] != ""
         options[:search_string] = filter_options[:search_box]
       end
   
       if filter_options['is_my_teams'] == 'yes'
         options[:is_my_team] = 1
       else
!!       options[:is_my_team] = 0
       end
   
   
       # Filter in the model by course, professor, my teams and search input
       @deliverables = []
       @faculty_deliverables = Deliverable.get_deliverables(course_id, current_user.id, options)
   
       # Filter once again according to the selected grading options. If no filter options are selected,
       # display every deliverable
!!     @selected_options = []
!!     filter_options.collect do |filter_option|
!!       @selected_options << filter_option[0].to_sym if filter_option[1] == "1"
       end
!!     if @selected_options.size == 0
!!       @deliverables = @faculty_deliverables
       else
!!       @selected_options.each do |option|
   #        @deliverables.concat(@faculty_deliverables.select { |deliverable| deliverable.get_grade_status == option })
!!         @deliverables.concat(@faculty_deliverables.select { |deliverable| deliverable.grade_status == option.to_s })
         end
       end
   
       # Filter by assignment names in drop down menu
!!     unless filter_options["assignment_id"] == '-1'
!!       @deliverables = @deliverables.select { |deliverable| deliverable.assignment_id == filter_options[
!!           "assignment_id"].to_i }
       end
   
!!     @deliverables = @deliverables.sort { |a, b| b.assignment.assignment_order <=> a.assignment.assignment_order }
     end
   
   end
   

================================================================================
 ./app/controllers/effort_log_line_items_controller.rb
================================================================================
   #
   #
   # Todo: consider removing this controller entirely.....
   #
   #
   #
   class EffortLogLineItemsController < ApplicationController
     # GET /effort_log_line_items
     # GET /effort_log_line_items.xml
   
     before_filter :redirect_to_effort_log_index
   
     def index
!!     @effort_log_line_items = EffortLogLineItem.all
   
!!     respond_to do |format|
!!       format.html # index.html.erb
!!       format.xml { render :xml => @effort_log_line_items }
       end
     end
   
     # GET /effort_log_line_items/1
     # GET /effort_log_line_items/1.xml
     def show
!!     @effort_log_line_item = EffortLogLineItem.find(params[:id])
   
!!     respond_to do |format|
!!       format.html # show.html.erb
!!       format.xml { render :xml => @effort_log_line_item }
       end
     end
   
     # GET /effort_log_line_items/new
     # GET /effort_log_line_items/new.xml
     def new
!!     @effort_log_line_item = EffortLogLineItem.new
   
!!     respond_to do |format|
!!       format.html # new.html.erb
!!       format.xml { render :xml => @effort_log_line_item }
       end
     end
   
     # GET /effort_log_line_items/1/edit
     def edit
   
!!     @effort_log_line_item = EffortLogLineItem.find(params[:id])
     end
   
     # POST /effort_log_line_items
     # POST /effort_log_line_items.xml
     def create
!!     @effort_log_line_item = EffortLogLineItem.new(params[:effort_log_line_item])
   
!!     respond_to do |format|
!!       if @effort_log_line_item.save
!!         flash[:notice] = 'EffortLogLineItem was successfully created.'
!!         format.html { redirect_to(@effort_log_line_item) }
!!         format.xml { render :xml => @effort_log_line_item, :status => :created, :location => @effort_log_line_item }
         else
!!         format.html { render :action => "new" }
!!         format.xml { render :xml => @effort_log_line_item.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # PUT /effort_log_line_items/1
     # PUT /effort_log_line_items/1.xml
     def update
!!     @effort_log_line_item = EffortLogLineItem.find(params[:id])
   
!!     respond_to do |format|
!!       if @effort_log_line_item.update_attributes(params[:effort_log_line_item])
!!         flash[:notice] = 'EffortLogLineItem was successfully updated.'
!!         format.html { redirect_to(@effort_log_line_item) }
!!         format.xml { head :ok }
         else
!!         format.html { render :action => "edit" }
!!         format.xml { render :xml => @effort_log_line_item.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # DELETE /effort_log_line_items/1
     # DELETE /effort_log_line_items/1.xml
     def destroy
!!     @effort_log_line_item = EffortLogLineItem.find(params[:id])
!!     @effort_log_line_item.destroy
   
!!     respond_to do |format|
!!       format.html { redirect_to(effort_log_line_items_url) }
!!       format.xml { head :ok }
       end
     end
   
     protected
     def redirect_to_effort_log_index
!!     redirect_to :controller => :effort_logs, :action => :index
     end
   end

================================================================================
 ./app/controllers/effort_logs_controller.rb
================================================================================
   class EffortLogsController < ApplicationController
   #  layout "cmu_sv_no_pad", :except => :new_effort_log_line_item
   
   #  layout 'cmu_sv_no_pad', :only => [:index, :show]
     layout 'simple'
   
     before_filter :authenticate_user!, :except => [:create_midweek_warning_email, :create_endweek_admin_email]
   
   
     # Todo: consider moving these email methods to the model(EffortLogs) and update the rake task accordingly
     #
     def create_midweek_warning_email
       if (!EffortLog.log_effort_week?(Date.today.cwyear, Date.today.cweek))
         #We skip weeks that students aren't taking courses
         logger.info "There is no class this week, so we won't remind students to log effort"
         return
       end
   
       random_scotty_saying = ScottyDogSaying.all.sample.saying
   
       courses = Course.remind_about_effort_course_list
       courses.each do |course_id|
         create_midweek_warning_email_for_course(random_scotty_saying, course_id)
       end
   
     end
   
     def create_midweek_warning_email_for_course(random_scotty_saying, course_id)
       year = Date.today.cwyear
       week_number = Date.today.cweek
   
       course = Course.find(course_id)
       users = course.registered_students | course.teams.collect { |team| team.members }.flatten
       users.each do |user|
         logger.debug "**    user #{user.human_name}"
         effort_log = EffortLog.where(:user_id => user.id, :week_number => week_number, :year => year).first
         if (!user.emailed_recently(:effort_log))
           EffortLogMailer.midweek_warning(random_scotty_saying, user).deliver
           user.effort_log_warning_email = Time.now
           user.save
         end
       end
     end
   
     def create_endweek_faculty_email
!!     notify_course_list = Course.remind_about_effort_course_list
   
       #notify_course_list = [48, 47, 46]  #list all courses that we want to track effort
!!     last_week = (Date.today - 7).cweek
!!     last_week_year = (Date.today -7).cwyear
   
!!     if (!EffortLog.log_effort_week?(last_week_year, last_week))
!!       logger.info "There was no class last week, so we won't remind students to log effort"
!!       return
       end
   
!!     notify_course_list.each do |course|
!!       faculty = {}
!!       teams = Team.where(:course_id => course.id)
!!       teams.each do |team|
!!         faculty[team.primary_faculty_id] = 1 unless team.primary_faculty_id.nil?
!!         faculty[team.secondary_faculty_id] = 1 unless team.secondary_faculty_id.nil?
         end
!!       faculty_emails = []
!!       faculty.each { |faculty_id, value| faculty_emails << User.find_by_id(faculty_id).email }
!!       EffortLogMailer.endweek_admin_report(course.id, course.name, faculty_emails).deliver
       end
     end
   
     def update_task_type_select
!!     unless params[:task_id].blank?
!!       logger.debug "updated " + params[:task_id]
!!       @selected_type = TaskType.find_by_id(params[:task_id])
       end
   
!!     render :partial => "description_update"
     end
   
     # GET /effort_logs
     # GET /effort_logs.xml
     def index
!!     @effort_logs = EffortLog.find_effort_logs(current_user)
   
!!     if Date.today.cweek == 1 #If the first week of the year, then we set to the last week of previous year
!!       @prior_week_number = 52
!!       @year = Date.today.cwyear - 1
       else
!!       @prior_week_number = Date.today.cweek - 1
!!       @year = Date.today.cwyear
       end
   
       # if no effort logs created
!!     if @effort_logs.empty?
         # show new current link
!!       @show_new_link = true
   
         # if no effort logs created and today is Monday, then show new prior link
!!       if Date.today.cwday == 1
!!         @show_prior_week = true
         else
!!         @show_prior_week = false
         end
       else
         # if most recent effort log is for current period, then don't show new current link, else show new current link
!!       if @effort_logs[0].year == Date.today.cwyear && @effort_logs[0].week_number == Date.today.cweek
!!         @show_new_link = false
         else
!!         @show_new_link = true
         end
   
         # start by always showing prior week link
!!       @show_prior_week = true
   
         #if today is Monday, evaluate, otherwise don't show prior week link
!!       if Date.today == Date.commercial(Date.today.cwyear, Date.today.cweek, 1)
           # if most recent log is a match, then don't show prior week link
!!         if (@effort_logs[0].year == @year && @effort_logs[0].week_number == @prior_week_number)
!!           @show_prior_week = false
           end
           # if second most recent entry is a match, then don't show prior week link
!!         if @effort_logs[1]
!!           if (@effort_logs[1].year == @year && @effort_logs[1].week_number == @prior_week_number)
!!             @show_prior_week = false
             end
           end
         else
           # if not Monday, don't ever show the prior week link
!!         @show_prior_week = false
         end
       end
   
!!     respond_to do |format|
!!       format.html # index.html.erb
!!       format.xml { render :xml => @effort_logs }
       end
     end
   
     # GET /effort_logs/1
     # GET /effort_logs/1.xml
     def show
!!     @effort_log = EffortLog.find(params[:id])
!!     setup_required_datastructures(@effort_log.year, @effort_log.week_number)
   
!!     respond_to do |format|
!!       format.html # show.html.erb
!!       format.xml { render :xml => @effort_log }
       end
     end
   
   
     # GET /effort_logs/new
     # GET /effort_logs/new.xml
     def new
!!     if params[:prior] == 'true' then
!!       if Date.today.cweek == 1
!!         week_number = 52
!!         year = Date.today.cwyear -1
         else
!!         week_number = Date.today.cweek - 1
!!         year = Date.today.cwyear
         end
!!       error_msg = "There already is an effort log for the previous week"
       else
!!       week_number = Date.today.cweek
!!       year = Date.today.cwyear
!!       error_msg = "There already is an effort log for the current week"
       end
!!     setup_required_datastructures(year, week_number)
   
!!     @effort_log = EffortLog.new
!!     @effort_log.user_id = current_user.id
   
       #find the most recent effort log to copy its structure, but not its effort data
!!     recent_effort_log = EffortLog.where(:user_id => current_user.id).order("year DESC, week_number DESC").first
   
       # We want to make sure that the user isn't accidentally creating two efforts for the same week.
       # Since students are only able to log effort for this week (or a previous week)
!!     if recent_effort_log and recent_effort_log.week_number == week_number
         #Yes we already have effort for this week
!!       duplicate_effort_log = recent_effort_log
       else
         #Do we already have effort for the week we are trying to log effort against?
!!       duplicate_effort_log = EffortLog.where(:user_id => current_user.id, :week_number => week_number, :year => year).first
       end
   
!!     if duplicate_effort_log
!!       logger.debug "We should not be creating another effort log for week #{week_number}"
!!       flash[:error] = error_msg
!!       redirect_to(effort_logs_url) and return
       end
   
!!     if recent_effort_log
!!       logger.debug "Copy effort log from week #{recent_effort_log.week_number}"
!!       recent_effort_log.effort_log_line_items.each do |line|
!!         @effort_log.effort_log_line_items << EffortLogLineItem.new(:course_id => line.course_id, :task_type_id => line.task_type_id)
         end
       else
!!       logger.debug "This is the first effort log for the person in the system"
   
!!       course = recent_foundations_or_course
!!       course_id = course.id
   
!!       @task_types.each do |task_type|
!!         @effort_log.effort_log_line_items << EffortLogLineItem.new(:course_id => course_id, :task_type_id => task_type.id)
         end
       end
   
       # Ps. if we wanted to have an effort log with a single effort log line item that is blank, then this would do it       @effort_log.effort_log_line_items.build      
   
   
!!     @effort_log.year = year
!!     @effort_log.week_number = week_number
   
   #          format.html # new.html.erb
   #      format.xml  { render :xml => @effort_log }
   
   
!!     respond_to do |format|
!!       if @effort_log.save
!!         flash[:notice] = 'EffortLog was successfully created.'
!!         format.html { redirect_to(edit_effort_log_url(@effort_log.id)) }
!!         format.xml { render :xml => @effort_log, :status => :created, :location => @effort_log }
         else
!!         flash[:notice] = 'Unable to create new EffortLog.'
!!         format.html { redirect_to(effort_logs_url) }
!!         format.xml { render :xml => @effort_log.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # GET /effort_logs/1/edit
     def edit
!!     @effort_log = EffortLog.find(params[:id])
   
   #    if @effort_log.week_number != Date.today.cweek
!!     if !@effort_log.editable_by(current_user)
!!       flash[:error] = 'You do not have permission to edit the effort log.'
!!       redirect_to(effort_logs_url) and return
       end
   #    if !@effort_log.has_permission_to_edit_period(current_user)
   #      flash[:error] = 'You are unable to update effort logs from the past.'
   #      redirect_to(effort_logs_url) and return
   #    end
!!     setup_required_datastructures(@effort_log.year, @effort_log.week_number)
     end
   
     # POST /effort_logs
     # POST /effort_logs.xml
     def create
!!     @effort_log = EffortLog.new(params[:effort_log])
   
!!     setup_required_datastructures(@effort_log.year, @effort_log.week_number)
   
   
!!     respond_to do |format|
!!       if @effort_log.save
!!         course_error_msg = @effort_log.validate_effort_against_registered_courses()
!!         flash[:notice] = 'EffortLog was successfully created.'
!!         if (course_error_msg!="")
!!           flash[:error] = 'You are not on a team in the following course(s) ' + course_error_msg
           end
!!         format.html { redirect_to(@effort_log) }
!!         format.xml { render :xml => @effort_log, :status => :created, :location => @effort_log }
         else
!!         format.html { render :action => "new" }
!!         format.xml { render :xml => @effort_log.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # PUT /effort_logs/1
     # PUT /effort_logs/1.xml
     def update
!!     params[:effort_log][:existing_effort_log_line_item_attributes] ||= {}
   
!!     @effort_log = EffortLog.find(params[:id])
!!     if !@effort_log.editable_by(current_user)
!!       flash[:error] = 'You do not have permission to edit the effort log.'
!!       redirect_to(effort_logs_url) and return
       end
   #    if !@effort_log.has_permission_to_edit_period(current_user)
   #      flash[:error] = 'You are unable to update effort logs from the past.'
   #      redirect_to(effort_logs_url) and return
   #    end
   
!!     setup_required_datastructures(@effort_log.year, @effort_log.week_number)
   
!!     respond_to do |format|
!!       if @effort_log.update_attributes(params[:effort_log])
           #check to see if user is logging effort for unregistered courses
!!         course_error_msg = @effort_log.validate_effort_against_registered_courses()
!!         flash[:notice] = 'EffortLog was successfully updated.'
!!         if (course_error_msg!="")
!!           flash[:error] = 'You are not on a team in the following course(s)<br/>' + course_error_msg
           end
!!         format.html { redirect_to(edit_effort_log_url) }
!!         format.xml { head :ok }
         else
!!         format.html { render "edit" }
!!         format.xml { render :xml => @effort_log.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # DELETE /effort_logs/1
     # DELETE /effort_logs/1.xml
     def destroy
!!     @effort_log = EffortLog.find(params[:id])
!!     @effort_log.destroy
   
!!     respond_to do |format|
!!       format.html { redirect_to(effort_logs_url) }
!!       format.xml { head :ok }
       end
     end
   
     def effort_for_unregistered_courses
!!     @error_effort_logs_users = EffortLog.users_with_effort_against_unregistered_courses()
!!     respond_to do |format|
!!       format.html
!!       format.xml { render :xml => @error_effort_logs_users }
       end
     end
   
     #Typically an ajax call
     def new_effort_log_line_item
!!     setup_required_datastructures(Date.today.cwyear, Date.today.cweek)
!!     @effort_log_line_item = EffortLogLineItem.new
!!     @effort_log_line_item.effort_log_id = params[:effort_log_id]
!!     @effort_log_line_item.save
     end
   
     private
   
     def setup_required_datastructures(year, week_number)
!!     @day_labels = [1, 2, 3, 4, 5, 6, 7].collect do |day|
!!       Date.commercial(year, week_number, day).strftime "%b %d" # Jul 01
       end
   
!!     @courses = Course.where(:year => Date.today.cwyear, :semester => AcademicCalendar.current_semester())
   
!!     @task_types = TaskType.where(:is_student => true)
   
!!     @today_column = which_column_is_today(year, week_number)
     end
   
     def which_column_is_today year, week_number
!!     column = "none"
!!     [1, 2, 3, 4, 5, 6, 7].collect do |day|
!!       column = day if Date.commercial(year, week_number, day) == Date.today
       end
!!     return column
     end
   
     def recent_foundations_or_course
   #    name = "Foundations"
   #    recent_foundations = Course.find :first, :conditions =>  ["name like ?", "%" + name + "%"], :order => "year DESC"
   #    if !recent_foundations.nil? 
   #      return recent_foundations
   #    end
!!     Course.order("id DESC").first
     end
   
   
   end

================================================================================
 ./app/controllers/effort_reports_controller.rb
================================================================================
   class EffortReportsController < ApplicationController
   
     layout 'cmu_sv', :only => [:index, :show, :campus_semester, :campus_week, :course]
   
     before_filter :authenticate_user!
   
     class PanelState
       attr_accessor :year, :week_number, :course_id, :date
     end
     class SemesterPanel
       attr_accessor :program, :track, :graduation_year, :is_part_time, :person_id, :course_id, :semester, :year
   
       def generate_sql(just_student = nil)
   
!!       if (self.course_id.blank?)
!!         sql_statement = "select distinct el.week_number, el.sum as student_effort, el.user_id "
         else
!!         sql_statement = "select el.week_number, e.sum as student_effort, el.user_id "
         end
!!       sql_statement = sql_statement + "from effort_log_line_items e, effort_logs el,courses c, users u
         where e.sum>0 and e.course_id=c.id and e.effort_log_id=el.id and el.user_id= u.id and el.year=c.year"
!!       sql_statement = sql_statement + " AND el.year=#{self.year}"
!!       sql_statement = sql_statement + " and e.course_id=#{self.course_id}" unless self.course_id.blank?
!!       sql_statement = sql_statement + " and c.semester='#{self.semester}'"
!!       sql_statement = sql_statement + " and u.graduation_year='#{self.graduation_year}'" unless self.graduation_year.blank?
!!       sql_statement = sql_statement + " and u.masters_program='#{self.program}'" unless self.program.blank?
!!       sql_statement = sql_statement + " and u.masters_track='#{self.track}'" unless self.track.blank?
!!       case self.is_part_time
           when "PT"
!!           sql_statement = sql_statement + " and u.is_part_time is true"
           when "FT"
!!           sql_statement = sql_statement + " and u.is_part_time is false"
         end
!!       sql_statement = sql_statement + " and el.user_id=#{self.person_id}" if just_student && !self.person_id.blank?
   
!!       sql_statement = sql_statement + " order by el.week_number"
!!       return sql_statement
       end
     end
   
     def get_course_data(year, week_number, course_id)
!!     effort_logs = EffortLog.find_by_sql("select task_type_id, t.name, e.sum as student_effort from effort_log_line_items e,effort_logs el,task_types t where e.sum>0 and e.task_type_id=t.id and e.effort_log_id=el.id AND el.year=#{year} and el.week_number=#{week_number} AND e.course_id=#{course_id} order by task_type_id;")
   
!!     task_type_id_to_value_array_hash = {}
!!     effort_logs.each do |effort_log|
!!       key = effort_log.task_type_id
!!       value = effort_log.student_effort.to_f
!!       task_type_id_to_value_array_hash[key] = [] if task_type_id_to_value_array_hash[key].nil?
!!       task_type_id_to_value_array_hash[key] << value
       end
   
!!     values_array = []
!!     task_type_id_to_value_array_hash.each do |task_type_id, values|
!!       values_array << ([TaskType.find(task_type_id).name] + course_ranges_array(values))
       end
!!     return values_array
     end
   
   
     def get_campus_week_data(year, week_number)
!!     effort_logs = EffortLog.where("week_number=? AND year=? AND sum>0", week_number.to_i, year.to_i)
   
!!     course_id_to_value_array_hash = {}
!!     effort_logs.each do |effort_log|
!!       course_to_person_hash = {}
!!       effort_log.effort_log_line_items.each do |line_item|
!!         unless line_item.course_id == nil
!!           course_to_person_hash[line_item.course_id] = 0 if course_to_person_hash[line_item.course_id].nil?
!!           course_to_person_hash[line_item.course_id] += line_item.sum
           end
         end
!!       course_to_person_hash.each do |course_id, sum|
!!         course_id_to_value_array_hash[course_id] = [] if course_id_to_value_array_hash[course_id].nil?
!!         course_id_to_value_array_hash[course_id] << sum
         end
       end
   
!!     values_array = []
!!     course_id_to_value_array_hash.each do |course_id, values|
!!       values_array << ([Course.find_by_id(course_id).short_or_full_name] + course_ranges_array(values))
       end
!!     return values_array
     end
   
   
     def get_campus_semester_data(panel)
!!     logger.debug panel.generate_sql()
   
!!     effort_logs = EffortLog.find_by_sql(panel.generate_sql())
   
       #The data we get is not sorted by week number and it is indexed by the commercial week of the year
       #At the beginning of a semester we want to show all the weeks in a semester
       #So we need to do a little calculation to figure out which week to start and end.
   
       #The code is not adding multiple entries per student together. Ie meetings and working on deliverables for a course
   
!!     unless effort_logs.blank?
!!       first_dataset_week_number = effort_logs.first.week_number
!!       last_dataset_week_number = effort_logs.last.week_number
!!       weeks_in_semester = 15
!!       weeks_in_report = [weeks_in_semester, (last_dataset_week_number - first_dataset_week_number + 1)].max
       else
!!       weeks_in_report = 15
       end
   
   
       # When the view is for only one course, a student will have logged effort for different types (meetings, deliverable)
       # Each of these is a row in the returnset, so we need to add up all the effort the student did for that course for
       # a given week
!!     student_effort_accumulator = {}
!!     effort_logs.each do |effort_log|
!!       key = [effort_log.week_number - first_dataset_week_number, effort_log.user_id]
!!       value = effort_log.student_effort.to_f
!!       if student_effort_accumulator[key].nil?
!!         student_effort_accumulator[key] = value
         else
!!         student_effort_accumulator[key] = student_effort_accumulator[key] + value
         end
       end
   
!!     week_number_to_value_array_array = []
!!     person_hours = []
!!     weeks_in_report.times do |i|
!!       week_number_to_value_array_array[i] = []
!!       person_hours[i] = 0
       end
   
!!     student_effort_accumulator.each do |array, hours|
!!       key = array[0] #week_number
!!       value = hours
!!       week_number_to_value_array_array[key] = [] if week_number_to_value_array_array[key].nil?
!!       week_number_to_value_array_array[key] << value
       end
   
       #Determine the effort for a particular, selected student
!!     unless panel.person_id.blank?
!!       a = panel.person_id
!!       student_effort_accumulator.each do |array, hours|
!!         week_number = array[0]
!!         person_id = array[1]
!!         person_hours[week_number] = hours if panel.person_id == person_id
         end
       end
   
!!     values_array = []
!!     week_number_to_value_array_array.each_index do |week_number|
!!       values = week_number_to_value_array_array[week_number]
!!       unless panel.person_id.blank?
!!         values_array << ([week_number + 1] + course_ranges_array(values) + [person_hours[week_number]])
         else
!!         values_array << ([week_number + 1] + course_ranges_array(values))
         end
       end
   
!!     return values_array
     end
   
   
   #  def box_chart_helper(reports, multiplier)
   ##        return "-1,"+ values.map{|v| (v ? "%.2f" % (v*multiplier):0)}.join(",") + ",-1"
   #    puts "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
   #    puts reports.values.join(",")
   #    puts reports.keys.join(",")
   #    str = "-1,"
   #    reports.keys.sort.each do |key|
   #      v = reports[key]
   #      #puts "LENNNNNNNNNNNN %d" % v.length
   #      if !v.nil?
   #        puts v
   #        #str = str + (!v.nil? ? ("%.2f" % (v*multiplier)) : 0.0).to_s  + ","
   #        str = str + "%.2f" % (v*multiplier) + ","
   #      else
   #        puts "=EMPTY="
   #        str = str + "0,"
   #      end
   #    end
   #    str += "-1"
   #    return str
   #  end
   
   
     def generate_google_box_chart(title, reports)
!!     title_str = title.gsub(' ', '+')
   
       # Datastructure of the reports
       # array: [course_name, min, 25, median, 75, max]
       # array: [course_name, min, 25, median, 75, max, student_data] #used in campus semester view
   
!!     if reports && reports.size > 0
!!       max_value = reports.collect { |r| r[5] }.max
   
!!       multiplier = 100.0/(max_value)
!!       multiplier = 1 if max_value <= 0.0
   
!!       minimums_str = "-1," + reports.collect { |r| "%.2f"%(r[1]*multiplier) }.join(",")+",-1"
!!       lower25_str = "-1," + reports.collect { |r| "%.2f"%(r[2]*multiplier) }.join(",")+",-1"
!!       medians_str = "-1," + reports.collect { |r| "%.2f"%(r[3]*multiplier) }.join(",")+",-1"
!!       upper25_str = "-1," + reports.collect { |r| "%.2f"%(r[4]*multiplier) }.join(",")+",-1"
!!       maximums_str = "-1," + reports.collect { |r| "%.2f"%(r[5]*multiplier) }.join(",")+",-1"
!!       if reports.first[6].blank?
!!         outliers_str = ""
         else
!!         outliers_str = "|-1," + reports.collect { |r| "%.2f"%(r[6]*multiplier) }.join(",")+",-1"
         end
   
!!       labels_str = "|"+reports.collect { |r| r[0] }.join("|")+"|"
   
!!       url = "http://chart.apis.google.com/chart?chtt="+title_str+"&chxt=x,y&chs=700x400&cht=lc&chd=t0:" +
             minimums_str + "|" + lower25_str + "|" + upper25_str + "|" + maximums_str + "|" + medians_str + outliers_str +
             "&chl=" + labels_str + #get course_id and course_name from DB
             "&chm=F,FF9900,0,-1,25|H,0CBF0B,0,-1,1:10|H,000000,4,-1,1:25|H,0000FF,3,-1,1:10" +
             "|o,FF0000,5,-1,7|o,FF0000,6,-1,7" +
!!           "&chxr=1,0," + (max_value).to_s
!!       return url
       else
!!       return "http://chart.apis.google.com/chart?chtt="+ title_str+ "&chxt=x,y&chs=700x400&cht=lc&chd=t0:-1,0,0,0,-1|-1,0,0,0,-1|-1,0,0,0,-1|-1,0,0,0,-1|-1,0,0,0,-1&chm=F,FF9900,0,-1,25|H,0CBF0B,0,-1,1:10|H,000000,4,-1,1:25|H,0000FF,3,-1,1:10&chxr=1,0,15"
       end
     end
   
     def determine_panel_state
!!     if params[:panel_state]
!!       @panel_state = PanelState.new
!!       @panel_state.year = params[:panel_state][:year]
!!       @panel_state.week_number = params[:panel_state][:week_number]
!!       @panel_state.date = params[:panel_state][:date]
!!       logger.debug(params[:panel_state][:date])
!!       if !@panel_state.date.blank?
!!         panel_date = Date.parse(@panel_state.date)
!!         @panel_state.year = panel_date.cwyear
!!         @panel_state.week_number = panel_date.cweek
   
         end
       else
!!       @panel_state = PanelState.new
!!       @panel_state.year = Date.today.cwyear
!!       @panel_state.week_number = Date.today.cweek - 1
       end
     end
   
     def campus_semester
!!     if params[:semester_panel]
!!       @semester_panel = SemesterPanel.new
!!       @semester_panel.program = params[:semester_panel][:program]
!!       @semester_panel.track = params[:semester_panel][:track]
!!       @semester_panel.graduation_year = params[:semester_panel][:graduation_year]
!!       @semester_panel.is_part_time = params[:semester_panel][:is_part_time]
!!       @semester_panel.person_id = params[:semester_panel][:person_id].to_i unless params[:semester_panel][:person_id].blank?
!!       @semester_panel.course_id = params[:semester_panel][:course_id].to_i unless params[:semester_panel][:course_id].blank?
!!       @semester_panel.semester = params[:semester_panel][:semester]
!!       @semester_panel.year = params[:semester_panel][:year]
       else
!!       @semester_panel = SemesterPanel.new
!!       @semester_panel.program = current_user.is_student ? current_user.masters_program : "SE"
!!       @semester_panel.track = ""
!!       @semester_panel.graduation_year = ""
!!       @semester_panel.is_part_time = current_user.is_student && !current_user.is_part_time ? "FT" : "PT"
!!       @semester_panel.person_id = current_user.is_student ? current_user.id : ""
!!       @semester_panel.course_id = ""
!!       @semester_panel.semester = AcademicCalendar.current_semester
!!       @semester_panel.year = Date.today.cwyear
       end
   
!!     if current_user.is_staff || current_user.is_admin
!!       @students = Person.where(:is_student => true).order("first_name ASC, last_name ASC")
       else
!!       @students = [current_user]
       end
!!     @courses = Course.where(:semester => @semester_panel.semester, :year => @semester_panel.year).order("name ASC")
!!     @programs = []
   
!!     ActiveRecord::Base.connection.execute("SELECT distinct masters_program FROM users u;").each do |result|
!!       @programs << result["masters_program"]
       end
!!     @tracks = []
!!     ActiveRecord::Base.connection.execute("SELECT distinct masters_track FROM users u;").each do |result|
!!       @tracks << result["masters_track"]
       end
   
!!     title = "Campus View - " + @semester_panel.semester + " " + @semester_panel.year.to_s
!!     reports = get_campus_semester_data(@semester_panel)
!!     @chart_url = generate_google_box_chart(title, reports)
   
   
!!     respond_to do |format|
!!       if params[:layout]
!!         format.html { render :layout => false } # index.html.erb
         else
!!         format.html { render :layout => "cmu_sv" } # index.html.erb
         end
       end
     end
   
   
     def campus_week
!!     determine_panel_state()
!!     title = "Campus View - Week " + @panel_state.week_number.to_s + " of " + @panel_state.year.to_s
!!     course_data = get_campus_week_data(@panel_state.year, @panel_state.week_number)
!!     @chart_url = generate_google_box_chart(title, course_data)
     end
   
   
     def course
!!     determine_panel_state()
!!     if params[:panel_state]
!!       @panel_state.course_id = params[:panel_state][:course_id]
       else
!!       @panel_state.course_id = params[:course_id]
   
!!       if @panel_state.year.blank?
!!         @panel_state.year = Date.today.cwyear
         end
   
!!       if @panel_state.week_number.blank?
!!         @panel_state.week_number = Date.today.cweek - 1
         end
   
       end
!!     puts "PAREMETERS: #{@panel_state.year}, #{@panel_state.week_number}, #{params[:course_id]}"
!!     @chart_url = generate_course_chart(@panel_state.year, @panel_state.week_number, @panel_state.course_id)
   
!!     @course = Course.find(params[:course_id])
     end
   
   
     def generate_course_chart(year, week_number, course_id)
!!     course = Course.where(:id => course_id).first
!!     if course
!!       title = course.name
       else
!!       title = "Course Does Not Exist"
       end
!!     reports = get_course_data(year, week_number, course_id)
!!     return generate_google_box_chart(title, reports)
     end
   
   
     def index
     end
   
     def show_week
!!     if params[:week]
!!       @week_number = params[:week].to_i
       else
!!       @week_number = Date.today.cweek
       end
   
!!     if @week_number <= 0 then
!!       @week_number = 1
       end
!!     if @week_number >52 then
!!       @week_number = @week_number - 52
       end
   
!!     @next_week_number = @week_number + 1
!!     @prev_week_number = @week_number - 1
     end
   
     def show
     end
   
   
   #  def load_google_chart
   #
   #    GoogleChart::BoxChart.new('800x200', "Box Chart") do |bc|
   #      bc.data "s1",[-1,5,10,7,12,-1]
   #      bc.data "s2",[-1,25,30,27,24,-1]
   #      bc.data "s3",[-1,40,45,47,39,-1]
   #      bc.data "s4",[-1,55,63,59,80,-1]
   #      bc.data "s5",[-1,30,40,35,30,-1]
   #      bc.data "s6",[-1,-1,5,70,90,-1]
   #      bc.data "s7",[-1,-1,-1,80,5,-1]
   #      bc.data_encoding = :text
   #      @chart = bc.to_url(:chm => "F,FF9900,0,1:4,40|H,0CBF0B,0,1:4,1:20|H,000000,4,1:4,1:40|H,0000FF,3,1:4,1:20|o,FF0000,5,-1,7|o,FF0000,6,-1,7")
   #    end
   #
   #
   #  end
   
     def raw_data
!!     if !(current_user.is_admin? || current_user.is_staff?)
!!       flash[:error] = 'You don' 't have permissions to view this data.'
!!       redirect_to(effort_reports_url)
!!       return
       end
!!     @report_lines = EffortLog.find_by_sql(["SELECT effort_logs.year, effort_logs.week_number, users.human_name, task_types.name, effort_log_line_items.sum, effort_log_line_items.course_id FROM effort_log_line_items inner join effort_logs on effort_log_line_items.effort_log_id = effort_logs.id inner join users on users.id = user_id inner join task_types on task_type_id = task_types.id where course_id = ?  order by week_number ", params[:id]])
     end
   
   
     def course_table
!!     if !(current_user.is_admin? || current_user.is_staff?)
!!       flash[:error] = 'You don' 't have permissions to view this data.'
!!       redirect_to(effort_reports_url)
!!       return
       end
!!     @course = Course.find(params[:id])
   
       #given the course id, determine the start week and the end week of the semester
   
!!     @report_header = ["Team", "Person"]
!!     (1..@course.course_length).each do |week|
!!       @report_header << "Wk #{week} "
       end
       #    @course.course_length.times do @report_header << "Wk  "  end
   
!!     @report_lines = []
   
!!     blank_line = Array.new(@course.course_length, "-")
!!     min_effort = Array.new(@course.course_length, 100)
!!     max_effort = Array.new(@course.course_length, 0)
!!     total_effort = Array.new(@course.course_length, 0)
!!     count_effort = Array.new(@course.course_length, 0)
!!     average_effort = Array.new(@course.course_length, 0)
   
   
!!     @course.teams.each do |team|
!!       team.members.each do |user|
!!         person_result = report_person_effort_for_course(user, @course)
!!         @report_lines << {:team_name => team.name, :person_name => user.human_name, :effort => person_result}
!!         min_effort = update_min(min_effort, person_result)
!!         max_effort = update_max(max_effort, person_result)
!!         total_effort = update_total(total_effort, person_result)
!!         count_effort = update_count(count_effort, person_result)
         end
       end
!!     update_average(average_effort, total_effort, count_effort)
!!     @report_lines << {:team_name => "", :person_name => "", :effort => blank_line}
!!     @report_lines << {:team_name => "Summary", :person_name => "Min", :effort => min_effort}
!!     @report_lines << {:team_name => "Summary", :person_name => "Avg", :effort => average_effort}
!!     @report_lines << {:team_name => "Summary", :person_name => "Max", :effort => max_effort}
!!     @report_lines << {:team_name => "", :person_name => "", :effort => blank_line}
!!     @report_lines << {:team_name => "Summary", :person_name => "Total", :effort => total_effort}
!!     @report_lines << {:team_name => "Summary", :person_name => "Count", :effort => count_effort}
   
     end
   
     # helper method for course_table
     def update_max(max_effort, person_result)
!!     max_effort.each_index { |i| max_effort[i] = person_result[i] if person_result[i] > max_effort[i] }
     end
   
     def update_min(min_effort, person_result)
!!     min_effort.each_index { |i| min_effort[i] = person_result[i] if person_result[i] < min_effort[i] && person_result[i] > 0 }
     end
   
     def update_total(total_effort, person_result)
!!     total_effort.each_index { |i| total_effort[i] += person_result[i] }
     end
   
     def update_count(count_effort, person_result)
!!     count_effort.each_index { |i| count_effort[i] += 1 if person_result[i] != 0 }
     end
   
     def update_average(average_effort, total_effort, count_effort)
!!     average_effort.each_index { |i| average_effort[i] = total_effort[i] / count_effort[i] unless count_effort[i] == 0 }
     end
   
   
     # helper method for course_table
     def report_person_effort_for_course(person, course)
!!     person_effort_log_lines = EffortLog.find_by_sql(["SELECT effort_logs.week_number, effort_log_line_items.sum  FROM effort_log_line_items inner join effort_logs on effort_log_line_items.effort_log_id = effort_logs.id where effort_log_line_items.course_id = ? and effort_logs.user_id = ? order by effort_logs.week_number", course.id, person.id])
   
!!     person_result = []
!!     @course.course_length.times do
!!       person_result << 0
       end
!!     if !person_effort_log_lines.nil? && person_effort_log_lines.size != 0 then
!!       person_effort_log_lines.each do |line|
!!         week = line.week_number.to_i
!!         if week >= @course.course_start && week <= @course.course_end then
!!           person_result[week - @course.course_start + 0] += line.sum.to_i #add two to skip the team and person label at the front of the array
           end
   
         end
   
       end
!!     return person_result
     end
   
     def course_ranges_array(data_set) # data_set is an array of Numeric objects
!!     return [0, 0, 0, 0, 0] if data_set.blank?
!!     data_set = data_set.sort
!!     maximum = data_set.max
!!     minimum = data_set.min
!!     median = median(data_set)
!!     if data_set.count % 2 == 1
!!       lower25 = median(data_set[0..((data_set.count / 2).ceil)], 0.25)
!!       upper25 = median(data_set[((data_set.count / 2).floor)..-1], 0.75)
       else
!!       lower25 = median(data_set[0...(1 + data_set.count / 2)], 0.25)
!!       upper25 = median(data_set[(-1 + data_set.count / 2)..-1], 0.75)
       end
   
!!     [minimum, lower25, median, upper25, maximum]
     end
   
     def median(data_set, pct = 0.5)
!!     middle = (data_set.count + 1)/2.0
!!     middle -= 1 # convert from set index to array index (count from 0)
!!     if data_set.nil? or data_set.count == 0
         nil
!!     elsif data_set.count == 1
!!       data_set[0]
!!     elsif data_set.count % 2 == 1
!!       data_set[middle.floor]
       else
!!       data_set[middle.floor] + (pct * (data_set[middle.ceil] - data_set[middle.floor]))
       end
     end
   
   
   end

================================================================================
 ./app/controllers/generic_ajax_controller.rb
================================================================================
   class GenericAjaxController < ApplicationController
   
     before_filter :authenticate_user!
   
     def update_model_with_value
!!     model_name = params[:model]
!!     id = params[:id]
!!     attribute = params[:attribute]
!!     update_value = params[:value]
   
   # This is an example of what we are doing for an input of User, 1, course_tools_view, "links"
   #    instance = "User".constantize.find(1)
   #    instance.course_tools_view = "links"
   
!!     model = model_name.constantize
!!     instance = model.find_by_id(id)
!!     if (instance.nil?)
!!       return render :text => "#{model_name} does not have a row with an id of #{id}"
       end
   
!!     unless instance.attributes.has_key? attribute
!!       return render :text => "#{model_name} does not have the attribute #{attribute}"
       end
   
!!     unless can? :update, instance
!!       return render :text => "Do not have permission to modify #{model_name}"
       end
   
!!     result = instance.update_attribute(attribute, update_value)
   
!!     if result
!!       return render :text => "Success"
       else
!!       return render :text => "Failure on update_attribute"
       end
   
   
     end
   
   
   end

================================================================================
 ./app/controllers/grades_controller.rb
================================================================================
   class GradesController < ApplicationController
   
     layout 'cmu_sv'
   
     before_filter :authenticate_user!
     before_filter :get_course
     before_filter :render_grade_book_menu
     before_filter :validate_permission, :except => [:student_deliverables_and_grades_for_course]
     before_filter :get_team_assignment, :only => [:index, :student_deliverables_and_grades_for_course]
   
   
     def get_course
!!     @course=Course.find(params[:course_id])
     end
   
     def render_grade_book_menu
!!     @is_in_grade_book = true
     end
   
     def validate_permission
!!     unless (current_user.is_admin? || @course.faculty.include?(current_user))
!!       has_permissions_or_redirect(:admin, root_path)
       end
     end
   
     def get_team_assignment
!!     @team_assignment = {}
!!     @course.teams.each do |t|
!!       t.members.each do |m|
!!         @team_assignment[m.id] = t
         end
       end
     end
   
     def index
!!     if @course.grading_rule.nil?
!!       flash[:error] = I18n.t(:no_grading_rule_for_course)
!!       redirect_to course_path(@course) and return
       end
!!     if @course.grading_rule.default_values?
!!       flash.now[:error] = I18n.t(:default_grading_rule_for_course)
       end
!!     @no_pad = true
!!     @students = @course.registered_students_or_on_teams
!!     @assignments = @course.assignments
!!     @grades = {}
!!     @students.each do |student|
!!       @grades[student] = Grade.get_grades_for_student_per_course(@course, student)
       end
!!     render
     end
   
     def student_deliverables_and_grades_for_course
!!     @course = Course.find(params[:course_id])
!!     if (params[:user_id])
!!       @user = User.find_by_param(params[:user_id])
       else
!!       @user = current_user
       end
!!     if (current_user.id != @user.id)
!!       unless (@course.faculty.include?(current_user))||(current_user.is_admin?)
!!         flash[:error] = I18n.t(:not_your_deliverable)
!!         redirect_to root_path and return
         end
       end
!!     @assignments = @course.assignments
!!     @grades = {}
!!     @grades[@user] = Grade.get_grades_for_student_per_course(@course, @user)
!!     respond_to do |format|
!!       format.html { render :action => "student_deliverables" }
!!       format.xml { render :xml => @assignments }
       end
     end
   
     def post_drafted_and_send #and send email
!!     grades = params["grades"]
!!     faculty_email = nil
!!     if params[:send_copy_to_myself] == "1"
!!       faculty_email = current_user.email
       end
!!     Grade.mail_drafted_grade(@course.id, request.host_with_port, faculty_email)
!!     render :json => ({"message" => "true"})
     end
   
     def save
!!     grades = params["grades"]
!!     Grade.give_grades(grades, current_user.id)
!!     render :json => ({"message" => "true"})
     end
   
     def send_final_grade
!!     grades = params["grades"]
!!     faculty_email = nil
!!     if params[:send_copy_to_myself] == "1"
!!       faculty_email = current_user.email
       end
!!     Grade.mail_final_grade(@course.id, request.host_with_port, faculty_email)
!!     render :json => ({"message" => "true"})
     end
   
     def import
!!     if params[:import].nil? || params[:import][:spreadsheet].nil?
!!       flash[:error] = "please select a file to import"
!!       redirect_to course_grades_path(@course) and return
       end
   
!!     temp_file_path = params[:import][:spreadsheet].path
!!     if Grade.import_grade_book_from_spreadsheet(temp_file_path, @course.id)
!!       flash[:notice] = "grade book was imported"
       else
!!       flash[:error] = "spreadsheet format is incorrect"
       end
!!     redirect_to course_grades_path(@course)
     end
   
     def export
!!     temp_file_path = File.expand_path("#{Rails.root}/tmp/#{Process.pid}_") + "export.xls"
!!     Grade.export_grade_book_to_spreadsheet(@course, temp_file_path)
!!     flash[:notice] = "grade book was exported to " + temp_file_path
!!     send_file(temp_file_path, :filename => "GradeBook_#{@course.name}.xls")
     end
   
   end

================================================================================
 ./app/controllers/jobs_controller.rb
================================================================================
   class JobsController < ApplicationController
     layout "cmu_sv"
   
     before_filter :authenticate_user!
   
     # GET /jobs
     def index
!!     @jobs = Job.scoped
!!     @jobs = @jobs.active if params[:show_all] != "true"
     end
   
     # GET /jobs/new
     def new
!!     authorize! :create, Job
!!     @job = Job.new
!!     @job.supervisors << current_user
!!     @projects = SponsoredProject.current
     end
   
     # GET /jobs/1/edit
     def edit
!!     @job = Job.find(params[:id])
!!     authorize! :update, @job
!!     @projects = SponsoredProject.current
     end
   
     # POST /jobs
     def create
!!     authorize! :create, Job
!!     params[:job][:supervisors_override] = params[:supervisors]
!!     params[:job][:employees_override] = params[:students]
!!     @job = Job.new(params[:job])
!!     @projects = SponsoredProject.current
   
!!     respond_to do |format|
!!       if @job.save
!!         format.html { redirect_to(jobs_path, :notice => 'Job was successfully created.') }
         else
!!         format.html { render :action => "new" }
         end
       end
     end
   
     # PUT /jobs/1
     # PUT /jobs/1.xml
     def update
!!     params[:job][:supervisors_override] = params[:supervisors]
!!     params[:job][:employees_override] = params[:students]
!!     @job = Job.find(params[:id])
!!     authorize! :update, @job
!!     if  params[:job][:is_closed].present? && params[:job][:is_closed] == "true"
!!       notice_msg = "Job was closed."
       end
!!     @projects = SponsoredProject.current
   
!!     respond_to do |format|
!!       if @job.update_attributes(params[:job])
!!         format.html { redirect_to(jobs_path, :notice => notice_msg || 'Job was successfully updated.') }
         else
!!         format.html { render :action => "edit" }
         end
       end
     end
   
     def assignments
!!     authorize! :see_job_details, Job
!!     @jobs = Job.active
!!     @all_employees = Job.all_employees
     end
   
   end

================================================================================
 ./app/controllers/mailing_lists_controller.rb
================================================================================
   class MailingListsController < ApplicationController
     before_filter :authenticate_user!
   
     layout 'cmu_sv'
   
   
     # GET /mailing_lists
     # GET /mailing_lists.xml
     def index
!!     @mailing_lists = []
!!     google_apps_connection.retrieve_all_groups.each do |list|
         # group_name = list.group_id.split('@')[0] #ie all-students
!!       @mailing_lists << list.group_id #ie all-students@sv.cmu.edu
       end
   
!!     respond_to do |format|
!!       format.html
!!       format.xml { render :xml => @mailing_lists }
       end
     end
   
   
     # GET /mailing_lists/1
     # GET /mailing_lists/1.xml
     def show
!!     @mailing_list = params[:id]
   
   
   #     (group, domain) = @mailing_list.split('@')
   #     if(domain == "sv.cmu.edu")
   #        @mailing_list = group + "@west.cmu.edu"
   #     end
!!     @mailing_list = switch_sv_to_west(@mailing_list)
   
!!     @members = []
!!     google_apps_connection.retrieve_all_members(@mailing_list).each do |member|
!!       tmp = member.member_id
!!       @members << member.member_id
       end
   
!!     respond_to do |format|
!!       format.html # show.html.erb
!!       format.xml { render :xml => @members }
       end
   
     rescue GDataError => e
!!     flash[:error] = "Mailing list does not exist"
     end
   
   
   end

================================================================================
 ./app/controllers/page_attachments_controller.rb
================================================================================
   class PageAttachmentsController < ApplicationController
     def update
       @pa = PageAttachment.find(params[:id])
       @pa.user_id = current_user.id
   
!!     if @pa.page.editable?(current_user)
!!       respond_to do |format|
!!         if @pa.update_attributes(params[:page_attachment])
!!           format.html { redirect_to @pa.page }
           else
!!           flash[:error] = 'Could not upload your file.'
!!           format.html { redirect_to @pa.page }
           end
         end
       else
!!       flash[:error] = "You don't have permission to do that."
!!       redirect_to @pa.page
       end
   
     end
   
     def create
       @pa = PageAttachment.new params[:page_attachment]
       @pa.user_id = current_user.id
   
!!     if @pa.page.editable?(current_user)
!!       respond_to do |format|
!!         if @pa.page_attachment.present? && @pa.save
!!           format.html { redirect_to @pa.page }
           else
!!           flash[:error] = 'Could not upload your file.'
!!           format.html { redirect_to @pa.page }
           end
         end
       else
!!       flash[:error] = "You don't have permission to do that."
!!       redirect_to @pa.page
       end
     end
   
     def destroy
       @pa = PageAttachment.find(params[:id])
   
       if @pa.page.editable?(current_user)
         @pa.destroy
         flash[:notice] = "Page attachment successfully deleted."
   
         respond_to do |format|
           format.html { redirect_to @pa.page }
         end
       else
         flash[:error] = "You don't have permission to do that."
         redirect_to @pa.page
       end
     end
   
     def reposition
!!     order = params[:page_attachment]
!!     PageAttachment.reposition(order)
!!     render :text => order.inspect
     end
   end

================================================================================
 ./app/controllers/page_comment_types_controller.rb
================================================================================
   class PageCommentTypesController < ApplicationController
     before_filter :authenticate_user!
   
     # GET /page_comment_types
     # GET /page_comment_types.xml
     def index
!!     @page_comment_types = PageCommentType.all
     end
   
     # GET /page_comment_types/1
     # GET /page_comment_types/1.xml
     def show
!!     @page_comment_type = PageCommentType.find(params[:id])
     end
   
     # GET /page_comment_types/new
     # GET /page_comment_types/new.xml
     def new
!!     if has_permissions_or_redirect(:staff, page_comment_types_url)
   
!!       @page_comment_type = PageCommentType.new
       end
     end
   
     # GET /page_comment_types/1/edit
     def edit
!!     if has_permissions_or_redirect(:staff, page_comment_types_url)
!!       @page_comment_type = PageCommentType.find(params[:id])
       end
     end
   
     # POST /page_comment_types
     # POST /page_comment_types.xml
     def create
!!     if has_permissions_or_redirect(:staff, page_comment_types_url)
   
!!       @page_comment_type = PageCommentType.new(params[:page_comment_type])
   
!!       respond_to do |format|
!!         if @page_comment_type.save
!!           flash[:notice] = 'PageCommentType was successfully created.'
!!           format.html { redirect_to(@page_comment_type) }
!!           format.xml { render :xml => @page_comment_type, :status => :created, :location => @page_comment_type }
           else
!!           format.html { render :action => "new" }
!!           format.xml { render :xml => @page_comment_type.errors, :status => :unprocessable_entity }
           end
         end
       end
     end
   
     # PUT /page_comment_types/1
     # PUT /page_comment_types/1.xml
     def update
!!     if has_permissions_or_redirect(:staff, page_comment_types_url)
!!       @page_comment_type = PageCommentType.find(params[:id])
   
!!       respond_to do |format|
!!         if @page_comment_type.update_attributes(params[:page_comment_type])
!!           flash[:notice] = 'PageCommentType was successfully updated.'
!!           format.html { redirect_to(@page_comment_type) }
!!           format.xml { head :ok }
           else
!!           format.html { render :action => "edit" }
!!           format.xml { render :xml => @page_comment_type.errors, :status => :unprocessable_entity }
           end
         end
       end
     end
   
     # DELETE /page_comment_types/1
     # DELETE /page_comment_types/1.xml
     def destroy
!!     if has_permissions_or_redirect(:admin, page_comment_types_url)
!!       @page_comment_type = PageCommentType.find(params[:id])
!!       @page_comment_type.destroy
   
!!       respond_to do |format|
!!         format.html { redirect_to(page_comment_types_url) }
!!         format.xml { head :ok }
         end
       end
     end
   end

================================================================================
 ./app/controllers/page_comments_controller.rb
================================================================================
   class PageCommentsController < ApplicationController
     before_filter :authenticate_user!
   
   # This would happen on the page show
   #  def index
   #    page = Page.find(params[:id])
   #    @page_comments = PageComment.where("page_id = ? and semester = ? and year = ?", page.id, AcademicCalendar.current_semester(), Date.today.year.to_s)
   #    respond_to do |format|
   #      format.html # index.html.erb
   #      format.xml { render :xml => @page_comments }
   #    end
   #  end
   
     # GET /page_comments/1
     # GET /page_comments/1.xml
     def show
!!     @page_comment = PageComment.find(params[:id])
   
!!     respond_to do |format|
!!       format.html # show.html.erb
!!       format.xml { render :xml => @page_comment }
       end
     end
   
     # GET /page_comments/new
     # GET /page_comments/new.xml
     def new
!!     @page_comment = PageComment.new
!!     @page_comment.notify_me = true if current_user
!!     @types = PageCommentType.all
   
!!     respond_to do |format|
!!       format.html # new.html.erb
!!       format.xml { render :xml => @page_comment }
       end
     end
   
     # GET /page_comments/1/edit
     def edit
!!     @page_comment = PageComment.find(params[:id])
!!     @types = PageCommentType.all
     end
   
     # POST /page_comments
     # POST /page_comments.xml
     def create
!!     @page_comment = PageComment.new(params[:page_comment])
!!     @page_comment.user_id = current_user.id if current_user
!!     @page_comment.semester = AcademicCalendar.current_semester()
!!     @page_comment.year = Date.today.year
!!     @types = PageCommentType.all
   
!!     respond_to do |format|
!!       if @page_comment.save
!!         a = PageCommentMailer.comment_update(@page_comment, "created")
!!         a.deliver
!!         flash[:notice] = 'Comment was successfully created.'
!!         format.html { redirect_to(@page_comment.url) }
!!         format.xml { render :xml => @page_comment, :status => :created, :location => @page_comment }
         else
!!         format.html { render :action => "new" }
!!         format.xml { render :xml => @page_comment.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # PUT /page_comments/1
     # PUT /page_comments/1.xml
     def update
!!     @page_comment = PageComment.find(params[:id])
!!     unless @page_comment.editable?(current_user)
!!       flash[:error] = I18n.t(:no_permission)
!!       redirect_to(@page_comment.url) and return
       end
!!     @types = PageCommentType.all
   
!!     respond_to do |format|
!!       if @page_comment.update_attributes(params[:page_comment])
!!         PageCommentMailer.comment_update(@page_comment, "updated").deliver
!!         flash[:notice] = 'Comment was successfully updated.'
!!         format.html { redirect_to(@page_comment.url) }
!!         format.xml { head :ok }
         else
!!         format.html { render :action => "edit" }
!!         format.xml { render :xml => @page_comment.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # DELETE /page_comments/1
     # DELETE /page_comments/1.xml
     def destroy
!!     @page_comment = PageComment.find(params[:id])
!!     if has_permissions_or_redirect(:admin, @page_comment.url)
!!       @page_comment.destroy
   
!!       respond_to do |format|
!!         format.html { redirect_to(page_comments_url) }
!!         format.xml { head :ok }
         end
       end
     end
   
   
   end

================================================================================
 ./app/controllers/pages_controller.rb
================================================================================
   class PagesController < ApplicationController
     before_filter :authenticate_user!, :except => [:show]
   
     #  layout 'cmu_sv_no_pad'
     layout 'cmu_sv'
   
     # GET /pages
     # GET /pages.xml
     def index
!!     @pages = Page.all
   
!!     respond_to do |format|
!!       format.html # index.html.erb
!!       format.xml { render :xml => @pages }
       end
     end
   
     def changed
!!     @pages = Page.order("updated_at DESC").all
!!     @no_pad = true
   
!!     respond_to do |format|
!!       format.html
!!       format.xml { render :xml => @pages }
       end
     end
   
     # GET /pages/1
     # GET /pages/1.xml
     def show
       @no_pad = true
       @page = Page.find_by_url(params[:id])
       @page.revert_to(params[:version].to_i) if params[:version]
   
       if @page.blank?
!!       flash[:error] = "Page with an id of #{params[:id]} is not in this system. You may create it using the form below."
!!       redirect_to(:controller => :pages, :action => :new, :url => params[:id]) and return
       end
   
       if @page.visible == false
!!       flash[:error] = "This page no longer exists."
!!       redirect_to(root_url) and return
       end
   
       unless @page.viewable?(current_user)
         flash[:error] = "You don't have permission to do this action."
         redirect_to(root_url) and return
       end
   
       @tab = params[:tab]
   
       respond_to do |format|
         format.html # show.html.erb
         format.xml { render :xml => @page }
       end
     end
   
     # GET /pages/new
     # GET /pages/new.xml
     def new
!!     @page = Page.new
!!     @page.title = params[:url].split('_').collect { |w| w.capitalize + ' ' }.join().chomp(' ') if params[:url]
!!     @page.url = params[:url]
!!     @page.course_id = params[:course_id].to_i
!!     @courses = Course.unique_course_names
   
!!     respond_to do |format|
!!       format.html # new.html.erb
!!       format.xml { render :xml => @page }
       end
     end
   
     # GET /pages/1/edit
     def edit
!!     @page = Page.find_by_url(params[:id])
!!     @courses = Course.unique_course_names
   
!!     if @page.blank?
!!       flash[:error] = "Page with an id of #{params[:id]} is not in this system."
!!       redirect_to(pages_url) and return
       end
   
!!     unless @page.editable?(current_user)
!!       flash[:error] = "You don't have permission to do this action."
!!       redirect_to(page_url) and return
       end
   
!!     if @page.is_someone_else_currently_editing_page(current_user) && @page.timeout_has_not_passed
   
   
!!       flash[:notice] = "#{@page.current_edit_by.human_name} started editing this page
!!                         #{pluralize(((Time.now - @page.current_edit_started_at) / 1.minute).round, 'minute')} ago at
                           #{l @page.current_edit_started_at, :format => :detailed }"
!!       redirect_to(page_url) and return
       end
   
!!     @page.skip_version do
!!       @page.current_edit_by = current_user
!!       @page.current_edit_started_at = Time.now
!!       @page.save!
       end
   
!!     respond_to do |format|
!!       format.html # new.html.erb
!!       format.xml { render :xml => @page }
       end
     end
   
     def pluralize(number, text)
!!     return number.to_s+' '+text.pluralize if number != 1
!!     number.to_s+' '+text
     end
   
     # POST /pages
     # POST /pages.xml
     def create
!!     @page = Page.new(params[:page])
!!     @courses = Course.unique_course_names
   
!!     @page.updated_by_user_id = current_user.id if current_user
!!     respond_to do |format|
!!       if @page.save
!!         flash[:notice] = 'Page was successfully created.'
!!         format.html { redirect_to(@page) }
!!         format.xml { render :xml => @page, :status => :created, :location => @page }
         else
!!         format.html { render :action => "new" }
!!         format.xml { render :xml => @page.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # PUT /pages/1
     # PUT /pages/1.xml
     def update
!!     @page = Page.find_by_url(params[:id])
!!     @courses = Course.unique_course_names
   
!!     unless @page.editable?(current_user)
!!       flash[:error] = "You don't have permission to do this action."
!!       redirect_to(page_url) and return
       end
   
!!     respond_to do |format|
!!       format.html do
!!         update_page_edit_info(@page)
!!         if @page.update_attributes(params[:page])
!!           unless params[:timeout_flag].blank?
!!             flash[:notice] = "We thought you left, so we saved your page for you."
             else
!!             flash[:notice] = 'Page was successfully updated.'
             end
   
!!           redirect_to(@page)
           else
!!           render :action => "edit"
           end
         end
   
!!       format.xml do
!!         update_page_edit_info(@page)
!!         if @page.update_attributes(params[:page])
!!           head :ok
           else
!!           render :xml => @page.errors, :status => :unprocessable_entity
           end
         end
   
!!       format.json do
           # Do not bump up the version number for auto save
!!         @page.skip_version do
!!           if @page.update_attributes(params[:page])
!!             render :json => {:code => "success", :message => "", :new_post_path => page_path(@page)}
             else
!!             render :json => {:code => "failed", :message => "Automatic save failed"}
             end
           end
         end
       end
     end
   
     def revert
!!     @page = Page.find_by_url(params[:id])
   
!!     if @page.blank?
!!       flash[:error] = "Page with an id of #{params[:id]} is not in this system."
!!       redirect_to(pages_url) and return
       end
   
!!     unless @page.editable?(current_user)
!!       flash[:error] = "You don't have permission to do this action."
!!       redirect_to(page_url) and return
       end
   
!!     respond_to do |format|
!!       if @page.revert_to! params[:version].to_i
!!         flash[:notice] = 'Page was successfully reverted.'
!!         format.html { redirect_to(@page) }
!!         format.xml { head :ok }
         else
!!         format.html { redirect_to page_path(@page, :history => true) }
!!         format.xml { render :xml => @page.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     private
     def update_page_edit_info(page)
!!     page.updated_by_user_id = current_user.id if current_user
!!     page.current_edit_by = nil
!!     page.current_edit_started_at = nil
     end
   end

================================================================================
 ./app/controllers/password_resets_controller.rb
================================================================================
   class PasswordResetsController < ApplicationController
     layout 'cmu_sv'
   
     # Display new password reset page
     def index
       redirect_to new_password_reset_path
     end
   
     # Create new password reset request
     def create
       @user = User.find_by_email(params[:primaryEmail])
       @active_directory_services = ActiveDirectory.new
   
       if verify_recaptcha(:model => @user, :attribute => "verification code")
         if @user && @user.personal_email == params[:personalEmail]
           @active_directory_services.send_password_reset_token(@user)
         else
           flash[:error] = "Your entries do not match records"
           redirect_to new_password_reset_path and return
         end
         redirect_to root_url, :notice => "Password reset instructions have been sent to your secondary email account."
       else
!!       flash[:error] = "Verification code is wrong"
!!       redirect_to new_password_reset_path
       end
     end
   
     # Display edit form with password reset token link
     def edit
       @user = User.find_by_password_reset_token!(params[:id])
     rescue ActiveRecord::RecordNotFound
       redirect_to new_password_reset_path, :flash => {:error => "Password reset link has expired."}
     end
   
     # Do actual password reset
     def update
!!     @user = User.find_by_password_reset_token!(params[:id])
!!     @active_directory_services = ActiveDirectory.new
!!     respond_to do |format|
!!       if @user.password_reset_sent_at > 2.hours.ago
!!         if params[:newPassword]
!!           if @active_directory_services.reset_password(@user, params[:newPassword]) == "Success"
!!             flash[:notice] = "Password has been reset!"
!!             format.html { redirect_to root_url }
             else
!!             flash[:error]="Password reset was unsuccessful."
!!             redirect_to edit_password_reset_path and return
             end
           end
         else
!!         flash[:error] = "Password reset link has expired."
!!         format.html { redirect_to new_password_reset_path }
         end
       end
     end
   end

================================================================================
 ./app/controllers/peer_evaluation_controller.rb
================================================================================
   class PeerEvaluationController < ApplicationController
     layout 'cmu_sv'
     before_filter :authenticate_user!
   
     @@questions = [
         "What was this team member's most significant positive contribution to the team?",
         "In what ways could this team member improve his/her contribution to team meetings?",
         "In what ways could this team member improve his/her contribution to the team's deliverables? ",
         "Please provide feedback on the progress of each individual's improvement objective:"
     ]
     @@point_allocation = "Point allocations"
   
     def index_for_course
!!     @course = Course.find(params[:course_id])
!!     authorize! :peer_evaluation, @course
   
!!     @teams = Team.where(:course_id => params[:course_id])
     end
   
     def edit_setup
!!     if has_permissions_or_redirect(:staff, root_path)
!!       @team = Team.find(params[:id])
!!       @users = @team.members
   
!!       @objective = PeerEvaluationLearningObjective.new
   
!!       @objectives = []
!!       @team.members.each do |member|
!!         objective = PeerEvaluationLearningObjective.where(:team_id => @team.id, :user_id => member.id).first
!!         if objective.nil?
!!           @objectives << PeerEvaluationLearningObjective.new
           else
!!           @objectives << objective
           end
         end
       end
     end
   
     def complete_setup
!!     if has_permissions_or_redirect(:staff, root_path)
!!       @team = Team.find(params[:id])
   
!!       counter = 0
!!       @team.members.each do |member|
!!         if (PeerEvaluationLearningObjective.where(:team_id => @team.id, :user_id => member.id).first.nil?)
!!           @objective = PeerEvaluationLearningObjective.new(
                 :team_id => params[:id],
                 :user_id => member.id,
                 :learning_objective => params[:peer_evaluation_learning_objective][counter.to_s][:learning_objective]
             )
           else
!!           @objective = PeerEvaluationLearningObjective.where(:team_id => @team.id, :user_id => member.id).first
!!           @objective.learning_objective = params[:peer_evaluation_learning_objective][counter.to_s][:learning_objective]
           end
   
!!         @objective.save!
!!         counter += 1
         end
   
!!       flash[:notice] = "Learning objectives have been updated."
!!       redirect_to(peer_evaluation_path(@team.course, @team.id))
       end
     end
   
   
     def edit_evaluation
!!     @questions = @@questions
!!     @team = Team.find(params[:id])
!!     @users = @team.members
!!     @author = User.find(current_user.id)
!!     @answers = []
!!     @point_allocations = {}
!!     @review = PeerEvaluationReview.new
   
!!     @on_team = false
!!     @users.each do |user|
!!       if (user.human_name == current_user.human_name)
!!         @on_team = true
         end
       end
   
!!     if (@on_team == false)
!!       if (current_user.is_staff || current_user.is_admin)
!!         return
         end
!!       flash[:error] = "You are not on team #{@team.name}"
!!       redirect_to(peer_evaluation_path(@team.course, @team.id))
!!       return
       end
   
!!     @users.each do |user|
!!       @questions.each do |question|
!!         evaluation = PeerEvaluationReview.where(:author_id => @author.id, :recipient_id => user.id, :team_id => @team.id, :question => question).first
!!         if (evaluation.nil?)
!!           @answers << ""
           else
!!           @answers << evaluation.answer
           end
         end
       end
   
!!     allocation = PeerEvaluationReview.where(:author_id => @author.id, :team_id => @team.id, :question => @@point_allocation).first
!!     unless allocation.nil? || allocation.answer.nil?
!!       match_array = allocation.answer.scan /((\w| )*):(\d*)\s*/
!!       match_array.each do |match|
!!         name = match[0]
!!         points = match[2]
!!         @point_allocations[name] = points
         end
       end
     end
   
   
     def complete_evaluation
!!     ex = nil
   
!!     begin
!!       @questions = @@questions
   
!!       @team = Team.find(params[:id])
!!       @users = @team.members
   
!!       @author = User.find(current_user.id)
   
!!       user_counter = 0
!!       question_counter = 0
!!       @users.each do |user|
!!         @questions.each do |question|
!!           @evaluation = PeerEvaluationReview.where(:author_id => @author.id, :recipient_id => user.id, :team_id => @team.id, :question => question).first
!!           if (@evaluation.nil?)
!!             @evaluation = PeerEvaluationReview.new(
                   :author_id => @author.id,
                   :recipient_id => user.id,
                   :team_id => @team.id,
                   :question => question,
!!                 :answer => params[:peer_evaluation_review][(@questions.size*user_counter + question_counter).to_s][:answer],
                   :sequence_number => question_counter
               )
             else
!!             @evaluation.answer = params[:peer_evaluation_review][(@questions.size*user_counter + question_counter).to_s][:answer]
             end
!!           @evaluation.save!
!!           question_counter += 1
           end
   
!!         user_counter += 1
!!         question_counter = 0
         end
   
!!       alloc_counter = 0
!!       alloc_answer = ""
!!       @users.each do |user|
!!         alloc_answer << user.human_name + ":" + params[:allocations][alloc_counter.to_s] + " "
!!         alloc_counter += 1
         end
   
!!       allocation = PeerEvaluationReview.where(:author_id => @author.id, :team_id => @team.id, :question => @@point_allocation).first
!!       if (allocation.nil?)
!!         allocation = PeerEvaluationReview.new(
               :author_id => @author.id,
               :team_id => @team.id,
               :question => @@point_allocation,
               :answer => alloc_answer,
               :sequence_number => question_counter
           )
         else
!!         allocation.answer = alloc_answer
         end
!!       allocation.save!
!!     rescue => e
!!       ex = e
       ensure
!!       respond_to do |format|
           # html request
!!         format.html do
             # an exception was thrown, just re-throw the exception because the original code did not provide a user friendly message for exceptions
!!           unless ex.nil?
!!             raise ex
             end
   
!!           flash[:notice] = "Thank you for completing the peer evaluation form."
!!           redirect_to(peer_evaluation_path(@team.course, @team.id))
           end
   
           # ajax request
!!         format.json do
!!           unless ex.nil?
!!             render :json => {:code => "failed", :message => "Automatic save failed."}
             else
!!             render :json => {:code => "success", :message => ""} # auto-save success message won't be shown by client
             end
           end
         end
   
!!     end # begin..rescue..ensure..end
     end
   
     def edit_report
!!     if has_permissions_or_redirect(:staff, root_path)
!!       @team = Team.find(params[:id])
!!       @users = @team.members
   
!!       @report = PeerEvaluationReport.new
   
!!       @incompletes = Array.new
!!       @team.members.each do |member|
!!         unless PeerEvaluationReview.is_completed_for?(member.id, @team.id)
!!           @incompletes << (member)
           end
         end
   
!!       @reportArray = Array.new(@users.size)
!!       user_counter = 0
!!       @users.each do |user|
!!         @reportArray[user_counter] = generate_report_for_student(user.id, @team.id)
!!         user_counter += 1
         end
   
!!       @report_allocations = {}
!!       @point_allocations = Hash.new { |hash, key| hash[key] = {} } #two dimensional hash
!!       @users.each do |user|
!!         allocation = PeerEvaluationReview.where(:author_id => user.id, :team_id => @team.id, :question => @@point_allocation).first
!!         unless allocation.nil?
!!           @report_allocations[user.human_name] = allocation.answer
   
!!           match_array = allocation.answer.scan /((\w| )*):(\d*)\s*/
!!           match_array.each do |match|
!!             name = match[0]
!!             points = match[2]
!!             @point_allocations[user.human_name][name] = points
             end
           end
         end
       end
     end
   
     def complete_report
!!     if has_permissions_or_redirect(:staff, root_path)
!!       if params[:commit] == "Save And Email All"
!!         send_email = true
         else
!!         send_email = false
         end
   
!!       @team = Team.find(params[:id])
!!       @users = @team.members
!!       @users.each do |user|
           #Step 1 save feedback
!!         feedback = params[:peer_evaluation_report][user.id.to_s][:feedback]
!!         report = PeerEvaluationReport.where(:recipient_id => user.id, :team_id => @team.id).first
!!         if report.nil?
!!           report = PeerEvaluationReport.new(:recipient_id => user.id, :team_id => @team.id, :feedback => feedback)
           else
!!           report.feedback = feedback
           end
!!         report.save!
   
!!         faculty = @team.faculty_email_addresses()
           #Step 2 email feedback
!!         if send_email
!!           options = {:to => user.email, :cc => faculty, :subject => "Peer evaluation feedback from team #{@team.name}",
                        :message => feedback.gsub("\n", "<br/>"), :url => "", :url_label => ""}
!!           GenericMailer.email(options).deliver
!!           report.email_date = Time.now
!!           report.save!
           end
         end
   
!!       flash[:notice] = "Reports have been successfully saved."
!!       redirect_to(peer_evaluation_path(@team.course, @team.id))
       end
     end
   
   
     def email_reports
     end
   
     private
   
     def generate_report_for_student(user_id, team_id)
!!     report = PeerEvaluationReport.where(:recipient_id => user_id, :team_id => team_id).first
!!     if report.nil?
!!       report_string = ""
         #report_string += "{" + user.human_name + "}\n"
!!       question_counter = 0
!!       @@questions.each do |question|
!!         report_string += question + "\n"
!!         if question_counter == @@questions.size - 1
!!           learning_objective = PeerEvaluationLearningObjective.where(:user_id => user_id).first
!!           report_string += "\"" + learning_objective.learning_objective + "\"\n" unless (learning_objective.nil? || learning_objective.learning_objective.nil? || learning_objective.learning_objective.empty?)
           end
!!         data = PeerEvaluationReview.where(:team_id => team_id, :recipient_id => user_id, :question => question).all
!!         data.each do |answer|
!!           author = User.find(answer.author_id).human_name
!!           report_string += "[" + author + "]\n"
!!           report_string += " - " + answer.answer + "\n"
           end
!!         report_string += "\n"
!!         question_counter += 1
         end
!!       return report_string
       else
!!       return report.feedback
       end
   
     end
   
   
   end

================================================================================
 ./app/controllers/people_controller.rb
================================================================================
   require 'csv'
   require 'vpim/vcard'
   
   class PeopleController < ApplicationController
     #include ActionView::Helpers::AssetTagHelper
   
     def controller;
!!     self;
     end
   
     ; private(:controller)
   
     before_filter :authenticate_user!, :except => [:show_by_twiki]
   
   # Floating box source: http://roshanbh.com.np/2008/07/top-floating-message-box-using-jquery.html
   
     layout 'cmu_sv'
   
   #  auto_complete_for :person, :human_name
   #  protect_from_forgery :only => [:create, :update, :destroy] #required for auto complete to work
   
   
     # GET /people
     # GET /people.xml
     #
     # 1. This method checks to see if the logged in user has entered sufficient information in his own profile
     #    to use the people_search functionality (lovingly called carrot & stick)
     # 2. This method loads the search bar and default/key contacts for that user.
     #
     def index
       # 1. carrot & stick
!!     if !current_user.is_profile_valid?
!!       flash[:notice] = "<div align='center'><b>Warning:</b><br/> You have to update your profile details.<br/> If you do not do so in 4 weeks, you will lose access to the search profile features.<br/><a href='#{url_for(edit_person_path(current_user))}'>Click here to edit your profile.</a></div>".html_safe
!!       flash[:error] = nil
!!       if current_user.should_be_redirected?
!!         flash[:notice] = nil
!!         flash[:error] = "<div align='center'><b>Warning:</b><br/> Your access to the user search features have temporarily been disabled. <br/>To continue, please update your biography/phone numbers and social handles.</div>".html_safe
!!         redirect_to edit_person_path(current_user) and return
         end
       end
   
       # 2. default/key contacts for that user
!!     @people = get_default_key_contacts
       # pick only the fields required to be shown in the view and return as a Hash
   
!!     @key_contact_results = @people.collect { |default_person| Hash[
           #
           :image_uri => default_person.user.image_uri,
           :title => default_person.user.title,
           :human_name => default_person.user.human_name,
           :contact_dtls => default_person.user.telephones_hash,
           :email => default_person.user.email,
           :path => person_path(default_person.user),
           # first_name and last_name required for photobook view
           :first_name => default_person.user.first_name,
           :last_name => default_person.user.last_name
       ] }
!!     @key_contact_results.uniq!
!!     respond_to do |format|
!!       format.html { render :html => @key_contact_results }
!!       format.json { render :json => @key_contact_results }
       end
     end
   
     def advanced
!!     index
     end
   
     def photo_book
!!     index
     end
   
     # GET /people_search.json
     #
     # Ajax call for people search results using params[:filterBoxOne].
     # Sends back json object with search results (from database)
     #
     # Number of requesting coming in here is controlled through a javascript timer
     # (see js in views/people/index.html.erb for more details.)
     def search
       # call the function that actually finds all releveant search results from database
!!     @people = search_db_fields
       #
!!     priority_results = prioritize_search_results
   
       # pick only the fields required to be shown in the view and return as a Hash
!!     @people_hash = @people.collect do |person|
         # program, the user is enrolled in needs to be constructed to include addtional info like full-time/part-time
!!       program = ''
!!       if person.is_student
!!         program += (person.masters_program + ' ') unless person.masters_program.blank?
!!         program += person.masters_track unless person.masters_track.blank?
!!         if person.is_part_time
!!           program += ' (PT)'
           else
!!           program += ' (FT)'
           end
         elsif person.is_staff
!!         program += 'Staff'
         end
         # constructing Hash/json containing results
!!       Hash[:id => person.twiki_name,
              :first_name => person.first_name,
              :last_name => person.last_name,
              :image_uri => ActionController::Base.helpers.asset_path(person.image_uri),
              :program => program,
!!            :contact_dtls => person.telephones_hash.map { |k, v| "#{k}: #{v}" }.to_a,
              :email => person.email,
              :path => person_path(person),
              :priority => priority_results.include?(person.id)
         ]
       end
   
!!     respond_to do |format|
!!       format.json { render :json => @people_hash, :layout => false }
       end
     end
   
     #Ajax call for autocomplete using params[:term]
     def index_autocomplete
       #if database is mysql
       #@people = User.where("human_name LIKE ?", "%#{params[:term]}%").all
!!     @people = User.where("human_name ILIKE ?", "%#{params[:term]}%").all
   
!!     respond_to do |format|
!!       format.html { render :html => @people }
!!       format.json { render :json => @people.collect { |person| person.human_name }, :layout => false }
       end
     end
   
     # GET /people/1
     # GET /people/1.xml
     # GET /people/AndrewCarnegie
     # GET /people/AndrewCarnegie.xml
     def show
!!     @person = Person.find_by_param(params[:id])
!!     @person.revert_to params[:version_id] if params[:version_id]
   
!!     respond_to do |format|
!!       if @person.nil?
!!         flash[:error] = "Person with an id of #{params[:id]} is not in this system."
!!         format.html { redirect_to(people_url) }
!!         format.xml { render :xml => @person.errors, :status => :unprocessable_entity }
         else
!!         format.html # show.html.erb
!!         format.xml { render :xml => @person }
!!         format.json { render :json => @person, :layout => false }
         end
       end
     end
   
     # GET /people/twiki/AndrewCarnegie
     # GET /people/twiki/AndrewCarnegie.xml
     def show_by_twiki
   
       redirect_to :action => 'robots' if robot?
       host = get_http_host()
       if !(host.include?("info.sv.cmu.edu") || host.include?("info.west.cmu.edu")) && (current_user.nil?)
         flash[:error] = "You don't have permissions to view this data."
         redirect_to(people_url)
         return
       end
   
!!     @machine_name = "http://whiteboard.sv.cmu.edu"
   
!!     twiki_name = params[:twiki_name]
!!     @person = User.find_by_twiki_name(twiki_name)
   
!!     respond_to do |format|
!!       if @person.nil?
!!         flash[:error] = "Person #{params[:twiki_name]} is not in this system."
!!         format.html { redirect_to(people_url) }
!!         format.xml { render :xml => @person.errors, :status => :unprocessable_entity }
         else
!!         format.html { render :html => @person, :layout => false } # show.html.erb
!!         format.xml { render :xml => @person }
         end
       end
     end
   
     #http://localhost:3000/people/new?first_name=Todd&last_name=Sedano&webiso_account=at33@andrew.cmu.edu&is_student=true&program=ECE&expires_at=2013-01-01
   
     # GET /people/new
     # GET /people/new.xml
     def new
!!     authorize! :create, User
   
!!     @person = User.new
!!     @person.is_active = true
!!     @person.webiso_account = params[:webiso_account]
!!     @person.personal_email = params[:personal_email]
!!     @person.is_student = params[:is_student]
!!     @person.is_staff = params[:is_staff]
!!     @person.first_name = params[:first_name]
!!     @person.last_name = params[:last_name]
!!     @person.masters_program = params[:program]
!!     @person.expires_at = params[:expires_at]
   
!!     if Rails.env.development?
!!       @domain = GOOGLE_DOMAIN
       else
!!       @domain = "sv.cmu.edu"
       end
   
   
!!     respond_to do |format|
!!       format.html # new.html.erb
!!       format.xml { render :xml => @person }
       end
     end
   
     # GET /people/1/edit
     def edit
!!     @person = User.find_by_param(params[:id])
   
!!     unless can? :update, @person #@person.id == current_user.id or current_user.is_admin?
!!       flash[:error] = "You're not allowed to edit this user's profile."
!!       redirect_to user_path(@person)
       end
     end
   
     # POST /people
     # POST /people.xml
     def create
!!     authorize! :create, User
   
!!     @person = User.new(params[:user])
!!     @person.updated_by_user_id = current_user.id
!!     @person.image_uri = ActionController::Base.helpers.asset_path("mascot.jpg")
!!     @person.image_uri_first = ActionController::Base.helpers.asset_path("mascot.jpg")
!!     @person.image_uri_second = ActionController::Base.helpers.asset_path("mascot.jpg")
!!     @person.image_uri_custom = ActionController::Base.helpers.asset_path("mascot.jpg")
!!     @person.photo_selection = "first"
   
!!     respond_to do |format|
   
!!       if @person.save
!!         create_google_email = params[:create_google_email]
!!         create_twiki_account = params[:create_twiki_account]
!!         create_active_directory_account = params[:create_active_directory_account]
   
!!         Delayed::Job.enqueue(PersonJob.new(@person.id, create_google_email, create_twiki_account, create_active_directory_account)) unless create_google_email.nil? && create_twiki_account.nil? && create_active_directory_account.nil?
   
!!         flash[:notice] = 'Person was successfully created.'
!!         format.html { redirect_to(@person) }
!!         format.xml { render :xml => @person, :status => :created, :location => @person }
         else
!!         format.html { render :action => "new" }
!!         format.xml { render :xml => @person.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     def upload_photo
!!     @person = User.find_by_param(params[:id])
!!     if (can? :upload_official_photo, User) && !params[:user][:photo_first].blank?
!!       @person.photo_first = params[:user][:photo_first]
       end
!!     if (can? :upload_official_photo, User) && !params[:user][:photo_second].blank?
!!       @person.photo_second = params[:user][:photo_second]
       end
   
!!     if !params[:user][:photo_custom].blank?
!!       @person.photo_custom = params[:user][:photo_custom]
       end
!!     @person.attributes = params[:user]
   
!!     respond_to do |format|
!!       if @person.save
!!         format.html { redirect_to edit_person_path(@person) }
!!         format.xml { head :ok }
         else
!!         format.html { render :action => "edit" }
!!         format.xml { render :xml => @person.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # PUT /people/1
     # PUT /people/1.xml
     def update
!!     @person = User.find_by_param(params[:id])
!!     authorize! :update, @person
   
!!     Rails.logger.info("People#update #{request.env["REQUEST_PATH"]} #{current_user.human_name} #{params}")
   
!!     @person.updated_by_user_id = current_user.id
   
!!     respond_to do |format|
!!       @person.attributes = params[:user]
!!       @person.expires_at = params[:user][:expires_at] if current_user.is_admin?
   
!!       if @person.save
!!         unless @person.is_profile_valid
!!           flash[:error] = "Please update your (social handles or biography) and your contact information"
           end
!!         flash[:notice] = 'Person was successfully updated.'
!!         format.html { redirect_to(@person) }
!!         format.xml { head :ok }
         else
!!         format.html { render :action => "edit" }
!!         format.xml { render :xml => @person.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # Checks whether the specified webiso account already exists.
     # Expected input is through the q=<account@andrew.cmu.edu> parameter
     # Output is an object with a single exists property set to whether the account
     # exists.
     # Requires user to be able to authenticate same-as-if creating.
     # GET /people/check_webiso_account
     def ajax_check_if_webiso_account_exists
!!     respond_with_existence User.find_by_webiso_account(params[:q])
     end
   
     # Checks whether the specified email account already exists.
     # Expected input is through the q=<account@andrew.cmu.edu> parameter
     # Output is an object with a single exists property set to whether the account
     # exists.
     # Requires user to be able to authenticate same-as-if creating.
     # GET /people/check_email
     def ajax_check_if_email_exists
!!     respond_with_existence User.find_by_email(params[:q])
     end
   
     # Creates a response from the specified object.
     # Output is an object with a single exists property set to whether the object
     # is not nil.
     def respond_with_existence obj
!!     result = {}
!!     result[:exists] = !obj.nil?
   
!!     respond_to do |format|
!!       format.json { render :json => result }
!!       format.xml { render :xml => result, :status => 200 }
       end
     end
   
     def revert_to_version
!!     @person = User.find_by_param(params[:id])
!!     @person.revert_to! params[:version_id]
!!     redirect_to :action => 'show', :id => @person
     end
   
     def robots
!!     logger.info("curriculum comment: robot detected")
!!     format.html # index.html.erb
     end
   
     # DELETE /people/1
     # DELETE /people/1.xml
     def destroy
!!     if !current_user.is_admin?
!!       flash[:error] = 'You don' 't have permission to do this action.'
!!       redirect_to(people_url) and return
       end
   
!!     @person = User.find_by_param(params[:id])
!!     @person.destroy
   
!!     respond_to do |format|
!!       format.html { redirect_to(people_url) }
!!       format.xml { head :ok }
       end
     end
   
   
     def my_teams
!!     @person = User.find_by_param(params[:id])
!!     if @person.nil?
!!       flash[:error] = "Person with an id of #{params[:id]} is not in this system."
!!       redirect_to(people_url) and return
       end
   
!!     person_id = @person.id.to_i
!!     if (current_user.id != person_id)
!!       unless (current_user.is_staff?)||(current_user.is_admin?)
!!         flash[:error] = 'You don' 't have permission to see another person' 's teams.'
!!         redirect_to(people_url) and return
         end
       end
!!     @course = Course.new()
   
!!     @current_year = Date.today.year()
!!     @current_semester = AcademicCalendar.current_semester()
   
       #SQL statements determined by Team Juran
!!     @current_teams_as_member = Team.find_current_by_person(@person)
!!     @past_teams_as_member = Team.find_past_by_person(@person)
   
!!     (@teams_map, @teams_students_map) = current_user.faculty_teams_map(person_id)
!!     a = 10
     end
   
     def my_courses
!!     @person = User.find_by_param(params[:id])
!!     if @person.nil?
!!       flash[:error] = "Person with an id of #{params[:id]} is not in this system."
!!       redirect_to(people_url) and return
       end
   
!!     person_id = @person.id.to_i
!!     if (current_user.id != person_id)
!!       unless (current_user.is_staff?)||(current_user.is_admin?)
!!         flash[:error] = 'You don' 't have permission to see another person' 's courses.'
!!         redirect_to(people_url) and return
         end
       end
!!     @registered_for_these_courses = [] #@person.registered_for_these_courses
!!     @teaching_these_courses = @person.teaching_these_courses
     end
   
     def my_courses_verbose
!!     @person = User.find_by_param(params[:id])
!!     person_id = @person.id.to_i
!!     if (current_user.id != person_id)
!!       unless (current_user.is_staff?)||(current_user.is_admin?)
!!         flash[:error] = 'You don' 't have permission to see another person' 's courses.'
!!         redirect_to(people_url) and return
         end
       end
!!     @courses_registered_as_student = @person.registered_for_these_courses_during_current_semester
!!     @courses_teaching_as_faculty = @person.teaching_these_courses
     end
   
   
     class ClassProfileState
       attr_accessor :graduation_year, :is_part_time, :program
     end
   
   
     def class_profile
!!     if params[:class_profile_state]
!!       @class_profile_state = ClassProfileState.new
!!       @class_profile_state.program = params[:class_profile_state][:program]
!!       @class_profile_state.graduation_year = params[:class_profile_state][:graduation_year]
!!       @class_profile_state.is_part_time = params[:class_profile_state][:is_part_time]
       else
!!       @class_profile_state = ClassProfileState.new
!!       @class_profile_state.program = current_user.is_student ? current_user.masters_program : "SE"
!!       @class_profile_state.graduation_year = Date.today.year + 1
!!       @class_profile_state.is_part_time = current_user.is_student && !current_user.is_part_time ? "FT" : "PT"
       end
   
!!     case @class_profile_state.is_part_time
         when "PT"
!!         @students = User.part_time_class_of(@class_profile_state.program, @class_profile_state.graduation_year.to_s)
         when "FT"
!!         @students = User.full_time_class_of(@class_profile_state.program, @class_profile_state.graduation_year.to_s)
       end
!!     @programs = []
!!     ActiveRecord::Base.connection.execute("SELECT distinct masters_program FROM users u;").each do |result|
!!       @programs << result["masters_program"]
       end
!!     @tracks = []
!!     ActiveRecord::Base.connection.execute("SELECT distinct masters_track FROM users u;").each do |result|
!!       @tracks << result["masters_track"]
       end
   
!!     @title = "Class profile for #{@class_profile_state.is_part_time} #{@class_profile_state.program} #{@class_profile_state.graduation_year}"
   
!!     respond_to do |format|
!!       if params[:layout]
!!         format.html { render :layout => false } # index.html.erb
         else
!!         format.html { render :layout => "cmu_sv" } # index.html.erb
         end
       end
     end
   
     # GET /people/download_csv
     #
     # Export the search results in csv format
     def download_csv
!!     if params[:search_id].blank?
         # this is for multiple contacts
!!       @people = get_search_or_key_contacts(params)
       else
         # this is for a single contact
!!       @people = []
!!       @people << User.find_by_id(params[:search_id])
       end
!!     respond_to do |format|
!!       format.csv do
!!         csv_string = CSV.generate do |csv|
!!           csv << ["Name", "Given Name", "Additional Name", "Family Name", "Yomi Name", "Given Name Yomi", "Additional Name Yomi", "Family Name Yomi", "Name Prefix", "Name Suffix", "Initials", "Nickname", "Short Name", "Maiden Name", "Birthday", "Gender", "Location", "Billing Information", "Directory Server", "Mileage", "Occupation", "Hobby", "Sensitivity", "Priority", "Subject", "Notes", "Group Membership", "E-mail 1 - Type", "E-mail 1 - Value", "E-mail 2 - Type", "E-mail 2 - Value", "Phone 1 - Type", "Phone 1 - Value", "Phone 2 - Type", "Phone 2 - Value", "Phone 3 - Type", "Phone 3 - Value", "Phone 4 - Type", "Phone 4 - Value", "Organization 1 - Type", "Organization 1 - Name", "Organization 1 - Yomi Name", "Organization 1 - Title", "Organization 1 - Department", "Organization 1 - Symbol", "Organization 1 - Location", "Organization 1 - Job Description"]
!!           @people.each do |user|
!!             org = user.organization_name.nil? ? "" : user.organization_name
!!             title = user.title.nil? ? "" : user.title
               csv << [user.first_name, user.first_name, "", user.last_name, "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", user.is_staff? ? "Work" : "Other", user.email, "Home", user.personal_email,
   
                       csv_name_converter(user.telephone1_label), user.telephone1,
                       csv_name_converter(user.telephone2_label), user.telephone2,
                       csv_name_converter(user.telephone3_label), user.telephone3,
                       csv_name_converter(user.telephone4_label), user.telephone4,
!!                     "", org, "", title, "", "", "", ""]
             end
           end
!!         send_data csv_string,
                     :type => "text/csv; charset=utf-8",
                     :disposition => "attachment; filename=contact.csv"
         end
       end
     end
   
     # GET /people/download_vcf
     #
     # Export the search results in vCard format
     def download_vcf
!!     if params[:search_id].blank?
         # this is for multiple contacts
!!       @people = get_search_or_key_contacts(params)
       else
         # this is for a single contact
!!       @people = []
!!       @people << User.find_by_id(params[:search_id])
       end
!!     vcard_str=""
!!     @people.each do |user|
!!       card = Vpim::Vcard::Maker.make2 do |maker|
!!         maker.add_name do |name|
!!           name.prefix = ''
!!           name.given = user.first_name
!!           name.family = user.last_name
           end
!!         phones_hash = user.telephones_hash
!!         if (!user.email.blank?)
!!           maker.add_email(user.email) { |e| e.location = user.is_staff? ? 'work' : 'other' }
           end
!!         if (!user.personal_email.blank?)
!!           maker.add_email(user.personal_email) { |e| e.location = 'home' }
           end
!!         maker.title = user.title unless user.title.nil?
!!         maker.org = user.organization_name unless user.organization_name.nil?
   
!!         phones_hash.each do |k, v|
             # ignore empty telephone fields
!!           if (!v.blank?)
!!             maker.add_tel(v) do |tel|
!!               tel.location = "work" if k == "Work"
!!               tel.location = "home" if k == "Home"
!!               tel.location = "fax" if k == "Fax"
!!               tel.location = "cell" if k == "Mobile"
!!               tel.location = "voice" if k == "Google Voice"
               end
             end
           end
         end
!!       vcard_str << card.to_s
       end
!!     send_data vcard_str,
                 :type => "text/vcf; charset=utf-8",
                 :disposition => "attachment; filename=contact.vcf"
     end
   
     private
   
     # Private function that does the heavy lifting for all search
     #
     # search params:
     #     user_type
     #         F => Faculty
     #         S => Students
     #         T => Staff
     #         P => Part Time students
     #         L => Full Time students
     #         (can be clubbed e.g. SL for Full time students)
     #     filterBoxOne
     #         keywords typed in the search box
     #     graduation_year
     #     masters_program
     #     is_active
     def search_db_fields
!!     people = User.scoped
   
       # check user_type
!!     if !params[:user_type].blank?
!!       where_clause_string = ""
!!       if params[:user_type].include? "F" or params[:user_type].include? "S" or params[:user_type].include? "T"
           # if (params[:user_type] =~ /[FST]/) == 0
!!         where_clause_string << "("
!!         where_clause_string << " is_faculty = 't' OR " if params[:user_type].include?("F")
!!         where_clause_string << " is_student = 't' OR " if params[:user_type].include?("S")
!!         where_clause_string << " is_staff = 't' OR " if params[:user_type].include?("T")
           # remove last OR
!!         where_clause_string= where_clause_string[0..-4]
!!         where_clause_string << ")"
         end
!!       people = people.where(where_clause_string) unless where_clause_string.blank?
         # user_type - P => Part Time students
!!       people = people.where("is_part_time = 't'") if params[:user_type].include?("P")
         # user_type - L => Full Time students
!!       people = people.where("is_part_time = 'f'") if params[:user_type].include?("L")
       end
   
       # search more db fields (checks all entered keywords with db fields)
!!     if !params[:filterBoxOne].blank?
!!       params[:filterBoxOne].split.each do |query|
!!         query = "%#{query}%"
!!         people = people.where("first_name ILIKE ? OR last_name ILIKE ? OR human_name ILIKE ? OR biography ILIKE ? OR email ILIKE ? OR title ILIKE ? OR webiso_account ILIKE ? OR organization_name ILIKE ? OR personal_email ILIKE ? OR work_city ILIKE ? OR work_state ILIKE ? OR work_country ILIKE ?", query, query, query, query, query, query, query, query, query, query, query, query)
         end
       end
   
       # advanced search filter parameters
!!     people = people.where("graduation_year = ?", "#{params[:graduation_year]}") unless params[:graduation_year].blank?
!!     people = people.where("masters_program = ?", "#{params[:masters_program]}") unless params[:masters_program].blank?
!!     people = people.where("is_active = 't'") unless params[:search_inactive] == 't'
!!     people = people.joins(:registrations).where("registrations.course_id=?", "#{params[:course_id]}") unless params[:course_id].blank?
       #    people = people.joins(:teams).where("teams.course_id=?","#{params[:course_id]}") unless params[:course_id].blank?
!!     people = people.order("first_name ASC, last_name ASC")
     end
   
     # helper function that prioritizes the search results (if name was entered as part of search result, that is shown first vs it being found in bio/profile etc)
     def prioritize_search_results
!!     priority_results = User.scoped
!!     if !params[:filterBoxOne].blank?
!!       params[:filterBoxOne].split.each do |query|
!!         query = '%'+query+'%'
!!         priority_results = priority_results.where("first_name ILIKE ? OR last_name ILIKE ? OR human_name ILIKE ? OR organization_name ILIKE ?", query, query, query, query)
         end
       end
!!     priority_results = priority_results.collect { |result| result.id }
     end
   
     # Private function to get the key_contacts for a logged in user
     # (lovingly called group_box)
     def get_default_key_contacts
!!     @user = current_user
!!     if (current_user.is_admin? || current_user.is_staff?)
!!       if !params[:id].blank?
!!         @user_override = true
!!         @user = User.find_by_param(params[:id])
         end
       end
!!     results = PeopleSearchDefault.default_search_results(@user)
     end
   
     # Private helper function currently used by download_vcf and download_csv
     # to decide whether to return key_contacts or search_results from the search_params
     def get_search_or_key_contacts(search_params)
!!     if !search_params[:filterBoxOne].blank? || !search_params[:advanced_search_toggled].blank?
         # a specific search was issued, so return the exact search results for exporting contact details
!!       search_db_fields
       else
         # no specific search issues, return key_contact results
!!       @defaults = get_default_key_contacts
!!       @people = []
!!       @defaults.each do |default|
!!         @people << User.find(default.user_id)
         end
!!       return @people.uniq
       end
     end
   
     # private helper function to get correct keyname mappings for csv
     def csv_name_converter(origin)
!!     case origin
         when "Work"
!!         return "work"
         when "Home"
!!         return "home"
         when "Fax"
!!         return "fax"
         when "Mobile"
!!         return "cell"
         when "Google Voice"
!!         return "voice"
         else
!!         return ""
       end
     end
   
   end

================================================================================
 ./app/controllers/presentations_controller.rb
================================================================================
   class PresentationsController < ApplicationController
     layout 'cmu_sv'
   
     before_filter :authenticate_user!
   
     @@eval_options = {
         4 => "Outstanding",
         3 => "Good",
         2 => "Minimally Acceptable",
         1 => "Poor"
     }
   
     def my_presentations
!!     user = User.find_by_param(params[:id])
!!     if (current_user.id != user.id)
!!       unless (current_user.is_staff?)||(current_user.is_admin?)
!!         flash[:error] = I18n.t(:not_your_presentation)
!!         redirect_to root_path and return
         end
       end
!!     @presentations = Presentation.find_by_presenter(user)
     end
   
     def today
!!     if current_user.is_student?
!!       team_id = Team.find_by_person(current_person)
         #@presentations = Presentation.where(
         #  "(team_id is Null AND user_id != :id) OR (team_id is not Null AND team_id != :team_id)",
         #  {:id => current_user.id, :team_id => team_id})
!!       @presentations = Presentation.order("presentation_date DESC")
       else
!!       @presentations = Presentation.order("presentation_date DESC")
       end
!!     @presentations = Presentation.where(:presentation_date => Date.today)
     end
   
     def index
!!     @presentations = Presentation.order("presentation_date DESC")
     end
   
     # GET /courses/:course_id/presentations
     def index_for_course
!!     @course = Course.find(params[:course_id])
!!     if (current_user.is_admin? || @course.faculty.include?(current_user))
!!       @presentations = Presentation.find_all_by_course_id(@course.id)
       else
!!       has_permissions_or_redirect(:admin, root_path)
       end
     end
   
     # GET /course/:person_id/presentations/new
     def new
!!     @course = Course.find(params[:course_id])
!!     if (current_person.is_admin? || @course.faculty.include?(current_user))
!!       @presentation = Presentation.new(:presentation_date => Date.today)
!!       @course =Course.find_by_id(params[:course_id])
       else
!!       has_permissions_or_redirect(:admin, root_path)
       end
     end
   
     # GET /course/:person_id/presentations/:id/edit
     #def edit
     #  @presentation = Presentation.find(:course_id)
     #  if (current_person.is_admin? || @course.faculty.include?(current_user))
     #    @presentation = Presentation.new(:presentation_date => Date.today)
     #    @course =Course.find_by_id(params[:course_id])
     #  else
     #     has_permissions_or_redirect(:admin, root_path)
     #  end
     #end
   
     # POST /course/:person_id/presentations
     def create
!!     @course = Course.find(params[:course_id])
   
!!     @presentation = Presentation.new(:name => params[:presentation][:name],
                                        :team_id => params[:presentation][:team_id],
                                        :presentation_date => params[:presentation][:presentation_date],
                                        :task_number => params[:presentation][:task_number],
                                        :course_id => params[:course_id],
                                        :creator_id => current_user.id)
   
!!     human_name = params[:presentation][:user]
!!     unless human_name.blank?
!!       user = User.find_by_human_name(human_name)
!!       if user.nil?
!!         flash[:error] = "Can't find person #{human_name}"
!!         render :action => "new" and return
         else
!!         @presentation.user_id = user.id
         end
       end
   
   
!!     respond_to do |format|
!!       if @presentation.save
!!         format.html { redirect_to(course_presentations_path, :course_id => params[:course_id], :notice => 'Successfully created the presentation.') }
         else
!!         format.html { render :action => "new" }
         end
       end
     end
   
   
     def new_feedback
!!     store_previous_location
   
       # Check existence of requested presentation
!!     @feedback = PresentationFeedback.new
!!     @feedback.presentation_id = params[:id]
!!     @questions = PresentationQuestion.existing_questions
!!     @eval_options = @@eval_options
!!     @presentation = Presentation.find(params[:id])
!!     @ratings = []
!!     @comments = []
   
       # Check whether this user has already created a feedback
   
!!     respond_to do |format|
!!       format.html
       end
   
     end
   
     def create_feedback
       # Check existence of requested presentation
!!     @feedback = PresentationFeedback.new(params[:feedback])
!!     @questions = PresentationQuestion.existing_questions
!!     @eval_options = @@eval_options
!!     @feedback.evaluator = current_user
!!     @presentation = Presentation.find(params[:id])
!!     @feedback.presentation = @presentation
!!     @presentation.save
   
   
       # Necessary checks here
   
!!     respond_to do |format|
   
!!       is_successful = true
   
!!       params[:evaluation].each do |key, value|
!!         answer = PresentationFeedbackAnswer.new(value)
!!         begin
!!           question = PresentationQuestion.find(key)
           rescue ActiveRecord::RecordNotFound => e
!!           is_successful = false
!!           break
           end
!!         @feedback.answers << answer
!!         answer.question = question
         end
   
!!       if is_successful && @feedback.save
!!         @presentation.feedback_email_sent = true
   
!!         if @presentation.feedback_email_sent?
!!           @presentation.send_presentation_feedback_email(show_feedback_for_presentation_url(:id => params[:id]))
           end
!!         format.html { redirect_back_or_default(today_presentations_url) }
         else
!!         format.html { render :action => "new_feedback" }
         end
       end
   
     end
   
     def update_feedback
!!     feedback = PresentationFeedback.find_by_evaluator_id_and_presentation_id(current_user, params[:id])
   
!!     params[:evaluation].each do |key, value|
!!       answer = PresentationFeedbackAnswer.find_by_feedback_id_and_question_id(feedback.id, key)
!!       if answer
!!         answer.rating = value["rating"]
!!         answer.comment = value["comment"]
!!         answer.save
         end
       end
   
!!     respond_to do |format|
!!       flash[:notice] = I18n.t(:presentation_feedback_updated)
!!       format.html { redirect_back_or_default(today_presentations_url) }
       end
     end
   
     def edit_feedback
!!     store_previous_location
   
!!     @presentation = Presentation.find(params[:id])
   
!!     feedbacks = PresentationFeedback.where(:presentation_id => params[:id])
   
!!     @feedback = nil
!!     @eval_options = @@eval_options
   
!!     @questions = PresentationQuestion.where(:deleted => false)
   
!!     feedbacks.each do |f|
!!       if f.evaluator_id == current_user.id
!!         @feedback = f
           # break
         end
       end
   
!!     @ratings = []
!!     @comments = []
!!     @questions.each do |q|
!!       feedback_answer = PresentationFeedbackAnswer.where(:question_id => q.id, :feedback_id => @feedback.id)
!!       @ratings << feedback_answer.first.rating
!!       @comments << feedback_answer.first.comment
       end
   
!!     respond_to do |format|
!!       format.html
       end
     end
   
     def show_feedback
!!     @presentation = Presentation.find(params[:id])
   
   
!!     unless @presentation.can_view_feedback?(current_user)
!!       flash[:error] = I18n.t(:not_your_presentation)
!!       redirect_to root_path and return
       end
   
!!     @feedbacks = PresentationFeedback.where(:presentation_id => params[:id])
   
!!     @faculty_feedbacks = []
!!     @student_feedbacks = []
   
!!     @questions = PresentationQuestion.where(:deleted => false)
   
!!     @feedbacks.each do |f|
!!       evaluator = User.find(f.evaluator_id)
!!       if evaluator.is_staff?
!!         @faculty_feedbacks << f
         elsif evaluator.is_student?
!!         @student_feedbacks << f
         end
       end
   
!!     @faculty_ratings = Presentation.find_ratings(@faculty_feedbacks, @questions)
!!     @student_ratings = Presentation.find_ratings(@student_feedbacks, @questions)
   
!!     @faculty_comments = Presentation.find_comments(@faculty_feedbacks, @questions)
!!     @student_comments = Presentation.find_comments(@student_feedbacks, @questions)
   
!!     respond_to do |format|
!!       format.html
       end
     end
   
   end

================================================================================
 ./app/controllers/rss_feeds_controller.rb
================================================================================
   class RssFeedsController < ApplicationController
     before_filter :authenticate_user!, :except => :index
   
     # GET /rss_feeds
     # GET /rss_feeds.xml
     def index
!!     @rss_feeds = RssFeed.all
!!     puts "hello world"
!!     respond_to do |format|
!!       format.html # index.html.erb
!!       format.xml { render :xml => @rss_feeds }
       end
     end
   
     # GET /rss_feeds/1
     # GET /rss_feeds/1.xml
     def show
!!     @rss_feed = RssFeed.find(params[:id])
   
!!     respond_to do |format|
!!       format.html # show.html.erb
!!       format.xml { render :xml => @rss_feed }
       end
     end
   
     # GET /rss_feeds/new
     # GET /rss_feeds/new.xml
     def new
!!     @rss_feed = RssFeed.new
   
!!     respond_to do |format|
!!       format.html # new.html.erb
!!       format.xml { render :xml => @rss_feed }
       end
     end
   
     # GET /rss_feeds/1/edit
     def edit
!!     @rss_feed = RssFeed.find(params[:id])
     end
   
     # POST /rss_feeds
     # POST /rss_feeds.xml
     def create
!!     @rss_feed = RssFeed.new(params[:rss_feed])
   
!!     respond_to do |format|
!!       if @rss_feed.save
!!         flash[:notice] = 'RssFeed was successfully created.'
!!         format.html { redirect_to(@rss_feed) }
!!         format.xml { render :xml => @rss_feed, :status => :created, :location => @rss_feed }
         else
!!         format.html { render :action => "new" }
!!         format.xml { render :xml => @rss_feed.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # PUT /rss_feeds/1
     # PUT /rss_feeds/1.xml
     def update
!!     @rss_feed = RssFeed.find(params[:id])
   
!!     respond_to do |format|
!!       if @rss_feed.update_attributes(params[:rss_feed])
!!         flash[:notice] = 'RssFeed was successfully updated.'
!!         format.html { redirect_to(@rss_feed) }
!!         format.xml { head :ok }
         else
!!         format.html { render :action => "edit" }
!!         format.xml { render :xml => @rss_feed.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # DELETE /rss_feeds/1
     # DELETE /rss_feeds/1.xml
     def destroy
!!     @rss_feed = RssFeed.find(params[:id])
!!     @rss_feed.destroy
   
!!     respond_to do |format|
!!       format.html { redirect_to(rss_feeds_url) }
!!       format.xml { head :ok }
       end
     end
   end

================================================================================
 ./app/controllers/scotty_dog_sayings_controller.rb
================================================================================
   class ScottyDogSayingsController < ApplicationController
     layout 'cmu_sv'
   
     before_filter :authenticate_user!
   
     # GET /scotty_dog_sayings
     # GET /scotty_dog_sayings.xml
     def index
!!     @scotty_dog_sayings = ScottyDogSaying.all
   
!!     respond_to do |format|
!!       format.html # index.html.erb
!!       format.xml { render :xml => @scotty_dog_sayings }
       end
     end
   
     # GET /scotty_dog_sayings/1
     # GET /scotty_dog_sayings/1.xml
     def show
!!     @scotty_dog_saying = ScottyDogSaying.find(params[:id])
   
!!     respond_to do |format|
!!       format.html # show.html.erb
!!       format.xml { render :xml => @scotty_dog_saying }
       end
     end
   
     # GET /scotty_dog_sayings/new
     # GET /scotty_dog_sayings/new.xml
     def new
!!     @scotty_dog_saying = ScottyDogSaying.new
   
!!     respond_to do |format|
!!       format.html # new.html.erb
!!       format.xml { render :xml => @scotty_dog_saying }
       end
     end
   
     # GET /scotty_dog_sayings/1/edit
     def edit
!!     @scotty_dog_saying = ScottyDogSaying.find(params[:id])
     end
   
     # POST /scotty_dog_sayings
     # POST /scotty_dog_sayings.xml
     def create
!!     @scotty_dog_saying = ScottyDogSaying.new(params[:scotty_dog_saying])
!!     @scotty_dog_saying.user_id = current_user.id if current_user
   
!!     respond_to do |format|
!!       if @scotty_dog_saying.save
!!         flash[:notice] = 'Thank you for adding to my reprotoire. Scotty Dog Saying was successfully created.'
!!         format.html { redirect_to(scotty_dog_sayings_path) }
!!         format.xml { render :xml => @scotty_dog_saying, :status => :created, :location => @scotty_dog_saying }
         else
!!         format.html { render :action => "new" }
!!         format.xml { render :xml => @scotty_dog_saying.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # PUT /scotty_dog_sayings/1
     # PUT /scotty_dog_sayings/1.xml
     def update
!!     @scotty_dog_saying = ScottyDogSaying.find(params[:id])
   
!!     respond_to do |format|
!!       if @scotty_dog_saying.update_attributes(params[:scotty_dog_saying])
!!         flash[:notice] = 'Thanks for giving me something better to say. Scotty Dog Saying was successfully updated.'
!!         format.html { redirect_to(scotty_dog_sayings_path) }
!!         format.xml { head :ok }
         else
!!         format.html { render :action => "edit" }
!!         format.xml { render :xml => @scotty_dog_saying.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # DELETE /scotty_dog_sayings/1
     # DELETE /scotty_dog_sayings/1.xml
     def destroy
!!     @scotty_dog_saying = ScottyDogSaying.find(params[:id])
!!     @scotty_dog_saying.destroy
   
!!     respond_to do |format|
!!       format.html { redirect_to(scotty_dog_sayings_url) }
!!       format.xml { head :ok }
       end
     end
   end

================================================================================
 ./app/controllers/search_controller.rb
================================================================================
   require 'open-uri'
   
   class SearchController < ApplicationController
     layout 'cmu_sv'
     before_filter :authenticate_user!
   
     def self.index_tank
!!     @api = IndexTank::Client.new(ENV['WHITEBOARD_SEARCHIFY_API_URL'] || 'http://your_api_url')
!!     @index ||= @api.indexes(ENV['WHITEBOARD_SEARCHIFY_INDEX'] || 'cmux')
!!     @index
     end
   
     # retrieve docs from IndexTank
     def self.search(query)
!!     query = query.gsub(/\W+/, ' ').strip
   
!!     if query.present?
!!       query << "*"
!!       index_tank.search("#{query} OR title:#{query}", :fetch => 'timestamp,url,text,title', :snippet => 'text')
       end
     end
   
     def index
!!     @docs = SearchController.search(params[:query]) if params[:query].present?
     end
   end

================================================================================
 ./app/controllers/sponsored_project_allocations_controller.rb
================================================================================
   class SponsoredProjectAllocationsController < ApplicationController
   
     layout 'cmu_sv'
   
     before_filter :authenticate_user!
   
     def index
!!     authorize! :read, SponsoredProjectAllocation
!!     @allocations = SponsoredProjectAllocation.current
     end
   
     def new
!!     authorize! :create, SponsoredProjectAllocation
!!     @allocation = SponsoredProjectAllocation.new
!!     @users = User.staff
!!     @projects = SponsoredProject.current
     end
   
     def edit
!!     authorize! :update, SponsoredProjectAllocation
!!     @allocation = SponsoredProjectAllocation.find(params[:id])
!!     @users = User.staff
!!     @projects = SponsoredProject.current
     end
   
     def create
!!     authorize! :create, SponsoredProjectAllocation
!!     @allocation = SponsoredProjectAllocation.new(params[:sponsored_project_allocation])
!!     @users = User.staff
!!     @projects = SponsoredProject.current
   
!!     if @allocation.save
!!       flash[:notice] = 'Allocation was successfully created.'
!!       redirect_to(sponsored_project_allocations_path)
       else
!!       render "new"
       end
     end
   
     def update
!!     authorize! :update, SponsoredProjectAllocation
!!     @allocation = SponsoredProjectAllocation.find(params[:id])
!!     @users = User.staff
!!     @projects = SponsoredProject.current
   
!!     if @allocation.update_attributes(params[:sponsored_project_allocation])
!!       flash[:notice] = 'Allocation was successfully updated.'
!!       redirect_to(sponsored_project_allocations_path)
       else
!!       render "edit"
       end
     end
   
     def archive
!!     authorize! :archive, SponsoredProjectAllocation
!!     @allocation = SponsoredProjectAllocation.find(params[:id])
!!     if @allocation.update_attributes({:is_archived => true})
!!       flash[:notice] = 'Allocation was successfully archived.'
!!       redirect_to(sponsored_project_allocations_path)
       else
!!       flash[:notice] = 'Allocation could not be archived.'
!!       redirect_to(sponsored_project_allocations_path)
       end
     end
   
   end

================================================================================
 ./app/controllers/sponsored_project_efforts_controller.rb
================================================================================
   class SponsoredProjectEffortsController < ApplicationController
   
     before_filter :authenticate_user!
   
     layout "cmu_sv"
   
     def index
!!     authorize! :read, SponsoredProjectEffort
!!     @month = params[:date][:month].to_i unless params[:date].nil?
!!     @month = @month ||= 1.month.ago.month
!!     @year = params[:year] ||= 1.month.ago.year
!!     @efforts = SponsoredProjectEffort.for_all_users_for_a_given_month(@month, @year)
     end
   
     def show
!!     redirect_to(edit_sponsored_project_effort_path)
     end
   
     def edit
!!     if authorized_or_redirect
!!       setup_edit
       end
     end
   
     def update
!!     if authorized_or_redirect
!!       effort_id_values = params[:effort_id_values]
   
!!       @failed = false
!!       @changed_allocation = false
!!       effort_id_values.each do |key, value|
!!         effort = SponsoredProjectEffort.find(key)
           #      @changed_allocation = true if effort.actual_allocation != value
!!         effort.actual_allocation = value
!!         @changed_allocation = true if effort.actual_allocation_changed?
!!         effort.confirmed = true
!!         unless effort.save
!!           @failed = true
           end
         end
!!       if @changed_allocation
!!         SponsoredProjectEffort.emails_business_manager(effort_id_values.keys[0])
         end
   
!!       if @failed
!!         flash.now[:error] = 'Your allocations did not save.'
         else
!!         flash.now[:notice] = 'Your allocations are confirmed.'
         end
   
!!       setup_edit
!!       render 'edit'
       end
     end
   
     private
     #Todo: refactor this method to use CanCan
     def authorized_or_redirect
!!     @user = User.find_by_twiki_name(params[:id])
!!     if (@user.nil?)
!!       flash[:error] = t(:no_person)
!!       redirect_to(root_path)
!!       return false
       end
   
!!     unless @user.id == current_user.id || can?(:update, SponsoredProjectEffort)
!!       flash[:error] = t(:no_permission)
!!       redirect_to(root_path)
!!       return false
       end
!!     return true
     end
   
     def setup_edit
!!     @efforts = SponsoredProjectEffort.month_under_inspection_for_a_given_user(@user.id)
!!     @month = !@efforts.empty? ? @efforts[0].month : 1.month.ago.month
!!     @year = !@efforts.empty? ? @efforts[0].year : 1.month.ago.year
     end
   
   end
   

================================================================================
 ./app/controllers/sponsored_project_sponsors_controller.rb
================================================================================
   class SponsoredProjectSponsorsController < ApplicationController
   
     layout 'cmu_sv'
   
     before_filter :authenticate_user!
   
     def new
!!     authorize! :create, SponsoredProjectSponsor
!!     store_previous_location
!!     @sponsor = SponsoredProjectSponsor.new
     end
   
     def edit
!!     authorize! :update, SponsoredProjectSponsor
!!     @sponsor = SponsoredProjectSponsor.find(params[:id])
     end
   
     def create
!!     authorize! :create, SponsoredProjectSponsor
!!     @sponsor = SponsoredProjectSponsor.new(params[:sponsored_project_sponsor])
   
!!     if @sponsor.save
!!       flash[:notice] = 'Sponsor was successfully created.'
!!       redirect_back_or_default(sponsored_projects_path)
       else
!!       render "new"
       end
     end
   
     def update
!!     authorize! :update, SponsoredProjectSponsor
!!     @sponsor = SponsoredProjectSponsor.find(params[:id])
   
!!     if @sponsor.update_attributes(params[:sponsored_project_sponsor])
!!       flash[:notice] = 'Sponsor was successfully updated.'
!!       redirect_to(sponsored_projects_path)
       else
!!       render "edit"
       end
     end
   
     def archive
!!     authorize! :archive, SponsoredProjectSponsor
!!     @sponsor = SponsoredProjectSponsor.find(params[:id])
!!     if @sponsor.update_attributes({:is_archived => true})
!!       flash[:notice] = 'Sponsor was successfully archived.'
!!       redirect_to(sponsored_projects_path)
       else
!!       flash[:notice] = 'Sponsor could not be archived.'
!!       redirect_to(sponsored_projects_path)
       end
     end
   
   end

================================================================================
 ./app/controllers/sponsored_projects_controller.rb
================================================================================
   class SponsoredProjectsController < ApplicationController
   
     before_filter :authenticate_user!
   
     layout 'cmu_sv'
   
     def index
!!     authorize! :read, SponsoredProject
!!     @projects = SponsoredProject.current
!!     @sponsors = SponsoredProjectSponsor.current
     end
   
     def new
!!     authorize! :create, SponsoredProject
!!     store_previous_location
!!     @project = SponsoredProject.new
!!     @sponsors = SponsoredProjectSponsor.current
     end
   
     def edit
!!     authorize! :update, SponsoredProject
!!     @project = SponsoredProject.find(params[:id])
!!     @sponsors = SponsoredProjectSponsor.current
     end
   
     def create
!!     authorize! :create, SponsoredProject
!!     @project = SponsoredProject.new(params[:sponsored_project])
!!     @sponsors = SponsoredProjectSponsor.current
   
!!     if @project.save
!!       flash[:notice] = 'Project was successfully created.'
!!       redirect_back_or_default(sponsored_projects_path)
       else
!!       render "new"
       end
     end
   
     def update
!!     authorize! :update, SponsoredProject
!!     @project = SponsoredProject.find(params[:id])
!!     @sponsors = SponsoredProjectSponsor.current
   
!!     if @project.update_attributes(params[:sponsored_project])
!!       flash[:notice] = 'Project was successfully updated.'
!!       redirect_to(sponsored_projects_path)
       else
!!       render "edit"
       end
     end
   
     def archive
!!     authorize! :archive, SponsoredProject
!!     @project = SponsoredProject.find(params[:id])
!!     if @project.update_attributes({:is_archived => true})
!!       flash[:notice] = 'Project was successfully archived.'
!!       redirect_to(sponsored_projects_path)
       else
!!       flash[:notice] = 'Project could not be archived.'
!!       redirect_to(sponsored_projects_path)
       end
     end
   
   end

================================================================================
 ./app/controllers/static_controller.rb
================================================================================
   class StaticController < ApplicationController
     layout 'cmu_sv'
   
     before_filter :authenticate_user!
   
   end

================================================================================
 ./app/controllers/suggestions_controller.rb
================================================================================
   class SuggestionsController < ApplicationController
     layout 'cmu_sv'
   
   
     # GET /suggestions
     # GET /suggestions.xml
     def index
!!     @suggestions = Suggestion.all
   
!!     respond_to do |format|
!!       format.html # index.html.erb
!!       format.xml { render :xml => @suggestions }
       end
     end
   
     # GET /suggestions/1
     # GET /suggestions/1.xml
     def show
!!     @suggestion = Suggestion.find(params[:id])
   
!!     respond_to do |format|
!!       format.html # show.html.erb
!!       format.xml { render :xml => @suggestion }
       end
     end
   
     # GET /suggestions/new
     # GET /suggestions/new.xml
     def new
       @suggestion = Suggestion.new
       @suggestion.page = request.env["HTTP_REFERER"]
   
       respond_to do |format|
         format.html # new.html.erb
         format.xml { render :xml => @suggestion }
       end
     end
   
     # GET /suggestions/1/edit
     def edit
!!     @suggestion = Suggestion.find(params[:id])
   
     end
   
     # POST /suggestions
     # POST /suggestions.xml
     def create
       @suggestion = Suggestion.new(params[:suggestion])
       @suggestion.user_id = current_user.id if current_user
       page = @suggestion.page
   
   
       respond_to do |format|
         if @suggestion.save
           flash[:notice] = 'Thank you for your suggestion'
           format.html { redirect_to @suggestion.page }
           format.xml { render :xml => @suggestion, :status => :created, :location => @suggestion }
         else
!!         format.html { render :action => "new" }
!!         format.xml { render :xml => @suggestion.errors, :status => :unprocessable_entity }
         end
       end
   
       email_suggestion(@suggestion, "created")
     end
   
     # PUT /suggestions/1
     # PUT /suggestions/1.xml
     def update
!!     @suggestion = Suggestion.find(params[:id])
   
!!     respond_to do |format|
!!       if @suggestion.update_attributes(params[:suggestion])
!!         flash[:notice] = 'suggestion was successfully updated.'
!!         format.html { redirect_to(@suggestion) }
!!         format.xml { head :ok }
         else
!!         format.html { render :action => "edit" }
!!         format.xml { render :xml => @suggestion.errors, :status => :unprocessable_entity }
         end
       end
   
!!     email_suggestion(@suggestion, "updated")
     end
   
     # DELETE /suggestions/1
     # DELETE /suggestions/1.xml
     def destroy
!!     @suggestion = Suggestion.find(params[:id])
!!     @suggestion.destroy
   
!!     respond_to do |format|
!!       format.html { redirect_to(suggestions_url) }
!!       format.xml { head :ok }
       end
     end
   
   
     def email_suggestion(suggestion, status)
   
       message = "\"#{suggestion.comment}\"<br/><br/>"
       message = message + "by #{suggestion.user.human_name}" unless suggestion.user.nil?
   
       options = {:to => "todd.sedano@sv.cmu.edu",
                  :subject => "Suggestion #{status}",
                  :message => message,
                  :url_label => "Show this suggestion",
                  :url => "http://whiteboard.sv.cmu.edu" + suggestion_path(suggestion)
       }
       GenericMailer.email(options).deliver
   
     end
   
   end

================================================================================
 ./app/controllers/system_controller.rb
================================================================================
   class SystemController < ApplicationController
   
     def index
       @current_user = current_user
   
       respond_to do |format|
         format.html # index.html.erb
         format.xml { render :xml => @effort_logs }
       end
     end
   
   end

================================================================================
 ./app/controllers/task_types_controller.rb
================================================================================
   class TaskTypesController < ApplicationController
     layout 'cmu_sv'
   
     before_filter :authenticate_user!
   
     # GET /task_types
     # GET /task_types.xml
     def index
   #    @task_types = TaskType.locate_appropriate_by_user_type
!!     @task_types = locate_appropriate_by_user_type
       ##
!!     respond_to do |format|
!!       format.html # index.html.erb
!!       format.xml { render :xml => @task_types }
       end
     end
   
     # GET /task_types/1
     # GET /task_types/1.xml
     def show
!!     @task_type = TaskType.find(params[:id])
   
!!     respond_to do |format|
!!       format.html # show.html.erb
!!       format.xml { render :xml => @task_type }
       end
     end
   
     # GET /task_types/new
     # GET /task_types/new.xml
     def new
!!     if !(current_user.is_admin? || current_user.is_staff?)
!!       flash[:error] = "You don't have permission to do this action."
!!       redirect_to(task_types_url) and return
       end
   
!!     @task_type = TaskType.new
   
!!     respond_to do |format|
!!       format.html # new.html.erb
!!       format.xml { render :xml => @task_type }
       end
     end
   
     # GET /task_types/1/edit
     def edit
!!     if !(current_user.is_admin? || current_user.is_staff?)
!!       flash[:error] = "You don't have permission to do this action."
!!       redirect_to(task_type_url) and return
       end
   
!!     @task_type = TaskType.find(params[:id])
     end
   
     # POST /task_types
     # POST /task_types.xml
     def create
!!     if !(current_user.is_admin? || current_user.is_staff?)
!!       flash[:error] = "You don't have permission to do this action."
!!       redirect_to(task_types_url) and return
       end
   
!!     @task_type = TaskType.new(params[:task_type])
   
!!     respond_to do |format|
!!       if @task_type.save
!!         flash[:notice] = 'TaskType was successfully created.'
!!         format.html { redirect_to(@task_type) }
!!         format.xml { render :xml => @task_type, :status => :created, :location => @task_type }
         else
!!         format.html { render :action => "new" }
!!         format.xml { render :xml => @task_type.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # PUT /task_types/1
     # PUT /task_types/1.xml
     def update
!!     if !(current_user.is_admin? || current_user.is_staff?)
!!       flash[:error] = "You don't have permission to do this action."
!!       redirect_to(task_type_url) and return
       end
   
!!     @task_type = TaskType.find(params[:id])
   
!!     respond_to do |format|
!!       if @task_type.update_attributes(params[:task_type])
!!         flash[:notice] = 'TaskType was successfully updated.'
!!         format.html { redirect_to(@task_type) }
!!         format.xml { head :ok }
         else
!!         format.html { render :action => "edit" }
!!         format.xml { render :xml => @task_type.errors, :status => :unprocessable_entity }
         end
       end
     end
   
     # DELETE /task_types/1
     # DELETE /task_types/1.xml
     def destroy
!!     if !current_user.is_admin?
!!       flash[:error] = 'You don' 't have permission to do this action.'
!!       redirect_to(task_types_url) and return
       end
   
!!     @task_type = TaskType.find(params[:id])
!!     @task_type.destroy
   
!!     respond_to do |format|
!!       format.html { redirect_to(task_types_url) }
!!       format.xml { head :ok }
       end
     end
   
     private
     def locate_appropriate_by_user_type
!!     if current_user.is_student? && current_user.is_staff?
!!       task_types = TaskType.all
       end
!!     if current_user.is_student? && !current_user.is_staff?
!!       task_types = TaskType.where(:is_student => true).all
       end
!!     if !current_user.is_student? && current_user.is_staff?
!!       task_types = TaskType.where(:is_staff => true).all
       end
!!     if !current_user.is_student? && !current_user.is_staff?
!!       task_types = TaskType.all
       end
!!     return task_types
     end
   end

================================================================================
 ./app/controllers/teams_controller.rb
================================================================================
   class TeamsController < ApplicationController
     before_filter :authenticate_user!, :except => [:index, :twiki_index, :twiki_new]
     require 'csv'
   
     layout 'cmu_sv'
   
     # GET /courses/1/teams
     # GET /courses/1/teams.xml
     def index
       @show_teams_for_many_courses = false
       @machine_name = ""
       @teams = Team.where(:course_id => params[:course_id]).order("id").all unless params[:course_id].empty?
       @course = Course.find(params[:course_id])
   
       @show_section = false
       @teams.each do |team|
!!       @show_section = true unless (team.section.nil? || team.section.empty?)
       end
   
       respond_to do |format|
         format.html { render :partial => "twiki_index", :locals => {:teams => @teams, :show_new_teams_link => true, :show_photo_view_link => true, :show_student_photos => false, :show_course => false} } # index.html.erb
         format.xml { render :xml => @teams }
       end
     end
   
     # Create a new team from a team table page hosted on the twiki server
     def twiki_new
       if has_permissions_or_redirect(:staff, root_path)
         # Example url:
         # http://info.sv.cmu.edu/twiki/bin/view/Fall2008/Foundations/StudentTeams
         # http://info.sv.cmu.edu/twiki/bin/view/Fall2009/Foundations/WebHome
!!       url = get_twiki_http_referer()
!!       @course = Course.where(:twiki_url => url).first
!!       if (@course.nil?)
!!         parts = url.split('/')
!!         @course = Course.new()
!!         @course.twiki_url = url
!!         @course.name = parts[parts.length - 2]
!!         match = parts[parts.length - 3].match /(\D+)(\d+)/
!!         @course.semester = match[1] unless (match.nil? || match[1].nil?)
!!         @course.year = match[2] unless (match.nil? || match[2].nil?)
   
!!         if !@course.save()
!!           flash[:error] = 'Course could not be created.'
           end
         else
           #error
         end
!!       redirect_to url
       end
     end
   
     # generate the team table for a course on a page hosted on the twiki server
     def twiki_index
!!     @show_teams_for_many_courses = false
!!     @machine_name = "http://whiteboard.sv.cmu.edu"
   
!!     url = get_twiki_http_referer()
!!     @course = Course.where(:twiki_url => url).first
   
!!     @show_create_course = false
!!     if (@course.nil?)
!!       @show_create_course = true
!!       render :partial => "twiki_index", :layout => false, :locals => {:teams => @teams, :show_new_teams_link => true, :show_photo_view_link => true, :show_student_photos => false, :show_course => false}
!!       return
       end
!!     @teams = Team.where(:course_id => @course.id).order("id").all unless @course.nil?
   
!!     @show_section = false
!!     @teams.each do |team|
!!       @show_section = true unless (team.section.nil? || team.section.empty?)
       end
   
!!     render :partial => "twiki_index", :layout => false, :locals => {:teams => @teams, :show_new_teams_link => true, :show_photo_view_link => true, :show_student_photos => false, :show_course => false}
     end
   
     def index_photos
!!     @teams = Team.where(:course_id => params[:course_id]).order("id").all unless params[:course_id].empty?
!!     @course = Course.find(params[:course_id])
   
!!     respond_to do |format|
!!       format.html { render :html => @teams, :layout => "simple" } # index.html.erb
!!       format.xml { render :xml => @teams }
       end
     end
   
     def past_teams_list
!!     if has_permissions_or_redirect(:staff, root_path)
!!       @teams = Team.where(:course_id => params[:course_id]).order("id").all unless params[:course_id].empty?
!!       @course = Course.find(params[:course_id])
   
!!       respond_to do |format|
!!         format.html { render :html => @teams, :layout => "cmu_sv" } # index.html.erb
!!         format.xml { render :xml => @teams }
         end
       end
     end
   
     def export_to_csv
!!     if has_permissions_or_redirect(:staff, root_path)
   
!!       @course = Course.find(params[:course_id])
!!       @teams = Team.where(:course_id => params[:course_id]).order("id").all unless params[:course_id].empty?
   
!!       report = CSV.generate do |title|
!!         title << ['Team Name', 'Team Member', 'Past Teams', "Part Time", "Local/Near/Remote", "State", "Company Name"]
!!         @teams.each do |team|
!!           team.members.each do |user|
!!             part_time = user.is_part_time ? "PT" : "FT"
!!             title << [team.name, user.human_name, user.formatted(user.past_teams), part_time, user.local_near_remote, user.work_state, user.organization_name]
             end
           end
         end
!!       send_data(report, :type => 'text/csv;charset=iso-8859-1;', :filename => "past_teams_for_#{@course.display_course_name}.csv",
                   :disposition => 'attachment', :encoding => 'utf8')
       end
     end
   
   
     # GET /teams
     # GET /teams.xml
     def index_all
!!     @show_teams_for_many_courses = true
!!     @show_create_course = false
!!     @show_section = false
!!     @machine_name = ""
   
       #If possible, we would prefer to do an order by in sql to sort latest semester alphabetical by course name.
!!     @teams = Team.order("course_id DESC").all
       #    @teams = @teams.sort_by {|team| team.course.year + team.course.semester + team.course.name }.reverse
   
!!     respond_to do |format|
!!       format.html { render :partial => "twiki_index", :locals => {:teams => @teams, :show_new_teams_link => false, :show_photo_view_link => false, :show_student_photos => false, :show_course => false} } # index.html.erb
!!       format.xml { render :xml => @teams }
       end
     end
   
   
     # GET /courses/1/teams/1
     # GET /courses/1/teams/1.xml
     def show
!!     @course = Course.find(params[:course_id])
!!     @team = Team.find(params[:id])
   
!!     respond_to do |format|
!!       format.html # show.html.erb
!!       format.xml { render :xml => @team }
       end
     end
   
     # GET /courses/1/teams/new
     # GET /courses/1/teams/new.xml
     def new
!!     if has_permissions_or_redirect(:staff, root_path)
!!       @team = Team.new()
!!       @team.course_id = params[:course_id]
!!       @course = Course.find(params[:course_id])
!!       @faculty = @course.faculty
!!       (1..5).each do
!!         @team.members << User.new
         end
   
!!       respond_to do |format|
!!         format.html # new.html.erb
!!         format.xml { render :xml => @team }
         end
       end
     end
   
     # GET /courses/1/teams/1/edit
     def edit
!!     @team = Team.find(params[:id])
!!     @course = Course.find(params[:course_id])
!!     if has_permissions_or_redirect(:staff, course_team_path(@course, @team))
!!       @team.course_id = params[:course_id]
!!       @faculty = @course.faculty
       end
     end
   
     # POST /courses/1/teams
     # POST /courses/1/teams.xml
     def create
!!     if has_permissions_or_redirect(:staff, root_path)
!!       params[:team][:members_override] = params[:persons]
!!       @team = Team.new(params[:team])
   
!!       @team.course_id = params[:course_id]
!!       @course = Course.find(params[:course_id])
   
!!       update_course_faculty_label
   
!!       respond_to do |format|
!!         if @team.save
!!           flash[:notice] = 'Team was successfully created.'
!!           format.html { redirect_to(course_teams_path(@team.course_id)) }
!!           format.xml { render :xml => @team, :status => :created, :location => @team }
           else
!!           @faculty = @course.faculty
!!           format.html { render :action => "new" }
!!           format.xml { render :xml => @team.errors, :status => :unprocessable_entity }
           end
         end
       end
     end
   
     # PUT /courses/1/teams/1
     # PUT /courses/1/teams/1.xml
     def update
!!     params[:team][:members_override] = params[:persons]
!!     @team = Team.find(params[:id])
!!     @course = @team.course
!!     if has_permissions_or_redirect(:staff, course_team_path(@course, @team))
   
!!       update_course_faculty_label
   
!!       respond_to do |format|
!!         @team.attributes = params[:team]
!!         if @team.save(params[:team])
!!           flash[:notice] = 'Team was successfully updated.'
!!           format.html { redirect_to(course_teams_path(@team.course)) }
!!           format.xml { head :ok }
           else
!!           @faculty = @course.faculty
!!           format.html { render :action => "edit" }
!!           format.xml { render :xml => @team.errors, :status => :unprocessable_entity }
           end
         end
       end
     end
   
     # DELETE /courses/1/teams/1
     # DELETE /courses/1/teams/1.xml
     def destroy
!!     if !current_user.is_admin?
!!       flash[:error] = I18n.t(:no_permission)
!!       redirect_to(teams_url) and return
       end
   
!!     @team = Team.find(params[:id])
!!     course = @team.course
!!     @team.destroy
   
!!     respond_to do |format|
!!       format.html { redirect_to(course_teams_path(course)) }
!!       format.xml { head :ok }
       end
     end
   
     # GET /courses/1/teams/1/peer_evaluation
     def peer_evaluation
!!     @course = Course.find(params[:course_id])
!!     @team = Team.find(params[:id])
   
!!     @emails = []
!!     @first_names = []
!!     @full_names = []
!!     @ids = []
!!     @team.members.each do |user|
!!       @emails << user.email
!!       @first_names << user.first_name
!!       @full_names << user.human_name
!!       @ids << user.id
       end
   
!!     if (@team.peer_evaluation_first_email.nil?)
!!       @team.peer_evaluation_first_email = Date.today()
       end
!!     if (@team.peer_evaluation_second_email.nil?)
!!       @team.peer_evaluation_second_email = Date.today()
       end
   
!!     respond_to do |format|
!!       format.html # show.html.erb
!!       format.xml { render :xml => @team }
       end
     end
   
     def peer_evaluation_update
!!     @team = Team.find(params[:id])
   
!!     @team.peer_evaluation_first_email = params[:team][:peer_evaluation_first_email]
!!     @team.peer_evaluation_second_email = params[:team][:peer_evaluation_second_email]
   
!!     if @team.save
!!       flash[:notice] = 'Dates saved'
       else
!!       flash[:error] = 'Dates not saved'
       end
!!     redirect_to(peer_evaluation_path(@team.course, @team.id))
     end
   
   
     def update_course_faculty_label
!!     @course = Course.find(params[:course_id])
!!     if @course.primary_faculty_label != params[:primary_faculty_label] || @course.secondary_faculty_label != params[:seconday_faculty_label] then
!!       @course.primary_faculty_label = params[:primary_faculty_label]
!!       @course.secondary_faculty_label = params[:secondary_faculty_label]
!!       @course.save
       end
     end
   end

================================================================================
 ./app/controllers/users/omniauth_callbacks_controller.rb
================================================================================
   class Users::OmniauthCallbacksController < Devise::OmniauthCallbacksController
     include Devise::Controllers::Rememberable
   
     def failure
!!     puts "*******FAILURE*****"
!!     puts params[:message]
!!     puts "*******FAILURE*****"
!!     flash[:notice] = params[:message] # if using sinatra-flash or rack-flash
!!     redirect_to root_url
     end
   
     def google_apps
       # You need to implement the method below in your model
       @user = User.find_for_google_apps_oauth(env["omniauth.auth"].except("extra"), current_user)
   
       omniauth = env["omniauth.auth"]
       email = switch_west_to_sv(omniauth["info"]["email"])
   
       if @user
         remember_me(@user)
         flash[:notice] = I18n.t "devise.omniauth_callbacks.success", :kind => omniauth['provider'], :email => email
         sign_in_and_redirect @user, :event => :authentication
       else
!!       flash[:error] = "Sorry, no user with this email (#{email}) exists in the system. help@sv.cmu.edu was just notified of this issue."
!!       options = {:to => "help@sv.cmu.edu",
                    :from => "help@sv.cmu.edu",
                    :subject => "Login problem to on whiteboard.sv.cmu.edu for user #{email}",
                    :message => "A user tried to log into the rails application. They were authenticated by google, however, their email address does not exist as a person in the system. Either 1) the person is already in the system, but there is a typo with their email address or 2)the person needs to be added to the system. <br><br>The email address is #{email}",
                    :url_label => "",
                    :url => "",
                    :cc => "todd.sedano@sv.cmu.edu"
         }
!!       GenericMailer.email(options).deliver
!!       session["devise.google_apps_data"] = env["omniauth.auth"]
!!       redirect_to root_url
       end
   
   
       #if @user.persisted?
       #  flash[:notice] = I18n.t "devise.omniauth_callbacks.success", :kind => omniauth['provider']
       #  sign_in_and_redirect @user, :event => :authentication
       #else
       #  flash[:error] = "Sorry, no user with this email (#{email}) exists in the system. help@sv.cmu.edu was just notified of this issue."
       #
       #  session["devise.google_apps_data"] = env["omniauth.auth"]
       #  redirect_to root_url
       #end
       #      User.create(:email => data["email"], :first_name => data["first_name"], :last_name => data["last_name"], :human_name => "name")
       #      options = {:to => "help@sv.cmu.edu",
       #                 :subject => "Login problem to on whiteboard.sv.cmu.edu for user #{email}",
       #                 :message => "A user tried to log into the rails application. They were authenticated by google, however, their email address does not exist as a person in the system. Either 1) the person is already in the system, but there is a typo with their email address or 2)the person needs to be added to the system. <br><br>The email address is #{email}",
       #                 :url_label => "",
       #                 :url => "",
       #                 :cc => "todd.sedano@sv.cmu.edu"
       #      }
       #      GenericMailer.email(options).deliver
       #      failed_login "Sorry, no user with this email (#{email}) exists in the system. help@sv.cmu.edu was just notified of this issue."    if @user.persisted?
       #      flash[:notice] = I18n.t "devise.omniauth_callbacks.success", :kind => "Facebook"
       #      sign_in_and_redirect @user, :event => :authentication
       #    else
       #      session["devise.facebook_data"] = env["omniauth.auth"]
       #      redirect_to new_user_registration_url
       #    end
   
     end
   
     def passthru
!!     render :file => "#{Rails.root}/public/404.html", :status => 404, :layout => false
     end
   end

================================================================================
 ./app/controllers/welcome_controller.rb
================================================================================
   class WelcomeController < ApplicationController
     layout 'cmu_sv'
   
     def index
       @rss_feeds = RssFeed.all
   
       if (current_person.nil?)
         @registered_for_these_courses_during_current_semester = []
         @teaching_these_courses_during_current_semester = []
       else
!!       @registered_for_these_courses_during_current_semester = current_person.registered_for_these_courses_during_current_semester
!!       @teaching_these_courses_during_current_semester = current_person.teaching_these_courses_during_current_semester
       end
   
       respond_to do |format|
         format.html # index.html.erb
         format.xml { render :xml => @courses }
       end
     end
   
     def new_features
     end
   
     def configuration
   
     end
   
   end

================================================================================
 ./app/helpers/application_helper.rb
================================================================================
   module ApplicationHelper
   
   
     def sanitize_trusted(html)
       return sanitize html, :tags => %w(a b blockquote br div em h1 h2 h3 h4 hr i img span p pre strong strike table tbody thead th tr td u ul ol li), :attributes => %w(align bgcolor border colspan cellpadding cellspacing class href id name padding rowspan scope src start style valign width)
     end
   
   
     def scotty_dog_landscape
!!     image_tag("ScottyDogLandscape.jpg", :class => "bevel", :size => "236x69")
     end
   
     def scotty_dog_portrait
!!     image_tag("ScottyDog.jpg", :class => "bevel", :size => "214x234")
     end
   
     def image_spacer(width)
!!     image_tag("/cmu_sv/spacer.gif", :border => "0", :height => "1", :width => width, :alt => "")
     end
   
     # def left_nav_current_semester_courses
     #   current_semester() + " " + Date.today.year
     # end
   
     def professor_image
!!     image_tag("professor.jpg", :size => "50x50", :border => "0", :alt => "These fields can be edited by a faculty role", :title => "Faculty role")
     end
   
     def admin_image
!!     image_tag("admin.jpg", :size => "50x50", :border => "0", :alt => "These fields can be edited by an admin role", :title => "Admin role")
     end
   
     #Do we need this, used on welcome page
     def current_semester
!!     AcademicCalendar.current_semester()
     end
   
     def format_timestamp(timestamp)
!!     return "" if timestamp.nil?
!!     content_tag(:span, "#{time_ago_in_words(timestamp)} ago", :class => 'timestamp', :title => timestamp.in_time_zone('Pacific Time (US & Canada)').strftime('%a %b %d %Y, %I:%M %p Pacific Time'))
     end
   
     def monthname(monthnumber)
       if monthnumber
         Date::MONTHNAMES[monthnumber]
       end
     end
   
     def display_timestamp(timestamp, options = {})
   
!!     return "" if timestamp.nil?
!!     content_tag(:span, "#{timestamp.in_time_zone('Pacific Time (US & Canada)').strftime('%a %b %d %Y, %I:%M %p (Pacific)')}", options)
   
     end
   
   
   end

================================================================================
 ./app/helpers/cmu_sv_layout.rb
================================================================================

================================================================================
 ./app/helpers/courses_helper.rb
================================================================================
   module CoursesHelper
     def nomenclature_assignment_or_deliverable
       @course.nil? ? "Deliverable" : @course.nomenclature_assignment_or_deliverable.capitalize
     end
   
     def grade_type_points_or_weights
!!     @course.nil? ? "Points" : @course.grade_type_points_or_weights.capitalize
     end
   end

================================================================================
 ./app/helpers/deliverables_helper.rb
================================================================================
   module DeliverablesHelper
     def display_maximum_score
!!    grading_type= GradingRule.get_grade_type(@course.id)
   
   
   
!!    case grading_type
        when "letter"
!!        val="A"
!!        return val
        when "points"
!!        return @deliverable.assignment.maximum_score
        when "weights"
!!        val= "100%"
!!        return val
        end
      end
   
   
   
   
   end

================================================================================
 ./app/helpers/effort_logs_helper.rb
================================================================================
   module EffortLogsHelper
   
     def show_week_of_year_text
!!     "Week " + @effort_log.week_number + " of " + @effort_log.year
     end
   
     def show_monday_for(cwyear, week_number)
!!     Date.commercial(cwyear, week_number, 1).strftime "%b %d, %Y" # Jul 01, 2008
     end
   
     def td_class_is_today(day_of_week)
       @today_column == day_of_week ? "<td class='today'>".html_safe : "<td>".html_safe
     end
   
   
   end

================================================================================
 ./app/helpers/jobs_helper.rb
================================================================================
   module JobsHelper
   
     def job_person_names(job_persons)
!!     names = ""
!!     job_persons.each do |person|
!!       names << "<a href='/people/#{person.twiki_name}' target='_top'>#{person.human_name}</a>, "
       end
!!     names = names[0..-3]
     end
   
     def job_title_formatted(job)
!!     if job.is_accepting
!!       job.title
       else
!!       return "<strike>#{job.title}</strike>"
       end
     end
   
     def job_titles_formatted(jobs)
!!     job_titles = ""
!!     jobs.each do |job|
!!       job_titles << "<a href='/jobs/#{job.id}/edit' target='_top'>#{job.title}</a>, "
       end
!!     job_titles = job_titles[0..-3]
     end
   
   end

================================================================================
 ./app/helpers/people_helper.rb
================================================================================
   module PeopleHelper
   
     def display_location(person)
       return nil if (person.work_city.nil? && person.work_state.nil? && person.work_country.nil?)
!!     return "#{person.work_state} #{person.work_country}" if person.work_city.nil?
!!     return "#{person.work_city}, #{person.work_state} #{person.work_country}"
     end
   
     def linked_in_path(person)
       return "http#{$2}://www.linkedin.com/in/#{$7}" if person.linked_in =~ /(http)?(s)?(:\/\/)?(www.)?(linkedin.com\/)?(.*\/)?(.*)/
!!     return "http://www.linkedin.com/in/#{person.linked_in}"
     end
     def facebook_path(person)
       return "http#{$2}://www.facebook.com/#{$7}" if person.facebook =~ /(http)?(s)?(:\/\/)?(www.)?(facebook.com\/)?(.*\/)?(.*)/
!!     return "http://www.facebook.com/#{person.facebook}"
     end
     def twitter_path(person)
       return "http#{$1}://www.twitter.com/#{$2}" if person.twitter =~ /\[http\]?(s)?:\/\/\]?\[www\.\]?twitter\.com\/(.*)\/?/
       return "http://www.twitter.com/#{person.twitter}"
     end
     def google_plus_path(person)
       return "http#{$2}://plus.google.com/#{$7}" if person.google_plus =~ /(http)?(s)?(:\/\/)?(www.)?(plus.google.com\/)?(.*\/)?(\d+)(.*)/
!!     return "http://plus.google.com/#{person.google_plus}"
     end
     def github_path(person)
       return "http#{$1}://www.github.com/#{$2}" if person.github =~ /\[http\]?(s)?:\/\/\]?\[www\.\]?github\.com\/(.*)\/?/
       return "http://www.github.com/#{person.github}"
     end
   
   end

================================================================================
 ./app/helpers/teams_helper.rb
================================================================================
   module TeamsHelper
   
   
     #Todo: This method looks similiar to one in helpers/teams_helper.rb -- if so DRY!
     def find_past_teams(person)
!!     @past_teams_as_member = Team.find_by_sql(["SELECT t.* FROM  teams t INNER JOIN team_assignments ta ON ( t.id = ta.team_id) INNER JOIN users u ON (ta.user_id = u.id) INNER JOIN courses c ON (t.course_id = c.id) WHERE u.id = ? AND (c.semester <> ? OR c.year <> ?)", person.id, AcademicCalendar.current_semester(), Date.today.year])
   
!!     teams_list = ""
!!     count = 0
!!     @past_teams_as_member.each do |team|
!!       if count == 0
!!         teams_list = team.name
         else
!!         teams_list = teams_list.concat(", " + team.name)
         end
!!       count += 1
       end
!!     return teams_list
     end
   
   end

================================================================================
 ./app/mailers/course_mailer.rb
================================================================================
   class CourseMailer < ActionMailer::Base
     default :from => "CMU-SV Official Communication <help@sv.cmu.edu>",
             :bcc => ["todd.sedano@sv.cmu.edu", "rails.app@sv.cmu.edu"]
   
   
     def configure_course_faculty_email(course, options = {})
       @course = course
   
!!     mail(:to => options[:to] || course.faculty.collect { |user| user.email },
            :subject => options[:subject] || "Please let us know about your course #{course.name} (#{course.semester} #{course.year})",
            :date => Time.now)
     end
   
     def configure_course_admin_email(course, options = {})
       @course = course
   
       mail(:to => options[:to] || "help@sv.cmu.edu",
            :subject => "Faculty has configured a course #{course.semester} #{course.year} #{course.name}",
            :date => Time.now)
     end
   
   end
   
   
   

================================================================================
 ./app/mailers/effort_log_mailer.rb
================================================================================
   class EffortLogMailer < ActionMailer::Base
   
     default :from => 'scotty.dog@sv.cmu.edu',
             :bcc => "rails.app@sv.cmu.edu"
   
     def midweek_warning(saying, user)
!!     @user = user
!!     email_with_name = @user.human_name + ' <' + @user.email + '>'
!!     attachments["ScottyDogLandscape.jpg"] = Rails.application.assets.find_asset('ScottyDogLandscape.jpg')
!!     mail(:to => @user.email, :subject => "Scotty Dog says: #{saying}", :date => Time.now)
   
     end
   
     def endweek_admin_report(course_id, course_name, faculty_emails)
!!     @course_id = course_id
!!     @course_name = course_name
   
!!     mail(:to => faculty_emails, :subject => "Effort log data updated for #{course_name}", :date => Time.now)
     end
   
   end
   
   
   

================================================================================
 ./app/mailers/generic_mailer.rb
================================================================================
   class GenericMailer < ActionMailer::Base
   
     default :from => 'scotty.dog@sv.cmu.edu',
             :bcc => "rails.app@sv.cmu.edu"
   
     def email(options = {})
       @to = options[:to]
       @message = options[:message]
       @url = options[:url]
       @url_label = options[:url_label]
   
       mail(:to => @to, :cc => options[:cc],
            :subject => options[:subject], :date => Time.now)
     end
   
   
   end

================================================================================
 ./app/mailers/job_mailer.rb
================================================================================
   class JobMailer < ActionMailer::Base
     default :from => 'CMU-SV Official Communication <help@sv.cmu.edu>',
             :bcc => ["todd.sedano@sv.cmu.edu", "todd.sedano@sv.cmu.edu", "rails.app@sv.cmu.edu"]
   
     def notify_hr(job, added_people, removed_people)
!!     message = "Action required: please update billing records<br/>"
   
!!     if added_people.present?
!!       message += "The following people were added<br/>"
!!       added_people.each do |user|
!!         message += "#{user.human_name}<br/>"
         end
       end
!!     message += "<br/>"
   
!!     if removed_people.present?
!!       message += "The following people were removed<br/>"
!!       removed_people.each do |user|
!!         message += "#{user.human_name}<br/>"
         end
       end
   
!!     if job.id.present?
!!       url_label = "View this job"
!!       url = Rails.application.routes.url_helpers.edit_job_url(job, :host => "whiteboard.sv.cmu.edu")
       else
!!       url_label = ""
!!       url = ""
       end
   
!!     options = {:to => "sylvia.arifin@sv.cmu.edu",
                  :subject => "GA Jobs - people assigned to a project changed - " + job.title,
                  :message => message,
                  :url_label => url_label,
                  :url => url,
                  :template_path => 'generic_mailer',
                  :template_name => 'email',
                  :date => Time.now
       }
!!     GenericMailer.email(options).deliver
   
     end
   
   
     def notify_added_employees(job, added_people)
!!     @job = job
!!     if added_people.present?
!!       added_people.each do |user|
!!         options = {:to => user.email,
!!                    :cc => job.supervisors.collect { |user| user.email },
                      :subject => "GA Jobs - you've been added to " + job.title,
                      :date => Time.now,
           }
!!         mail(options).deliver
         end
       end
   
     end
   
     def notify_removed_employees(job, removed_people)
!!     message = "You've been removed from the project " + job.title
   
!!     if removed_people.present?
!!       removed_people.each do |user|
!!         options = {:to => user.email,
!!                    :cc => job.supervisors.collect { |user| user.email },
                      :subject => "GA Jobs - you've been removed from " + job.title,
                      :message => message,
                      :date => Time.now,
                      :template_path => 'generic_mailer',
                      :template_name => 'email'
           }
!!         GenericMailer.email(options).deliver
         end
       end
   
     end
   
   
   end

================================================================================
 ./app/mailers/page_comment_mailer.rb
================================================================================
   class PageCommentMailer < ActionMailer::Base
     default :from => "scotty.dog@sv.cmu.edu",
             :bcc => "todd.sedano@sv.cmu.edu"
   
     def comment_update(curriculum_comment, status)
!!     @page_comment = curriculum_comment
!!     @status = status
   
       mail(:to => curriculum_comment.notify_instructors(),
            :subject => "Scotty Dog says: comment #{status} for your course",
!!          :date => Time.now)
     end
   
   end

================================================================================
 ./app/mailers/password_mailer.rb
================================================================================
   class PasswordMailer < ActionMailer::Base
     default :from => "whiteboard-noreply@#{GOOGLE_DOMAIN}"
   
     def password_reset(user)
!!     @user = user
!!     mail :to => user.personal_email, :subject => "Whiteboard Password Reset"
     end
   end

================================================================================
 ./app/mailers/person_mailer.rb
================================================================================
   class PersonMailer < ActionMailer::Base
     default :from => 'CMU-SV Official Communication <help@sv.cmu.edu>',
             :cc => 'help@sv.cmu.edu',
             :bcc => "rails.app@sv.cmu.edu",
             :subject => 'Welcome to Carnegie Mellon University Silicon Valley'
   
     def welcome_email(person, password, options = {})
!!     @person = person
!!     @password = password
   
       mail(:to => [@person.email, @person.webiso_account, @person.personal_email],
            :subject => options[:subject] || "Welcome to Carnegie Mellon University Silicon Valley (" + @person.email + ")",
!!          :date => Time.now)
     end
   
   end

================================================================================
 ./app/mailers/reminder_mailer.rb
================================================================================
   class ReminderMailer < ActionMailer::Base
     default :from => 'scotty.dog@sv.cmu.edu',
             :bcc => "rails.app@sv.cmu.edu"
   
     # Send email reminder.
     #
     # ==== Attributes
     #
     # * +options+ - Hash containing the following options:
     #
     # ==== Options
     #
     # * +:to+ - Email recipients like "user@sv.cmu.edu".
     # * +:subject+ - Subject of the email like "Friendly reminder".
     # * +:message+ - Message preceding the urls "Please update the following urls:".
     # * +:urls+ - Hash containing details about the urls to include like
     #   "{url_1 => url_label_1, url_2 => url_label_2}".
     def email(options = {})
       @to = options[:to]
       @message = options[:message]
       @urls = options[:urls]
   
       mail(:to => @to,
            :cc => options[:cc],
            :subject => options[:subject],
            :date => Time.now)
     end
   end

================================================================================
 ./app/mailers/sponsored_project_effort_mailer.rb
================================================================================
   class SponsoredProjectEffortMailer < ActionMailer::Base
     default :from => "ngoc.ho@sv.cmu.edu",
             :cc => ["ngoc.ho@sv.cmu.edu"],
             :bcc => "rails.app@sv.cmu.edu"
   
     def monthly_staff_email(user, month, year, options = {})
!!     @user = user
!!     @month = month
!!     @year = year
   
       mail(:to => options[:to] || @user.email,
            :subject => options[:subject] || "Sponsored projects confirmation email for #{Date::MONTHNAMES[month]} #{year}",
!!          :date => Time.now)
     end
   
     def changed_allocation_email_to_business_manager(user, month, year, options = {})
!!     @user = user
!!     @month = month
!!     @year = year
   
       mail(:to => options[:to] || @user.email,
            :subject => options[:subject] || "Action required: change in monthly allocations for #{@user.human_name}",
!!          :date => Time.now)
     end
   
   end

================================================================================
 ./app/models/ability.rb
================================================================================
   class Ability
     include CanCan::Ability
   
     def initialize(user)
       # Define abilities for the passed in user here. For example:
       #
       #   user ||= User.new # guest user (not logged in)
       #   if user.admin?
       #     can :manage, :all
       #   else
       #     can :read, :all
       #   end
   
       can :manage, User, :id => user.id
       can :update, PageAttachment
       can :see_student_grades, Course
   
   
       if (user.human_name == "Todd Sedano" ||user.human_name == "Chris Zeise" || user.human_name == "Gerry Panelo Elizondo")
!!       can :upload, Course
       end
   
       #  This next line is for testing purposes only when working on managing active directory from whiteboard
       if (user.human_name == "Edward Akoto" || user.human_name == "Jazz Sabian" || user.human_name == "Albert Liu" || user.human_name == "Stacy Marshall" || user.human_name == "Todd Sedano" || user.human_name == "Gerry Panelo Elizondo")
!!       can :create, User
       else
         cannot :create, User
       end
   
       if (user.is_admin? || user.human_name == "Rofaida Abdelaal" || user.human_name == "Sarah Stanek")
         can :upload_official_photo, User
         can :update, User
       else
         cannot :upload_official_photo, User
       end
   
   
       #Contracts manager
       if (user.is_admin? || user.human_name == "Ngoc Ho" || user.human_name == "Hector Rastrullo")
         can :manage, SponsoredProjectAllocation
         can :manage, SponsoredProjectEffort
         can :manage, SponsoredProjectSponsor
         can :manage, SponsoredProject
       end
   
       if (user.is_admin? || user.is_staff?)
         can :view_assignments, Job
       end
   
       if (user.human_name == "Wendy Fong" || user.human_name == "Sylvia Arifin")
!!       can :manage, Job
       end
   
       if (user.is_admin?)
         can :manage, Course
         can :manage, Job
         can :manage, User
         can :see_current_sign_in_ip, User
       else
         cannot :see_current_sign_in_ip, User
       end
   
       if  (user.is_staff?)
         can [:teach, :create, :update, :peer_evaluation, :team_formation], Course
         can :manage, Assignment
         can [:create, :see_job_details], Job
       end
       can [:teach, :update, :peer_evaluation, :team_formation], Course, :faculty => {:id => user.id} #Useful for TAs.
       can :update, Job, :supervisors => {:id => user.id}
   
   
       # The first argument to `can` is the action you are giving the user permission to do.
       # If you pass :manage it will apply to every action. Other common actions here are
       # :read, :create, :update and :destroy.
       #
       # The second argument is the resource the user can perform the action on. If you pass
       # :all it will apply to every resource. Otherwise pass a Ruby class of the resource.
       #
       # The third argument is an optional hash of conditions to further filter the objects.
       # For example, here the user can only update published articles.
       #
       #   can :update, Article, :published => true
       #
       # See the wiki for details: https://github.com/ryanb/cancan/wiki/Defining-Abilities
     end
   end

================================================================================
 ./app/models/assignment.rb
================================================================================
   # Assignment is the task/deliverable on which the professor grades for students.
   #
   # Professor can create/view/modify assignments by going to manage assignment tab in course tools, on the index page of
   # each course. He/She can also limit submission from student, can change the type of assignment and submission date if
   # required. The assignments will automatically get sorted out based on the course and the task. Student will not be able
   # to modify the assignment, only faculty can do this. The assignment could be graded by points/weights/letter, and it
   # can be modified in the Course Configuration page.
   #
   # Generally, a course has many assignments, and each assignments contains many student grades and many submitted deliverables.
   #
   # * Professor can create an assignment on course assignments index page by clicking the "New Assignment" link.
   # * Assignment can be grouped by task_number.
   # * Assignment has default scope to get ordered based on task_number and assignment_order
   # * assignment_order is auto generated by system, professor cannot directly specify the number of assignment_order. Instead, they can use drag-drop function to reorder them.
   # * task_number, due_date, name can be blank
   # * maximum_score is a required field. Professor should give a maximum score (>=0 ) for each assignment.
   # * is_team_deliverable tells the assignment is a team deliverable or individual deliverable
   # * is_submittable is designed for those assignment that don't required any submission, e.g., course participation, effort log.
   # * verify_deliverables_submitted tells whether there are any deliverable submmited for this assignment. If so, the professor could not delete this assignment.
   
   
   class Assignment < ActiveRecord::Base
     attr_accessible :name, :course_id, :maximum_score, :is_team_deliverable, :due_date, :assignment_order, :task_number, :is_submittable, :short_name
     attr_accessor :date, :hour, :minute
   
     validates :maximum_score, :presence => true, :numericality => {:greater_than_or_equal_to => 0}
     validates_presence_of :course_id
     validates_inclusion_of :is_team_deliverable, :is_submittable, :in => [true, false]
   
     belongs_to :course
     has_many :grades
     has_many :deliverables
   
     before_destroy :verify_deliverables_submitted
   
     acts_as_list :column => "assignment_order", :scope => [:course_id]
     default_scope :order => 'assignment_order ASC'
   
     def name_with_type
!!     unless self.course.grading_rule.nil?
!!       nomenclature = self.course.nomenclature_assignment_or_deliverable.capitalize
       else
!!       nomenclature = "deliverable"
       end
   
!!     if self.task_number.blank?
!!       task = ""
       else
!!       task = "Task #{self.task_number}. "
       end
   
!!     if self.is_team_deliverable?
!!       task + self.name + " (Team " + nomenclature + ")"
       else
!!       task + self.name + " (Individual " + nomenclature + ")"
       end
     end
   
     # To check whether the deliverable is submitted or not.
     def verify_deliverables_submitted
       self.deliverables.size <= 0
     end
   
     # To get the list of deliverables submitted by the student.
     def get_student_deliverable student_id
       if self.is_team_deliverable?
         team = User.find(student_id).teams.find_by_course_id(self.course_id)
         unless team.nil?
           self.deliverables.find_by_team_id(team.id)
         end
       else
         self.deliverables.find_by_creator_id(student_id)
       end
     end
   
     # To get the student grade for an assignment.
     def get_student_grade student_id
       Grade.get_grade(self.course.id, self.id, student_id)
     end
   
     def formatted_maximum_score
!!     if self.course.nil? || self.course.grading_rule.nil? || self.course.grading_rule.grade_type=="points"
!!       self.maximum_score.to_s
       else
!!       "100"
       end
     end
   
     # To get list of all the assignments for the student from the courses he has registered.
     def self.list_assignments_for_student student_id, type= :all
       student = User.find(student_id)
       courses = case type
                   when :all
                     student.registered_courses
                   when :current
                     student.registered_for_these_courses_during_current_semester
                   when :past
                     student.registered_for_these_courses_during_past_semesters
                 end
       assignments = Assignment.unscoped.find_all_by_course_id(courses.map(&:id), :order => "course_id ASC, id ASC")
     end
   
     #Re-position: change the sequence of Assignments
     def self.reposition(ids)
       update_all(["assignment_order = STRPOS(?, ','||id||',')", ",#{ids.join(',')},"], {:id => ids})
     end
   
     def set_due_date date, hour, minute
       self.date = date
       self.hour = hour
       self.minute = minute
   
       if self.date.blank?
         self.due_date = nil
         return
       end
   
       if self.hour.blank?
         self.hour = "22"
         self.minute = "0"
       end
   
       if self.minute.blank?
         self.minute = "0"
       end
   
       self.due_date = "#{self.date} #{self.hour}:#{self.minute}"
     end
   
   end

================================================================================
 ./app/models/course.rb
================================================================================
   # Course represents a course taught at CMU-SV.
   #
   # At present, there is no distinction between sections of a course. Each team can belong to a "section"
   # which is only a labeled text field.
   #
   # == Adding a Course Offering
   #
   # Sometime before a new semester starts, Gerry will create all the courses for the next semester. The HUB
   # has a deadline for updating their system with courses, once that deadline has passed, Gerry typically will
   # update the rails system. A course can be added/removed/modified after this deadline, and the information in
   # the rails system should be updated. When Gerry creates a course, its will the minimal necessary information.
   # When the course is created, certain information is copied from the previous offering of the same course, where as
   # other information must not be copied.
   #
   # The CMU-SV community typically does not refer to courses by their number, where as on the Pittsburgh campus,
   # most undergraduate courses are referred to by their number.
   #
   # The system asks for the tuple (course_number, semester, and year) to create the course and then puts the user
   # in an edit mode prompting reasonable defaults from the last time the course was offered. If nothing has changed,
   # it's easy for Gerry to create the next course. If the instructor has changed then it's easy to edit that information
   #
   #
   # == Notifying instructors
   #
   # Whenever an instructor is added to a course, they are notified about the change, asking them to review the course
   # options. We ask that one of the instructors confirm the settings, when this happens we consider that the faculty
   # has "configured" the course. (Or verified it's settings.) If this doesn't happen, the system should periodically
   # remind faculty about the change.)
   #
   # Course has grading rules. These include grading cut_offs for grade's like A,A-,B+ etc.
   
   class Course < ActiveRecord::Base
     has_many :teams
     belongs_to :course_number
     has_many :pages, :order => "position"
     has_many :assignments, :order => "assignment_order"
   
   
     #----- delete this when implementing deliverable-----#
     has_many :deliverables
   
     has_many :faculty_assignments
     has_many :faculty, :through => :faculty_assignments, :source => :user
   
     has_many :registrations
     has_many :registered_students, :through => :registrations, :source => :user
   
     has_many :presentations
   
     has_many :grades, :through => :assignments
   
     has_one :grading_rule, :dependent => :destroy
     accepts_nested_attributes_for :grading_rule
     attr_accessible :grading_rule_attributes
   
     validates_presence_of :semester, :year, :mini, :name
     validate :validate_faculty_assignments
   
     versioned
     belongs_to :updated_by, :class_name => 'User', :foreign_key => 'updated_by_user_id'
     belongs_to :configured_by, :class_name => 'User', :foreign_key => 'configured_by_user_id'
   
     #When assigning faculty to a page, the user types in a series of strings that then need to be processed
     # :faculty_assignments_override is a temporary variable that is used to do validation of the strings (to verify
     # that they are people in the system) and then to save the people in the faculty association.
     attr_accessor :faculty_assignments_override
   
     attr_accessible :course_number_id, :name, :number, :semester, :mini, :primary_faculty_label,
                     :secondary_faculty_label, :twiki_url, :remind_about_effort, :short_name, :year,
                     :peer_evaluation_first_email, :peer_evaluation_second_email,
                     :curriculum_url, :configure_course_twiki,
                     :faculty_assignments_override
   
     include PeopleInACollection
   
     def validate_faculty_assignments
       validate_members :faculty_assignments_override
     end
   
   #  def to_param
   #    display_course_name
   #  end
   
     def display_course_name
       mini_text = self.mini == "Both" ? "" : self.mini
       result = self.short_or_full_name + self.semester + mini_text + self.year.to_s
       result.gsub(" ", "")
     end
   
     def display_for_course_page
   # Consider this
   #    "#{self.number} #{self.name} (#{self.short_name}) #{self.display_semester}"
       "#{self.number} #{self.name} (#{self.short_name})"
     end
   
     def display_name
       return self.name if self.short_name.blank?
       return self.name + " (" + self.short_name + ")"
     end
   
     def short_or_full_name
       unless self.short_name.blank?
         self.short_name
       else
         self.name
       end
     end
   
     def short_or_course_number
!!     unless self.short_name.blank?
!!       self.short_name
       else
!!       self.number
       end
     end
   
     def display_semester
       mini_text = self.mini == "Both" ? "" : self.mini + " "
       return self.semester + " " + mini_text + self.year.to_s
     end
   
     #before_validation :set_updated_by_user -- this needs to be done by the controller
     before_save :strip_whitespaces, :update_email_address, :need_to_update_google_list?, :update_faculty
     after_save :update_distribution_list
   
     scope :unique_course_numbers_and_names_by_number, :select => "DISTINCT number, name", :order => 'number ASC'
     scope :unique_course_names, :select => "DISTINCT name", :order => 'name ASC'
     scope :in_current_semester_with_course_number, lambda { |number|
!!     where("number = ? and semester = ? and year = ?", number, AcademicCalendar.current_semester(), Date.today.year)
     }
     scope :with_course_name, lambda { |name|
!!     where("name = ?", name).order("id ASC")
     }
   
     def self.first_offering_for_course_name(course_name)
!!     Course.with_course_name(course_name).first
     end
   
     def self.for_semester(semester, year)
       return Course.where(:semester => semester, :year => year).order("name ASC").all
     end
   
     def self.current_semester_courses()
       return self.for_semester(AcademicCalendar.current_semester(),
                                Date.today.year)
     end
   
     def self.next_semester_courses()
!!     return self.for_semester(AcademicCalendar.next_semester(),
                                AcademicCalendar.next_semester_year())
     end
   
     def self.first_email_on_peer_evaluation_is_today
!!     Course.where(:peer_evaluation_first_email => Date.today).all
     end
   
     def self.second_email_on_peer_evaluation_is_today
!!     Course.where(:peer_evaluation_second_email => Date.today).all
     end
   
   
     def course_length
       if self.mini == "Both" then
         if semester == "Summer" then
           return 12
         elsif semester == "Fall" then
           return 15
         else
           return 16
         end
       else
!!       if semester == "Summer" then
!!         return 6
         else
!!         return 7
         end
       end
     end
   
     # Return the week number of the year for the start of a course
     def course_start
       start = AcademicCalendar.semester_start(semester, year)
   
       if semester == "Spring" then
         return self.mini == "B" ? start + 9 : start
       end
       if semester == "Summer" then
         return self.mini == "B" ? start + 6 : start
       end
       if semester == "Fall" then
         return self.mini == "B" ? start + 8 : start
       end
!!     return 0 #If the semester field isn't set
     end
   
     # Return the week number of the year for the end of a course
     def course_end
       self.course_start + self.course_length - 1
     end
   
     def sortable_value
       self.year.to_i * 100 + self.course_end
     end
   
   
     def self.remind_about_effort_course_list
       courses = Course.where(:remind_about_effort => true, :year => Date.today.cwyear, :semester => AcademicCalendar.current_semester(), :mini => "Both").all
       courses = courses + Course.where(:remind_about_effort => true, :year => Date.today.cwyear, :semester => AcademicCalendar.current_semester(), :mini => AcademicCalendar.current_mini).all
       return courses
     end
   
     def auto_generated_twiki_url
       return "http://info.sv.cmu.edu/do/view/#{self.semester}#{self.year}/#{self.short_or_full_name}/WebHome".delete(' ')
     end
   
     def auto_generated_peer_evaluation_date_start
       return Date.commercial(self.year, self.course_start + 6)
     end
   
     def auto_generated_peer_evaluation_date_end
       return Date.commercial(self.year, self.course_start + 7)
     end
   
     #When modifying validate_faculty or update_faculty, modify the same code in team.rb
     #Todo - move to a higher class or try as a mixin
     def update_faculty
       return "" if faculty_assignments_override.nil?
       self.faculty = []
   
       self.faculty_assignments_override = faculty_assignments_override.select { |name| name != nil && name.strip != "" }
       list = map_member_strings_to_users(self.faculty_assignments_override)
       raise "Error converting faculty_assignments_override to IDs!" if list.include?(nil)
       self.faculty = list
       faculty_assignments_override = nil
       self.updating_email = true
     end
   
     def copy_as_new_course
       new_course = self.dup
       new_course.is_configured = false
       new_course.configured_by = nil
       new_course.updated_by = nil
       new_course.created_at = Time.now
       new_course.updated_at = Time.now
       new_course.curriculum_url = nil if self.curriculum_url.nil? || self.curriculum_url.include?("twiki")
       new_course.faculty = self.faculty
       new_course.grading_rule = self.grading_rule.dup if self.grading_rule.present?
       self.assignments.each { |assignment| new_course.assignments << assignment.dup } if self.assignments.present?
       return new_course
     end
   
     #Find the last time this course was offered
     def self.last_offering(course_number)
       #TODO: move this sorting into the database
       offerings = Course.where(:number => course_number).all
       offerings = offerings.sort_by { |c| -c.sortable_value } # note the '-' is for desc sorting
       return offerings.first
     end
   
     def self.copy_courses_from_a_semester_to_next_year(semester, year)
       next_year = year + 1
       if Course.for_semester(semester, next_year).empty?
         Course.for_semester(semester, year).each do |last_year_course|
           puts last_year_course.id
           next_year_course = last_year_course.copy_as_new_course
           next_year_course.peer_evaluation_first_email += 1.year if next_year_course.peer_evaluation_first_email
           next_year_course.peer_evaluation_second_email += 1.year if next_year_course.peer_evaluation_second_email
           next_year_course.year = next_year
           next_year_course.save
         end
       else
         raise "There are already courses in semester #{semester} #{next_year}"
       end
     end
   
     def copy_teams_to_another_course(destination_course_id)
       #Todo: at some point, refactor teams to be an ordered list, so that we wouldn't need to reverse it here to preserve ordering.
!!     self.teams.reverse.each do |team|
!!       team.clone_to_another_course(destination_course_id)
       end
     end
   
     def current_mini?
!!     case self.mini
         when "Both"
!!         self.year == Date.today.year && self.semester == AcademicCalendar.current_semester()
         else
!!         self.year == Date.today.year && self.mini == AcademicCalendar.current_mini()
       end
     end
   
     def invalidate_distribution_list
       self.updating_email = true
     end
   
     def update_email_address
       self.email = build_email
     end
   
     def email_faculty_to_configure_course_unless_already_configured
       CourseMailer.configure_course_faculty_email(self).deliver unless self.is_configured?
     end
   
   
     def nomenclature_assignment_or_deliverable
       if self.grading_rule.nil? || self.grading_rule.is_nomenclature_deliverable?
!!       "deliverable"
       else
         "assignment"
       end
     end
   
     def grade_type_points_or_weights
!!     if self.grading_rule.nil? || self.grading_rule.grade_type=="points"
!!       "points"
       else
!!       "weights"
       end
     end
   
     def registered_students_or_on_teams
       self.registered_students | self.teams.collect { |team| team.members }.flatten
     end
   
     protected
     def strip_whitespaces
       @attributes.each do |attr, value|
         self[attr] = value.strip if value.is_a?(String)
       end
     end
   
     def build_email
       unless self.short_name.blank?
         email = "#{self.semester}-#{self.year}-#{self.short_name}".chomp.downcase.gsub(/ /, '-') + "@" + GOOGLE_DOMAIN
       else
         email = "#{self.semester}-#{self.year}-#{self.number}".chomp.downcase.gsub(/ /, '-') + "@" + GOOGLE_DOMAIN
       end
       email = email.gsub('&', 'and')
       email.sub('@west.cmu.edu', '@sv.cmu.edu')
     end
   
     def need_to_update_google_list?
       if self.email_changed?
         self.updating_email = true
       end
     end
   
     def update_distribution_list
       if self.updating_email
         recipients = self.faculty | self.registered_students_or_on_teams
         Delayed::Job.enqueue(GoogleMailingListJob.new(self.email, self.email, recipients, self.email, "Course distribution list", self.id, "courses"))
       end
     end
   
     # convenience method for an admin. destination_course_id is the first time that course was offered
     def copy_pages_to_another_course(destination_course_id, url_prefix)
!!     self.pages.each do |page|
!!       new = page.dup
!!       new.course_id = destination_course_id
!!       new.url = url_prefix + page.url
!!       new.save
       end
     end
   
     public
     def registered_students_and_students_on_teams_hash
!!     students = Hash.new
!!     self.registered_students.each do |student|
!!       students[student.human_name] = {:hub => true}
       end
!!     self.teams.each do |team|
!!       team.members.each do |user|
!!         students[user.human_name] = (students[user.human_name] || Hash.new).merge({:team => true, :team_name => team.name})
         end
       end
!!     return students
     end
   end
   

================================================================================
 ./app/models/course_number.rb
================================================================================
   class CourseNumber < ActiveRecord::Base
   
     def display_name
!!     return self.name if self.short_name.blank?
!!     return self.name + " (" + self.short_name + ")"
     end
   
   end

================================================================================
 ./app/models/delayed_system_job.rb
================================================================================
   class DelayedSystemJob < ActiveRecord::Base
     set_table_name "delayed_jobs"
   end

================================================================================
 ./app/models/deliverable.rb
================================================================================
   # Deliverable is a zip or a file that the students submit for a course
   #
   # There are two ways for a student team to upload their deliverables.
   #
   # Way 1) On the curriculum pages for each task,  under the "Submitting Your Work" tab, there is a
   # "submit your deliverable link" -- this gives the student the ability to name their deliverable, and upload a
   # single attachment (i.e. one doc, ppt, or zip file). By default a Course Number and the Assignments are  provided for
   # the student. Student needs to choose which asignment he/she is going to submit. The deliverable is individual or team
   # deliverable will be checked on the basis of the assignment he/she is submitting. If a faculty member tries to do this,
   # they won't see any courses lists since they aren't taking the course as a student.
   # Students can submit only team deliverable and one individual deliverable per task, although they can update the
   # attachment as many times as they like.
   #
   # Every member of a team can see team deliverables, only the individual can see their individual deliverable.
   #
   # Way 2) A student team can upload their deliverable by clicking on "My Deliverables" on the left hand navigation and
   # select "New" at the bottom of the page. This is a little less efficient because the student needs to select a
   # course and task number. It is a quick way for a student to see everything they have submitted for their courses.
   #
   # If a student or team accidentally uploads the wrong file, they can upload additional files. All files are
   # kept in the system, but the convention is that the faculty will only examine the last uploaded file.
   #
   # The faculty assigned to that team will receive an email whenever a student submits a deliverable. The faculty
   # can click on the email and provide either written comments in an text area or provide a file attachment back.
   # If you annotate a word document you would upload the word document.
   # If you annotate multiple files then you would attach a zip, just like the students do.
   #
   # If the faculty needs to see who has provided feedback or if they loose the email sent by the system, there is a f
   # faculty interface for examining the deliverables. It is not perfect, it was developed by the students and they
   # didn't have a strong sense of how we would use it. It currently shows all the deliverables submitted
   # for a course sorted by recent changes first. There is no way to filter by faculty member, or sort by task,
   # or sort by team, or sort by whether feedback has been provided. Control F in the browser is a life saver.
   # It does show you which deliverables have been graded. In theory, just relying on the emails should be sufficient.
   
   
   class Deliverable < ActiveRecord::Base
     belongs_to :team
     belongs_to :course
   
     belongs_to :creator, :class_name => "User"
     has_many :attachment_versions, :class_name => "DeliverableAttachment", :order => "submission_date DESC"
     delegate :is_team_deliverable, :to => :assignment, :allow_nil => true
   
   
     #-----for assignment----#
     belongs_to :assignment
   
     validates_presence_of :course, :creator, :assignment
     validate :unique_course_task_owner?
   
     has_attached_file :feedback,
                       :storage => :s3,
                       :bucket => ENV['WHITEBOARD_S3_BUCKET'],
                       :s3_credentials => {:access_key_id => ENV['WHITEBOARD_S3_KEY'],
                                           :secret_access_key => ENV['WHITEBOARD_S3_SECRET']},
                       :path => "deliverables/:course_year/:course_name/:random_hash/feedback/:id/:filename"
   
     default_scope :order => "created_at DESC"
   
     after_save :inaccurate_course_and_assignment_check
   
     def self.get_deliverables(course_id, faculty_id, options)
   
   #    sql_template = "SELECT d.id FROM deliverables d INNER JOIN teams t ON d.team_id = t.id INNER JOIN team_assignments ta ON t.id = ta.team_id INNER JOIN users u1 ON d.creator_id = u1.id INNER JOIN users u2 ON ta.user_id = u2.id"
       sql_template = "SELECT d.id FROM deliverables d LEFT JOIN teams t ON d.team_id = t.id LEFT JOIN team_assignments ta ON t.id = ta.team_id LEFT JOIN users u1 ON d.creator_id = u1.id LEFT JOIN users u2 ON ta.user_id = u2.id"
   
       where_clause_course = " WHERE d.course_id = ?"
   
       where_clause_team_deliverable = " AND d.team_id IS NOT NULL AND t.primary_faculty_id = ?"
   
       where_clause_individual_deliverable = " AND d.team_id IS NULL AND d.creator_id IN (SELECT inner_ta.user_id FROM teams inner_t, team_assignments inner_ta WHERE inner_t.id = inner_ta.team_id AND inner_t.primary_faculty_id = ?)"
   
       where_clause_search = " AND (u1.first_name ILIKE ? OR u1.last_name ILIKE ? OR u1.human_name ILIKE ? OR u1.email ILIKE ? OR u1.webiso_account ILIKE ? OR u2.first_name ILIKE ? OR u2.last_name ILIKE ? OR u2.human_name ILIKE ? OR u2.email ILIKE ? OR u2.webiso_account ILIKE ? OR t.name ILIKE ?)"
   
       queue = []
   
       # 1. Are there teams in this course? If there are, and the "filter by teams is on", filter by teams
       # 2. If there are no teams in the course, and if this deliverable is an individual deliverable,
       # show deliverables for individuals who are in the faculty's teams only.
       # 3. Otherwise, show every deliverable
   
       course_has_teams = Team.where(:course_id => course_id).any?
   
       has_search_string = !options[:search_string].nil?
       selected_my_team = (options[:is_my_team] == 1)
   
       if has_search_string
         search_string = options[:search_string]
       end
   
       if !course_has_teams
   
         if has_search_string
!!         sql = sql_template + where_clause_course + where_clause_search
!!         deliverable_ids = Deliverable.find_by_sql([sql, course_id, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string]).uniq
         else
           sql = sql_template + where_clause_course
           deliverable_ids = Deliverable.find_by_sql([sql, course_id]).uniq
         end
   
       elsif selected_my_team
   
         if has_search_string
           sql = sql_template + where_clause_course + where_clause_team_deliverable + where_clause_search
           team_deliverable_ids = Deliverable.find_by_sql([sql, course_id, faculty_id, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string]).uniq
   
           sql = sql_template + where_clause_course + where_clause_individual_deliverable + where_clause_search
           individual_deliverable_ids = Deliverable.find_by_sql([sql, course_id, faculty_id, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string]).uniq
         else
           sql = sql_template + where_clause_course + where_clause_team_deliverable
           team_deliverable_ids = Deliverable.find_by_sql([sql, course_id, faculty_id]).uniq
   
           sql = sql_template + where_clause_course + where_clause_individual_deliverable
           individual_deliverable_ids = Deliverable.find_by_sql([sql, course_id, faculty_id]).uniq
         end
   
         deliverable_ids = []
   
         team_deliverable_ids.each do |team_deliverable_id|
           deliverable_ids << team_deliverable_id
         end
   
         individual_deliverable_ids.each do |individual_deliverable_id|
           deliverable_ids << individual_deliverable_id
         end
   
       else
   
!!       if has_search_string
!!         sql = sql_template + where_clause_course + where_clause_search
!!         deliverable_ids = Deliverable.find_by_sql([sql, course_id, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string, search_string]).uniq
         else
!!         sql = sql_template + where_clause_course
!!         deliverable_ids = Deliverable.find_by_sql([sql, course_id]).uniq
         end
   
       end
   
       deliverables = []
   
       deliverable_ids.each do |deliverable_id|
         deliverables << Deliverable.find(deliverable_id)
       end
   
       return deliverables
   
     end
   
     # To get the owner of the deliverable
     def unique_course_task_owner?
       if self.is_team_deliverable?
         duplicate = Deliverable.where(:course_id => self.course_id, :assignment_id => self.assignment_id, :team_id => self.team_id).first
         type = "team"
       else
         duplicate = Deliverable.where(:course_id => self.course_id, :assignment_id => self.assignment_id, :team_id => nil, :creator_id => self.creator_id).first
         type = "individual"
       end
       if duplicate && duplicate.id != self.id
!!       errors.add(:base, "Can't create another #{type} deliverable for the same course and task. Please edit the existing one.")
       end
     end
   
     # To check if it is a team deliverable
     def is_team_deliverable?
       self.is_team_deliverable
     end
   
     # To check the current attachment for the deliverable
     def current_attachment
!!     attachment_versions.first
     end
   
     # To get the name of the person/team who has submitted the deliverable
     def owner_name
       if self.is_team_deliverable?
         team.name unless team.blank? # 1/25/2014, why is it possible for team to be blank?
       else
         creator.human_name
       end
     end
   
     def owner_name_for_filename
       if self.is_team_deliverable?
         team.name
       else
!!       "#{creator.last_name} #{creator.first_name}"
       end
     end
   
     # To get the email_id/team_id who has submitted the deliverable
     def owner_email
       if self.is_team_deliverable?
         team.email
       else
         creator.email
       end
     end
   
     def self.find_current_by_user(user)
       # Find everything where the passed in person is either the creator
       # or is on the deliverable's team
!!     current_teams = Team.find_current_by_person(user)
!!     Deliverable.find_by_user_and_teams(user, current_teams)
     end
   
     def self.find_past_by_user(user)
       # Find everything where the passed in person is either the creator
       # or is on the deliverable's team
!!     past_teams = Team.find_past_by_person(user)
!!     Deliverable.find_by_user_and_teams(user, past_teams)
     end
   
     def self.find_by_user_and_teams(user, teams)
!!     team_condition = ""
!!     if !teams.empty?
!!       team_condition = "team_id IN ("
!!       team_condition << teams.collect { |t| t.id }.join(',')
!!       team_condition << ") OR "
       end
!!     Deliverable.find(:all, :conditions => team_condition + "(team_id IS NULL AND creator_id = #{user.id})")
     end
   
     # To see if this deliverable has a feedback or not
     def has_feedback?
       !self.feedback_comment.blank? or !self.feedback_file_name.blank?
     end
   
     # To send the deliverable submitted mail to the primary and secondary faculty
     def send_deliverable_upload_email(url)
!!     mail_to = []
!!     unless self.team.nil? || self.team.primary_faculty.nil?
!!       mail_to << self.team.primary_faculty.email
       end
!!     unless self.team.nil? || self.team.secondary_faculty.nil?
!!       mail_to << self.team.secondary_faculty.email
       end
   
!!     if mail_to.empty?
!!       return
       end
   
!!     message = self.owner_name + " has submitted a deliverable for "
!!     if !self.assignment.task_number.nil? and self.assignment.task_number != "" and !self.assignment.name.nil? and self.assignment.name !=""
!!       message += "#{self.assignment.name} (#{self.assignment.task_number}) of "
       end
!!     message += self.course.name
   
!!     options = {:to => mail_to,
                  :subject => "Deliverable submitted for " + self.course.name + " by " + self.owner_name,
                  :message => message,
                  :url_label => "View this deliverable",
                  :url => url
       }
!!     GenericMailer.email(options).deliver
     end
   
     # To send the feedback to the each student along with the score received respectively.
     def send_feedback_to_student(member_id, member_email, url, faculty_email=nil)
!!     feedback = "Feedback has been submitted for "
!!     if !self.assignment.task_number.nil? and self.assignment.task_number != "" and !self.assignment.name.nil? and self.assignment.name !=""
!!       feedback += "#{self.assignment.name} (#{self.assignment.task_number}) of "
       end
!!     feedback +=self.course.name
   
!!     if self.feedback_comment
!!       feedback +="\n\nFeedback Given:\n"
!!       feedback += self.feedback_comment
!!       feedback += "\n"
       end
!!     given_grade=Grade.get_grade(self.course.id, self.assignment_id, member_id)
!!     unless  given_grade.nil?
!!       feedback += "\nGrade earned for this "
!!       feedback += self.course.nomenclature_assignment_or_deliverable
!!       feedback += " is: "
!!       feedback += given_grade.score.to_s
!!       feedback+= " / "
!!       feedback += self.assignment.formatted_maximum_score
!!       feedback += "\n"
       end
!!     options = {:to => member_email,
                  :cc => faculty_email,
                  :subject => "Feedback for " + self.course.name,
                  :message => feedback,
                  :url_label => "View this deliverable",
                  :url => url}
   
!!     GenericMailer.email(options).deliver
     end
   
     # To send the feedback in the email back to the students.
     def send_deliverable_feedback_email(url, faculty_email=nil)
!!     if self.is_team_deliverable?
!!       self.team.members.each do |member|
!!         send_feedback_to_student(member.id, member.email, url, faculty_email)
         end
       else
!!       send_feedback_to_student(self.creator_id, self.creator.email, url, faculty_email)
       end
     end
   
     # To check if the current user can change/edit the deliverable
     def editable?(current_user)
       return true if self.course.faculty.include?(current_user)
   
       if self.is_team_deliverable?
         unless self.team.is_user_on_team?(current_user)
           unless (current_user.is_staff?)||(current_user.is_admin?)
             return false
           end
         end
       end
       if !self.is_team_deliverable?
         unless current_user == self.creator
           unless (current_user.is_staff?)||(current_user.is_admin?)
             return false
           end
         end
       end
       return true
     end
   
     def update_team
       # Look up the team this user is on if it is a team deliverable
!!     Team.where(:course_id => self.course.id).each do |team|
!!       answer = team.members.include?(self.creator)
!!       self.team = team if team.members.include?(self.creator)
       end
     end
   
     # To check if the grade received for this deliverable is visible to the students or not.
     def is_visible_to_student?
       grade = Grade.get_grade(self.course.id, self.assignment.id, creator_id)
       grade.try(:is_student_visible) || false
   #    grade_status == "graded"
     end
   
     # To update the feedback and the private notes by faculty
     def update_feedback_and_notes(params)
!!     self.feedback_comment = params[:feedback_comment]
!!     self.private_note = params[:private_note]
!!     unless params[:feedback].blank?
!!       self.feedback = params[:feedback]
       end
!!     if self.has_feedback?
!!       self.feedback_updated_at = Time.now
       end
!!     self.save
     end
   
     # To update the grade received by the student
     def update_grade(params, is_student_visible, current_user_id)
!!     error_msg = []
!!     if self.assignment.is_team_deliverable?
!!       self.team.members.each do |user|
!!         score = params[:"#{user.id}"]
!!         if Grade.give_grade(self.course_id, self.assignment.id, user.id, score, is_student_visible, current_user_id)==false
!!           error_msg << "Grade given to " + user.human_name + " is invalid!"
           end
         end
       else
!!       score = params[:"#{self.creator_id}"]
!!       unless Grade.give_grade(self.course_id, self.assignment.id, self.creator_id, score, is_student_visible, current_user_id)
   
!!         error_msg << "Grade given to " + self.creator.human_name + " is invalid!"
         end
       end
!!     error_msg
     end
   
     # Todo: update this when we are no longer using old data
     def assignment_name
!!     if self.assignment.nil?
!!       self.name
       else
!!       self.assignment.name
       end
     end
   
     # Todo: update this when we are no longer using old data
     def assignment_due_date
!!     if self.assignment
!!       self.assignment.due_date
       end
     end
   
     #Todo: rename get_grade_status to grade_status
     # To get the status of the deliverable for whether it is graded or not.
     def get_grade_status
!!     if self.is_team_deliverable?
!!       return :ungraded if self.team.nil?
!!       self.team.members.each do |member|
!!         status = self.get_status_for_every_individual(member.id)
!!         if status != :graded
!!           return status
           end
         end
!!       return :graded
       else
!!       return self.get_status_for_every_individual(self.creator_id)
       end
     end
   
     #Todo: rename get_status_for_every_individual to status_for_every_individual
     # To get the status of deliverable by student for is it graded or not.
     def get_status_for_every_individual(student_id)
!!     return :unknonwn if self.assignment.nil? #(guard for old deliverables)
!!     grade = Grade.get_grade(self.course.id, self.assignment.id, student_id)
!!     if grade.nil?
!!       return :ungraded
!!     elsif !grade.is_student_visible?
!!       return :drafted
       else
!!       return :graded
       end
     end
   
   
     def inaccurate_course_and_assignment_check
       if self.assignment
         if self.assignment.course_id != self.course_id
           options = {:to => "todd.sedano@sv.cmu.edu", :subject => "inaccurate_course_and_assignment_check #{self.id}",
                      :message => "The subject says it all", :url => "", :url_label => ""}
           GenericMailer.email(options).deliver
         end
       end
     end
   
     def get_graded_by
       if self.is_team_deliverable?
         return self.last_graded_by_for_every_individual(self.team.members[0].id)
       else
         return self.last_graded_by_for_every_individual(self.creator_id)
       end
     end
   
     def last_graded_by_for_every_individual(student_id)
       return :unknonwn if self.assignment.nil? #(guard for old deliverables)
       grade = Grade.get_grade(self.course.id, self.assignment.id, student_id)
       if grade.nil?
         return nil
       else
         return User.find_by_id(grade.last_graded_by) unless grade.last_graded_by.nil?
       end
     end
   
   end

================================================================================
 ./app/models/deliverable_attachment.rb
================================================================================
   class DeliverableAttachment < ActiveRecord::Base
     set_table_name "deliverable_attachment_versions"
   
     belongs_to :submitter, :class_name => "User", :foreign_key => "submitter_id"
     belongs_to :deliverable
   
     has_attached_file :attachment,
                       :storage => :s3,
                       :bucket => ENV['WHITEBOARD_S3_BUCKET'],
                       :s3_credentials => {:access_key_id => ENV['WHITEBOARD_S3_KEY'],
                                           :secret_access_key => ENV['WHITEBOARD_S3_SECRET']},
                       :path => "deliverables/:deliverable_course_year/:deliverable_course_semester/:deliverable_course_name/:deliverable_assignment_name/:deliverable_owner_name/:deliverable_random_hash/:id/:deliverable_owner_name_:filename"
   
   
     before_create :store_filename
   
     validates_presence_of :submitter, :submission_date
   
     before_validation(:on => :create) do
       update_submission_date
     end
   
     protected
     def update_submission_date
       self.submission_date = DateTime.now
     end
   
     def store_filename
       self.stored_filename = self.attachment.url
     end
   
   
   end

================================================================================
 ./app/models/effort_log.rb
================================================================================
   class EffortLog < ActiveRecord::Base
     has_many :effort_log_line_items, :dependent => :destroy
     belongs_to :user
   
     validates_presence_of :user
     validates_presence_of :week_number
     validates_presence_of :year
   
     before_save :determine_total_effort
   
     def self.find_effort_logs(current_user)
!!     where("user_id = '#{current_user.id}'").order("year DESC, week_number DESC")
     end
   
     def editable_by(current_user)
       if (current_user && current_user.is_admin?)
         return true
       end
       if (current_user && current_user.id == user_id)
         a = Date.today
         b = Date.commercial(self.year, self.week_number, 1)
         c = (Date.commercial(self.year, self.week_number, 7) + 1.day)
         if (Date.today >= Date.commercial(self.year, self.week_number, 1) && Date.today <= (Date.commercial(self.year, self.week_number, 7) + 1.day))
           return true
         end
       end
       return false
     end
   
     def validate_effort_against_registered_courses
!!     course_error_msg = ""
!!     registered_courses = self.user.registered_for_these_courses_during_current_semester()
   
!!     unregistered_courses = {}
!!     self.effort_log_line_items.each do |log_line_item|
!!       if (log_line_item.sum != 0)
!!         if (log_line_item.course.nil?)
!!           unregistered_courses["No course selected"] = 1
!!         elsif (!registered_courses.include?(log_line_item.course))
!!           unregistered_courses[log_line_item.course.name] = 1
           end
         end
       end
!!     course_error_msg = unregistered_courses.keys.join("<br/>") unless unregistered_courses.empty?
!!     return course_error_msg
     end
   
     def self.users_with_effort_against_unregistered_courses
       cweek = Date.today.cweek
       cyear = Date.today.cwyear
   
       sql_effort_logs_this_week = "SELECT e.* FROM effort_logs e,users u where e.week_number=#{cweek} and e.year=#{cyear} and u.id=e.user_id and u.is_student IS TRUE"
   
       effort_logs_this_week = EffortLog.find_by_sql(sql_effort_logs_this_week)
       @error_effort_logs_users = {}
   
       effort_logs_this_week.each do |effort_log|
         courses_in_error = effort_log.validate_effort_against_registered_courses()
         if (courses_in_error!="")
           @error_effort_logs_users[effort_log.user] = courses_in_error
         end
       end
       @error_effort_logs_users
     end
   
   
     def determine_total_effort
       self.sum = 0
       self.effort_log_line_items.each do |line|
         line.determine_total_effort
         self.sum = self.sum + line.sum
       end
     end
   
   
     def new_effort_log_line_item_attributes=(line_item_attributes)
!!     line_item_attributes.each do |attributes|
!!       effort_log_line_items.build(attributes)
       end
     end
   
     after_update :save_effort_log_line_items
     validates_associated :effort_log_line_items
   
     def existing_effort_log_line_item_attributes=(effort_log_line_item_attributes)
!!     effort_log_line_items.reject(&:new_record?).each do |effort_log_line_item|
!!       attributes = effort_log_line_item_attributes[effort_log_line_item.id.to_s]
!!       if attributes
!!         effort_log_line_item.attributes = attributes
         else
!!         effort_log_line_items.delete(effort_log_line_item)
         end
       end
     end
   
     def save_effort_log_line_items
!!     effort_log_line_items.each do |effort_log_line_item|
!!       effort_log_line_item.save(false)
       end
     end
   
     def self.log_effort_week?(year, week_number)
       if AcademicCalendar.spring_break(year).include?(week_number)
         return false
       else
         return AcademicCalendar.week_during_semester?(year, week_number)
       end
     end
   
     def self.latest_for_user(user_id, week_number, year)
!!     EffortLog.where("user_id = ? and week_number = ? and year = ?", user_id, week_number, year).first
     end
   
   end

================================================================================
 ./app/models/effort_log_line_item.rb
================================================================================
   class EffortLogLineItem < ActiveRecord::Base
     acts_as_list :scope => :effort_log
   
     belongs_to :effort_log
     belongs_to :task_type
     belongs_to :course
   
   #    before_save :determine_total_effort #this is not necessary since it is also called by the effort_log before a save
     validates_numericality_of :day1, :day2, :day3, :day4, :day5, :day6, :day7, :greater_than_or_equal_to => 0, :allow_nil => true
   
     def determine_total_effort
       self.sum = 0
       self.sum = self.sum + self.day1 if !self.day1.nil?
       self.sum = self.sum + self.day2 if !self.day2.nil?
       self.sum = self.sum + self.day3 if !self.day3.nil?
       self.sum = self.sum + self.day4 if !self.day4.nil?
       self.sum = self.sum + self.day5 if !self.day5.nil?
       self.sum = self.sum + self.day6 if !self.day6.nil?
       self.sum = self.sum + self.day7 if !self.day7.nil?
     end
   end

================================================================================
 ./app/models/faculty_assignment.rb
================================================================================
   class FacultyAssignment < ActiveRecord::Base
     belongs_to :user
     belongs_to :course
   
   #  set_table_name "courses_people"
   #  set_table_name "faculty_assignments"
   
   
   end

================================================================================
 ./app/models/grade.rb
================================================================================
   # Grade represents a grade given by the course instructor.
   #
   # Grade allows the professor to grade students. Professor can go to Grade by clicking Grade tab in faculty
   # tools, on the index page of each course. Professor can assign/view/change the score of the student directly
   # by putting the score for the assignment in front of his/her name. Also, only one grade is permitted for one student
   # per assignment. The design of grade is to encapusulate the grading from the submission.
   #
   # * For a course, a student will have at most one grade on each assignment.
   # * is_student_visible indicates that whether this grade is going to publish to student or not. 
   # * score would be in two forms. If the grading rule is set to use points, the score should be a number greater than
   #   zero, and we don't validate whether the score is greater than maximum number defined in Assignment object, so that
   #   professor can add extra credit on student's grade. If the grading rule is set to use letter grades, score would be
   #   A, A-, B+, B, B-, C+, C, or C-.
   # * score= assigns a number greater than zero, and we don't validate whether the score is greater than maximum
   #   number defined in Assignment object, so that professor can add extra credit on student's grade.
   
   require 'spreadsheet'
   
   class Grade < ActiveRecord::Base
     attr_accessible :course_id, :student_id, :assignment_id, :is_student_visible, :score
     belongs_to :course
     belongs_to :student, :class_name => "User"
     belongs_to :assignment
     validates :course_id, :student_id, :assignment_id, :presence => true
     validates :score, :uniqueness => {:scope => [:course_id, :assignment_id, :student_id]}, :allow_nil => true, :allow_blank => true
   
     before_save :format_score
     after_find :decrypt_score
   
     FIRST_GRADE_ROW = 2
     FIRST_GRADE_COL = 4
   
     # To format and encrypt the score in correct format before saving into the database.
     def format_score
       self.score = GradingRule.format_score(self.course.id, self.score)
       if self.assignment_id < 0
         self.score = Grade.encrypt_score(self.score, self.course_id, self.student_id)
       end
     end
   
     # To decrpyt the score if it is a final grade.
     def decrypt_score
       if self.assignment_id < 0
         self.score = Grade.decrypt_score(self.score, self.course_id, self.student_id)
       end
     end
   
     # To fetch the grade of student.
     def self.get_grades_for_student_per_course (course, student)
       grades = {}
       Grade.where(course_id: course.id).where(student_id: student.id).each do |grade|
         if grade.assignment_id < 0
!!         grade.score = Grade.decrypt_score(grade.score, grade.course_id, grade.student_id)
!!         grades["final"] = grade
         else
           grades[grade.assignment.id] = grade
         end
       end
       grades
     end
   
     # To fetch the entry with matching course, assignment and student.
     def self.get_grade(course_id, assignment_id, student_id)
       grade = Grade.where(course_id: course_id).where(student_id: student_id).where(:assignment_id => assignment_id).first
     end
   
     # To get the final grade of the student for a particular course.
     def self.get_final_grade(course_id, student_id)
       grade = Grade.where(course_id: course_id).where(student_id: student_id).where(:assignment_id => -1).first
       
       
       
       Grade.decrypt_score(grade.score, grade.course_id, grade.student_id)
       
     end
   
     # To returns a specific grade for one assignment of given course_id, student_id and assignment_id. This function is
     #   useful for controller to test whether the score is exists or not.
     def self.give_grade(course_id, assignment_id, student_id, score, is_student_visible = nil, last_graded_by = nil)
       if assignment_id > 0
         if Assignment.find(assignment_id).nil?
!!         return false
         end
       end
   
       grading_result = false
       student = User.find(student_id)
       course = Course.find(course_id)
       if course.registered_students_or_on_teams.include?(student)
         grade = Grade.get_grade(course_id, assignment_id, student_id)
         if grade.nil?
           grade = Grade.new({:course_id => course_id, :assignment_id => assignment_id, :student_id => student_id,
                              :score => score, :is_student_visible => is_student_visible, :last_graded_by => last_graded_by})
         end
   
         if course.grading_rule.validate_score(score)
           grade.score = score.upcase
           unless is_student_visible.nil?
             grade.is_student_visible = is_student_visible
           end
           unless last_graded_by.nil?
             if grade.last_graded_by.nil?
               grade.last_graded_by = last_graded_by
             end
           end
           grading_result = grade.save
         else
!!         grading_result = false
         end
       end
       grading_result
     end
   
     # To assign grades for to multiple students.
     def self.give_grades(grades, last_graded_by = nil)
       grades.each do |grade_entry|
         # FIXME: error handling for update failure
         self.give_grade(grade_entry[:course_id], grade_entry[:assignment_id], grade_entry[:student_id], grade_entry[:score], grade_entry[:is_student_visible], last_graded_by)
       end
     end
   
     # To notify students about the grade that were drafted by professor till now.
     def self.mail_drafted_grade(course_id, hostname, faculty_email=nil)
!!     draft_grades = Grade.find_all_by_is_student_visible_and_course_id(false, course_id)
!!     draft_grades.each do |grade|
!!       grade.is_student_visible = true
         
!!       unless (grade.score.blank?)
!!         grade.send_feedback_to_student(hostname, faculty_email)
         end
       end
     end
   
     # To send the final grade mail to students
     def self.mail_final_grade(course_id, hostname, faculty_email=nil)
!!     final_grades = Grade.find_all_by_course_id_and_assignment_id(course_id, -1)
!!     final_grades.each do |grade|
!!       if (grade.score.blank?)
!!         grade.is_student_visible = true
!!         grade.save
!!         grade.send_feedback_to_student(hostname, faculty_email)
         end
       end
     end
   
     # To import the grades into the gradebook from spreadsheet.
     def self.import_grade_book_from_spreadsheet(file_path, current_course_id)
!!     Spreadsheet.client_encoding = 'UTF-8'
!!     grade_book = Spreadsheet.open(file_path)
!!     grade_sheet = grade_book.worksheet(0)
!!     if validate_sheet(grade_sheet, current_course_id)
!!       import_scores(grade_sheet)
!!       return true
       else
!!       return false
       end
     end
   
     # To export the grades in spreadheet for offline grading.
     def self.export_grade_book_to_spreadsheet(course, file_path)
!!     Spreadsheet.client_encoding = 'UTF-8'
!!     grade_book = Spreadsheet::Workbook.new
!!     grade_sheet = grade_book.create_worksheet
!!     grade_sheet.name = "#{course.short_name}"
   
       # print course id and assignment id
!!     grade_sheet[0, 0] = course.id
!!     course.assignments.each_with_index do |assignment, i|
!!       grade_sheet[0, FIRST_GRADE_COL+i] = assignment.id
       end
!!     assignment_count = course.assignments.count
!!     grade_sheet[0, FIRST_GRADE_COL+assignment_count] = -1
!!     grade_sheet.row(0).hidden = true
   
       # print details
!!     grade_sheet[1, 1] = "First Name"
!!     grade_sheet[1, 2] = "Last Name"
!!     grade_sheet[1, 3] = "Team Name"
   
!!     grade_sheet.column(0).hidden=true
!!     course.assignments.each_with_index do |assignment, j|
!!       grade_sheet[1, FIRST_GRADE_COL+j] = assignment.name
       end
!!     grade_sheet[1, FIRST_GRADE_COL+assignment_count] = "Final Grade"
   
       # print students' names and grades
!!     students = course.registered_students_or_on_teams.sort do |x, y|
!!       r = (self.find_student_team(course.id, x.id).try(:name) || "")<=> (self.find_student_team(course.id, y.id).try(:name) || "")
!!       r = x.first_name <=> y.first_name if r == 0
!!       r = x.last_name <=> y.last_name if r == 0
!!       r
       end
!!     students.each_with_index do |student, i|
!!       grade_sheet[FIRST_GRADE_ROW+i, 0] = student.id
!!       grade_sheet[FIRST_GRADE_ROW+i, 1] = student.first_name
!!       grade_sheet[FIRST_GRADE_ROW+i, 2] = student.last_name
!!       grade_sheet[FIRST_GRADE_ROW+i, 3] = self.find_student_team(course.id, student.id).try(:name)
!!       course.assignments.each_with_index do |assignment, j|
!!         score=Grade.get_grade(course.id, assignment.id, student.id).try(:score) || ""
!!         if !course.grading_rule.validate_letter_grade(score)
!!           unless score.blank?
!!             score=score.to_f
             end
   
           end
!!         grade_sheet[FIRST_GRADE_ROW+i, FIRST_GRADE_COL+j] = score
         end
!!       grade_sheet[FIRST_GRADE_ROW+i, FIRST_GRADE_COL+assignment_count] = Grade.get_final_grade(course.id, student.id)
       end
!!     grade_book.write(file_path)
     end
   
     # To make the email body for the assignment graded by professor
     def make_feedback_for_one_assignment
!!     feedback = "Grade has been submitted for "
!!     if !self.assignment.task_number.nil? and self.assignment.task_number != "" and !self.assignment.name.nil? and self.assignment.name !=""
!!       feedback += "#{self.assignment.name} (#{self.assignment.task_number}) of "
       end
!!     feedback +=self.course.name
!!     feedback += "\nGrade earned for this "
!!     feedback += self.course.nomenclature_assignment_or_deliverable
!!     feedback += " is: "
!!     feedback += self.score.to_s
!!     feedback += " / "
!!     feedback += self.assignment.formatted_maximum_score
!!     feedback += "\n"
     end
   
     # To make the email body for the final grade awarded by the professor
     def make_feedback_for_final_grade
!!     feedback = "Final grade has been assigned for "
!!     feedback += self.course.name + "\n"
     end
   
     # To send the feedback to the student.
     def send_feedback_to_student(hostname, faculty_email=nil)
!!     if assignment_id > 0
!!       feedback = make_feedback_for_one_assignment
       else
!!       feedback = make_feedback_for_final_grade
       end
!!     url = hostname + "/courses/#{self.course.id}/student_grades"
!!     options = {:to => self.student.email,
                  :cc => faculty_email,
                  :subject => "Grade for " + self.course.name,
                  :message => feedback,
                  :url_label => "Click here to view grade",
                  :url => url
       }
   
!!     GenericMailer.email(options).deliver
     end
   
     private
     # To validate the course and assignment when importing a file
     def self.validate_first_row(row, current_course_id)
!!     num_cols = row.length
!!     if num_cols < (FIRST_GRADE_COL+1)
!!       return false
       end
   
       # check course ID at sheet[0,0]
!!     course = Course.find_by_id(row[0].to_i)
!!     if course.nil? || course.id!=current_course_id
!!       return false
       end
   
       # check assignment IDs
!!     is_found_final_grade_col = false
!!     for j in (FIRST_GRADE_COL..(num_cols-1))
!!       assignment_id = row[j].to_i
!!       if assignment_id > 0
           # the assignment should be able to be found.
!!         assignment = Assignment.find_by_id(assignment_id)
!!         if assignment.nil?
!!           return false
           end
           # the assignment should belong to this course.
!!         if assignment.course.id != course.id
!!           return false
           end
         elsif assignment_id < 0
           # final grade column should not be redundant.
!!         if is_found_final_grade_col
!!           return false
           else
!!           is_found_final_grade_col = false
           end
         else
           # the format of assignment id is incorrect.
!!         return false
         end
       end
!!     return true
     end
   
   
     # To validate that the students are enlisted in the course
     def self.validate_first_column(col)
!!     num_rows = col.length
!!     if num_rows < (FIRST_GRADE_ROW+1)
!!       return false
       end
   
!!     course = Course.find_by_id(col[0].to_i)
!!     if course.nil?
!!       return false
       end
   
!!     for i in (FIRST_GRADE_ROW..(num_rows-1))
!!       student = User.find_by_id(col[i].to_i)
!!       if student.nil?
!!         return false
         end
   
!!       unless course.registered_students_or_on_teams.include?(student)
!!         return false
         end
       end
   
!!     return true
     end
   
     # To validate that course, assignments and students are valid.
     def self.validate_sheet(grade_sheet, current_course_id)
!!     (validate_first_row(grade_sheet.row(0).to_a, current_course_id) && validate_first_column(grade_sheet.column(0).to_a))
     end
   
     # To import the scores from the gradebook
     def self.import_scores (grade_sheet)
!!     course_id = grade_sheet[0, 0].to_i
!!     num_rows = grade_sheet.row_count()
!!     num_cols = grade_sheet.column_count()
!!     for i in (FIRST_GRADE_ROW..(num_rows-1))
!!       for j in (FIRST_GRADE_COL..(num_cols-1))
!!         student_id = grade_sheet[i, 0].to_i
!!         assignment_id = grade_sheet[0, j].to_i
!!         score = grade_sheet[i, j].to_s
!!         Grade.give_grade(course_id, assignment_id, student_id, score, true)
         end
       end
     end
   
     # To find the team to which the student is assigned
     def self.find_student_team(course_id, student_id)
!!     User.find(student_id).teams.find_by_course_id(course_id)
     end
   
     # To encrypt the final scores.
     def self.encrypt_score(raw_score, course_id, student_id)
       # FIXME: get salt from somewhere else
       if raw_score.blank?
!!       return raw_score
       else
         return Digest::SHA2.hexdigest(salt+raw_score+course_id.to_s+student_id.to_s)
       end
     end
   
     # To decrypt the score for showing it to the professor.
     def self.decrypt_score(encrypted_score, course_id, student_id)
       if encrypted_score.blank?
!!       return ""
       end
   
       grading_rule = GradingRule.find_by_course_id(course_id)
       if grading_rule.nil?
!!       return ""
       end
   
       grading_rule.letter_grades.each do |letter|
         return letter if encrypted_score == encrypt_score(letter, course_id, student_id)
       end
       return encrypted_score
     end
   
     def self.salt
       ENV['WHITEBOARD_SALT'] || 'I am salt with lot of iodine'
     end
   
   end
   

================================================================================
 ./app/models/grading_rule.rb
================================================================================
   # GradingRule represents the correspondence between points earned and letter grades. The mapping rule is given by the
   # course instructor.
   #
   # GradingRule is configurable by clicking on "Configure course" in "Initial Course Configuration", both of which could
   # be found on the index page of each course. In the configuration page, professor can choose grading criteria between
   #   points and letter grades. If professor adopts letter grades, then professor needs to fill the table which maps out
   #   point and letter grades.
   #
   # GradingRule follows the grading policy of CMU@SV. We provide the following options for letter grades: A, A-, B+, B,
   #   B-, C+, C, C-. These grades can be configured by faculty by going to course configuration page. Beside these grades
   #   faculty can also enter R, W, I grades. But these grades are not configurable.
   #
   # We provide the following functions to map out points and letter grades.
   # * validate_letter_grade performs letter grade validation for the given score.
   # * validate_score performs score validation for the given score by the grade type
   # * format_score formats the given score
   # * get_grade_in_prof_format convert points to
   # * grade_type tells whether the deliverable is graded by weight or by points
   # * A_grade_min tells on or above this value the student will be marked as A-
   # * A_minus_grade_min tells on or above this value the student will be marked as A
   # * B_plus_grade_min tells on or above this value the student will be marked as B+
   # * B_grade_min tells on or above this value the student will be marked as B
   # * B_minus_grade_min tells on or above this value the student will be marked as B-
   # * C_plus_grade_min tells on or above this value the student will be marked as C+
   # * C_grade_min tells on or above this value the student will be marked as C
   # * C_minus_grade_min tells on or above this value the student will be marked as C
   # * course_id tells the course for which this grading rule exists
   # * is_nomenclature_deliverable tells which name is preferred by professor (deliverable or assignment)
   
   
   class GradingRule < ActiveRecord::Base
     attr_accessible :grade_type,
                     :A_grade_min,
                     :A_minus_grade_min,
                     :B_plus_grade_min,
                     :B_grade_min,
                     :B_minus_grade_min,
                     :C_plus_grade_min,
                     :C_grade_min,
                     :C_minus_grade_min,
                     :course_id,
                     :is_nomenclature_deliverable
   
     belongs_to :course
   
     def default_values?
!!     attribute_values = self.attributes.values
!!     attribute_values.include?(nil)
     end
   
     # To perform letter grade validation for the given score.
     def validate_letter_grade(raw_score)
       mapping_rule.has_key?(raw_score.to_s.upcase)
     end
   
     # To perform validation for the given score by the grade type
     def validate_score(raw_score)
       # allow users to skip entering grades
       if raw_score.nil? || raw_score.empty?
!!       return true
       end
   
       # allow users to enter letter grades
       if mapping_rule.has_key?(raw_score.to_s.upcase)
         return true
       end
   
       # return the grading type
       case grade_type
         when "points"
           return validate_points(raw_score)
         when "weights"
           return validate_weights(raw_score)
         else
!!         return false
       end
     end
   
     # To format the score is correct format before saving into the database.
     def self.format_score (course_id, raw_score)
       raw_score=raw_score.to_s
       grading_rule = GradingRule.find_by_course_id(course_id)
       if grading_rule.nil?
!!       return raw_score
       elsif grading_rule.grade_type=="weights" && raw_score.end_with?("%")
         return raw_score.split("%")[0]
       else
         return raw_score
       end
     end
   
     # To get the grade type of the course, i.e. it is points or weights
     def self.get_grade_type (course_id)
       grading_rule = GradingRule.find_by_course_id(course_id)
       if grading_rule.nil?
!!       return "points"
       end
   
       return grading_rule.grade_type
     end
   
     # To get the grade parameters for calculating earned grade and final grade in the javascript.
     def get_grade_params_for_javascript
!!     weight_hash = []
!!     self.course.assignments.each do |assignment|
!!       score = assignment.maximum_score
!!       if self.grade_type == "weights"
!!         score *= 0.01
         end
!!       weight_hash << score
       end
!!     "'#{GradingRule.get_grade_type self.course_id}', #{mapping_rule.to_json}, #{weight_hash.to_json}"
     end
   
     # To get all of the valid letter grades.
     def letter_grades
       @letter_grades ||= mapping_rule.keys
     end
   
     private
     # To generate the mapping rule for converting grades into points
     def mapping_rule
       @mapping_rule = {}
       prev = 100
       ["A_grade_min", "A_minus_grade_min", "B_plus_grade_min", "B_grade_min", "B_minus_grade_min", "C_plus_grade_min", "C_grade_min", "C_minus_grade_min"].each do |attr_name|
         key = attr_name.gsub("_grade_min", "").gsub("_minus", "-").gsub("_plus", "+")
         @mapping_rule[key] = prev if attr_name =="A_grade_min"
         attr = self.read_attribute(attr_name)
         unless attr.nil?
           @mapping_rule[key] = prev
           prev = attr - 0.1 unless attr.nil?
         end
         ["R", "W", "I"].each do |attr|
           @mapping_rule[attr] = 0
         end
       end
       @mapping_rule
     end
   
     # To validate that the points given by faculty are correct
     def validate_points(raw_score)
       if raw_score.to_i<0
!!       return false
       end
       true if Float(raw_score) rescue false
     end
   
     # To validate that the score is a valid weight.
     def validate_weights(raw_score)
       if raw_score.end_with?("%")
         raw_score = raw_score.split('%')[0]
       end
       validate_points(raw_score)
     end
   
   end

================================================================================
 ./app/models/job.rb
================================================================================
   class Job < ActiveRecord::Base
   
     validates :title, :presence => true
   
     before_save :update_supervisors_and_employees
     validate :validate_supervisors_and_employees
   
     has_many :job_supervisors
     has_many :supervisors, :through => :job_supervisors, :source => :user
   
     has_many :job_employees
     has_many :employees, :through => :job_employees, :source => :user
   
     belongs_to :sponsored_project
   
     default_scope order("is_accepting DESC, updated_at DESC")
   
     scope :active, where('is_closed IS NULL OR is_closed != ?', true)
   
     scope :part_time_class_of, lambda { |program, year|
!!     where("is_part_time is TRUE and masters_program = ? and graduation_year = ?", program, year.to_s).order("human_name ASC")
     }
   
     #When assigning faculty to a job, the user types in a series of strings that then need to be processed
     # :job_supervisors_override is a temporary variable that is used to do validation of the strings (to verify
     # that they are people in the system) and then to save the people in the job_supervisors association.
     attr_accessor :supervisors_override
     attr_accessor :employees_override
   
     attr_accessible :title, :description, :skills_must_haves, :skills_nice_haves,
                     :duration, :sponsored_project_id, :funding_description, :is_accepting,
                     :is_closed, :created_at,
                     :supervisors_override,
                     :employees_override
   
     include PeopleInACollection
   
     def validate_supervisors_and_employees
       validate_members :supervisors_override
       validate_members :employees_override
     end
   
     def update_supervisors_and_employees
       update_collection_members :supervisors_override, :supervisors, :update_log
       update_collection_members :employees_override, :employees, :notify_people
     end
   
     def notify_people added_users, removed_users
!!     update_log(added_users, removed_users)
!!     JobMailer.notify_hr(self, added_users, removed_users)
!!     JobMailer.notify_added_employees(self, added_users)
!!     JobMailer.notify_removed_employees(self, removed_users)
     end
   
     def update_log added_users, removed_users
!!     self.log = "" if self.log.nil?
!!     if added_users.present?
!!       added_users.each { |user| self.log += Time.now.to_s + " - added " + user.human_name + "<br/>" }
       end
!!     if removed_users.present?
!!       removed_users.each { |user| self.log += Time.now.to_s + " - removed " + user.human_name + "<br/>" }
       end
     end
   
     protected
   
     def self.all_employees
!!     active_ga_ids = User.where(:is_active => true).
           where(:is_ga_promised => true).
           select(:id).
           collect(&:id)
!!     current_employee_ids = JobEmployee.select(:user_id).collect(&:user_id)
!!     all_employee_ids = active_ga_ids.push(*current_employee_ids).uniq.sort
!!     User.find(all_employee_ids, :order => :is_ga_promised)
     end
   
   end

================================================================================
 ./app/models/job_employee.rb
================================================================================
   class JobEmployee < ActiveRecord::Base
     belongs_to :job
     belongs_to :user
     delegate :human_name, :to => :user
     delegate :twiki_name, :to => :user
   end

================================================================================
 ./app/models/job_supervisor.rb
================================================================================
   class JobSupervisor < ActiveRecord::Base
     belongs_to :job
     belongs_to :user
     delegate :human_name, :to => :user
     delegate :twiki_name, :to => :user
   
     protected
     def self.get_supervisors(jobs)
!!     supervisor_ids = JobSupervisor.
           where(:job_id => jobs.collect(&:id)).
           collect(&:user_id)
!!     User.find(supervisor_ids)
     end
   
   end

================================================================================
 ./app/models/page.rb
================================================================================
   class Page < ActiveRecord::Base
     attr_accessible :course_id, :title, :position, :indentation_level, :is_task, :tab_one_contents, :tab_two_contents,
                     :tab_three_contents, :task_duration, :tab_one_email_from, :tab_one_email_subject, :tips_and_traps, :faculty_notes,
                     :url, :is_editable_by_all, :is_viewable_by_all, :viewable_by, :version_comments, :course_name
   
     versioned
   
     validates_presence_of :title
     validates_presence_of :updated_by_user_id
     validates_uniqueness_of :url, :allow_blank => true
     validates_format_of :url, :allow_blank => true, :message => "can not be a number", :with => /^.*\D+.*$/ #it can not be a number
   
     belongs_to :updated_by, :class_name => 'User', :foreign_key => 'updated_by_user_id'
     belongs_to :current_edit_by, :class_name => 'User', :foreign_key => 'current_edit_by_user_id'
   
     has_many :page_attachments, :order => "position"
     belongs_to :course
     acts_as_list :scope => :course
   
     before_validation :update_url
   
     after_save :update_search_index
     before_destroy :delete_from_search
   
     def editable?(current_user)
       return false if self.is_duplicated_page?
       return false if current_user.blank?
       return true if self.is_editable_by_all?
       return (current_user.is_staff? || current_user.is_admin?)
     end
   
     def viewable?(current_user)
       return true if self.viewable_by == "world"
       return false if current_user.blank?
       if self.viewable_by == "users"
         return current_user.present?
       else
         return (current_user.is_staff? || current_user.is_admin?)
       end
     end
   
     def to_param
       url
     end
   
   
     #Re-position: change the sequence of pages for a given course
     def self.reposition(ids)
       #if database is mysql
       #    update_all(
       #      ['position = FIND_IN_SET(id, ?)', ids.join(',')],
       #      { :id => ids }
       #    )
!!     update_all(["position = STRPOS(?, ','||id||',')", ",#{ids.join(',')},"], {:id => ids})
     end
   
     def course_name
       self.course.nil? ? nil : self.course.name
     end
   
     def course_name=(course_name)
!!     course = Course.first_offering_for_course_name(course_name)
!!     self.course = course
     end
   
   
     def task_number
       match = self.title.match /\d+/
       match.nil? ? nil : match[0]
     end
   
     def update_search_index
       if self.viewable_by == "staff"
         update_search_index_for_index(ENV['WHITEBOARD_SEARCHIFY_STAFF_INDEX'] || 'cmu_staffx')
       else
         update_search_index_for_index(ENV['WHITEBOARD_SEARCHIFY_INDEX'] || 'cmux')
       end
     end
   
     def update_search_index_for_index(index_name)
       api = IndexTank::Client.new(ENV['WHITEBOARD_SEARCHIFY_API_URL'] || '<API_URL>')
       index = api.indexes(index_name)
       options_hash = {:title => self.title, :type => "page"}
       if self.course
!!       options_hash.merge!({:title => self.title + " (" + self.course.name + ")"})
       end
   
       begin
         index.document(self.id.to_s).add(options_hash.merge!({:text => self.tab_one_contents.gsub(/<\/?[^>]*>/, ""), :url => "pages/" + self.url}))
         if self.is_task?
!!         index.document(self.id.to_s + "-tabs-1").add(options_hash.merge!({:text => self.tab_two_contents.gsub(/<\/?[^>]*>/, ""), :url => "pages/" + self.url + "?tab=tabs-2"}))
!!         index.document(self.id.to_s + "-tabs-2").add(options_hash.merge!({:text => self.tab_three_contents.gsub(/<\/?[^>]*>/, ""), :url => "pages/" + self.url + "?tab=tabs-3"}))
         end
!!     rescue Exception => e
!!       logger.error("Searchify issue: " + e.message)
       end
     end
   
     def delete_from_search
!!     api = IndexTank::Client.new(ENV['WHITEBOARD_SEARCHIFY_API_URL'] || '<API_URL>')
!!     index = api.indexes(ENV['WHITEBOARD_SEARCHIFY_INDEX'] || 'cmux')
!!     index.document(self.id.to_s).delete
     end
   
     def current_semester_course
       #This little bit of magic finds the current offering of a course. This is handy for deliverable submission
       #and team lists where the static curriculum website points to the latest offering of the course.
       unless self.course.blank? || self.course.number.blank?
!!       Course.in_current_semester_with_course_number(self.course.number).first
       else
         nil
       end
     end
   
   
     def is_someone_else_currently_editing_page(current_user)
!!     self.current_edit_by != current_user
     end
   
     def timeout_has_not_passed
!!     if self.current_edit_started_at.nil?
!!       false
       else
!!       Time.now - self.current_edit_started_at < 5.minute
       end
     end
   
     protected
     def update_url
       self.url = self.title if self.url.blank?
     end
   
   end

================================================================================
 ./app/models/page_attachment.rb
================================================================================
   #
   # Any user who can edit a {Page}[link:classes/Page.html] can also upload attachments to that page.
   # (Note: in this system a Page is the CMS pages that represent curriculum materials. A user can not
   # upload an attachment to a team or a person page through this code.)
   #
   # The attachments are stored on Amazon S3. S3 allows us to revision all documents. All old versions
   # are still stored on the filesystem even though the user can only actively access the latest one.
   #
   # When uploading a file, the user is asked for a "readable name" for the file: a label for the link
   # to the file.
   #
   # After uploading a file, the file's "readable name" can be updated or the file can be replaced.
   # If the user replaces the an existing file (e.g. 'ppm_week1.ppt') with a different file name
   # (e.g. 'ppm_week1_ts.ppt') then a warning appears. Any user who tries to access the original file
   # name will not be able to do so. Under normal workflow, this isn't a big deal. It is possible
   # for the user to create a link on the page to the old file and system will not automatically
   # update it.
   #
   # The system records who uploads and replaces the file and when this happens, and versions this information.
   #
   
   class PageAttachment < ActiveRecord::Base
     belongs_to :page
     belongs_to :user
   
     validates_presence_of :readable_name, :user_id, :page_id
   
     has_attached_file :page_attachment,
                       :storage => :s3,
                       :bucket => ENV['WHITEBOARD_S3_BUCKET'],
                       :s3_credentials => {:access_key_id => ENV['WHITEBOARD_S3_KEY'],
                                           :secret_access_key => ENV['WHITEBOARD_S3_SECRET']},
                       :path => "page_attachments/:page_id/:random_hash/:id/:filename"
   
     versioned
   
     #Re-position: change the sequence of attachments for a given page
     def self.reposition(ids)
!!     update_all(["position = STRPOS(?, ','||id||',')", ",#{ids.join(',')},"], {:id => ids})
     end
   
   end

================================================================================
 ./app/models/page_comment.rb
================================================================================
   class PageComment < ActiveRecord::Base
     belongs_to :user
     belongs_to :type, :class_name => "PageCommentType", :foreign_key => "page_comment_type_id"
     belongs_to :page
   
     validates_presence_of :comment
     validates_presence_of :user_id
   
     def editable?(current_user)
!!     if (current_user && current_user.is_admin?)
!!       return true
       end
!!     if (current_user && current_user.id == user_id)
!!       return true
       end
!!     return false
   
     end
   
     def notify_us()
   #todo add current
!!     curriculum_comments = PageComment.where(:page_id => self.page_id, :notify_me => true).all
!!     email_addresses = []
!!     curriculum_comments.each { |comment| email_addesses << comment.user.email }
!!     return email_addresses
     end
   
   end

================================================================================
 ./app/models/page_comment_type.rb
================================================================================
   class PageCommentType < ActiveRecord::Base
     validates_presence_of :name, :background_color
   end

================================================================================
 ./app/models/peer_evaluation_learning_objective.rb
================================================================================
   class PeerEvaluationLearningObjective < ActiveRecord::Base
   end

================================================================================
 ./app/models/peer_evaluation_report.rb
================================================================================
   class PeerEvaluationReport < ActiveRecord::Base
   
     def self.emailed_on(team_id)
!!     report = PeerEvaluationReport.where(:team_id => team_id).first
!!     report.email_date unless report.nil?
     end
   
   end

================================================================================
 ./app/models/peer_evaluation_review.rb
================================================================================
   # Peer Evaluations are done by student teams at the request of a faculty member.
   # Usually, the faculty member will setup the peer evaluation and will need to
   # know the following information
   # * Start date - when to email the student team about the evaluation.
   #   Teams can start before this
   # * End date - when to email the student team
   #   Teams can end after this provided the faculty hasn't created the report.
   # * Learning Ojbectives for each team member (optional)
   #
   # == Related classes
   # {Peer Evaluation Controller}[link:classes/PeerEvaluationController.html]
   #
   # {Peer Evaluation Learning Objective}[link:classes/PeerEvaluationLearningObjective.html]
   #
   # {Peer Evaluation Report}[link:classes/PeerEvaluationReport.html]
   #
   # == Assumptions
   # * The peer evaluation for a team is always ready, theoretically a team could
   #   start one on their own
   # * A team would not need to do a peer evaluation twice. If they had to,
   #   a system admin would clean out the data or alter the foreign keys to appear
   #   as if a peer evaluation had not been done for that team
   # == Security
   # * Students should not be able to see the peer evaluations for other students
   # * Any faculty can see the peer evaluation for a team
   #
   # This component was originally written by Russel Reed (Class of 2010)
   # and integrated by Todd Sedano. Student teams can provide 360 review feedback
   # when prompted by the faculty.
   class PeerEvaluationReview < ActiveRecord::Base
   
     belongs_to :team
     belongs_to :author, :class_name => "User"
     belongs_to :recipient, :class_name => "User"
   
     def self.is_completed_for?(user_id, team_id)
       !PeerEvaluationReview.where({:team_id => team_id, :author_id => user_id}).empty?
     end
   
   
   end

================================================================================
 ./app/models/people_search_default.rb
================================================================================
   # If no search parameters were provided, the most useful default contacts for that user is shown.
   # this is implemented in the people search pages
   #
   # == Related classes
   # {Person Controller}[link:classes/PeopleController.html]
   #
   class PeopleSearchDefault < ActiveRecord::Base
     belongs_to :user
     validates_presence_of :student_staff_group, :user_id
   
     def self.default_search_results(user)
       # Grab all records from the people_search_defaults table
       search_defaults = PeopleSearchDefault.all
   
       # Save "all" records for student_staff_group into results and reject from search_defaults list to move forward.
       results = search_defaults.find_all { |t| t.student_staff_group == 'All' }
       search_defaults.reject!  { |t| t.student_staff_group == 'All' }
       if(user.is_student)
   
         # Filter to only students
         search_defaults = search_defaults.find_all { |t| t.student_staff_group == 'Student' }
   
         # Save "all" records for program_group into results and reject from search_defaults list to move forward.
         search_defaults.find_all { |t| t.program_group == 'All' }.each { |x| results.push(x) }
         search_defaults.reject!  { |t| t.program_group == 'All' }
   
         # Filter to only students in same master program as user
         search_defaults = search_defaults.find_all { |t| t.program_group == user.masters_program }
   
         # Save "all" records for track_group into results and reject from search_defaults list to move forward.
         search_defaults.find_all { |t| t.track_group == 'All' }.each { |x| results.push(x) }
         search_defaults.reject!  { |t| t.track_group == 'All' }
   
         # Filter to only students in same master's track as user
         search_defaults = search_defaults.find_all { |t| t.track_group == user.masters_track || (user.masters_program == 'PhD' && t.track_group == nil) }.each { |x| results.push(x) }
   
       else
         # Filter to only staff and save
         search_defaults = search_defaults.find_all { |t| t.student_staff_group == 'Staff' }
         search_defaults.each { |x| results.push(x) }
       end
       # remove user if he would see himself and return.
       results.reject{ |t| t.user_id == user.id }
     end
   
   end

================================================================================
 ./app/models/person.rb
================================================================================
   # Person is a versioned model representing user data. As described in the README,
   # the Person model and the User model both represent the same database table.
   #
   # == Related classes
   # {Person Controller}[link:classes/PeopleController.html]
   #
   # {User}[link:classes/User.html]
   #
   class Person < User
     set_table_name "users"
   
   
   #  def to_param
   #    if twiki_name.blank?
   #      id.to_s
   #    else
   #      twiki_name
   #    end
   #  end
   
   
   end

================================================================================
 ./app/models/presentation.rb
================================================================================
   #
   # The overarching design goal of the presentation tool is to make it very easy to instantiate,
   # collect feedback, and distribute feedback to the presenters. At the beginning of a meeting,
   # if you decided you wanted to get feedback on a presentation, it should happen quickly.
   # (We've found that tools like survey monkey required too much hoop jumping to make it work quickly)
   #
   # Creating a presentation 
   # From the course tool page, any user can put a presentation into the system by clicking on
   # Presentations -> Assign new presentation. If a team is selected, then anyone on that team can see
   # feedback. If an individual is selected, then only that individual can see feedback. Faculty can
   # always see feedback for any presentation.
   #
   # Providing feedback
   # Any user can click on "Presentations" on the left navigation. The default view here is to show
   # presentations that are scheduled for today. (There is an All Presentations link on the right,
   # and students can see feedback from past presentations with "My Presentations.")
   # Then click on "Give Feedback" to provide detailed feedback.
   #
   # Receiving feedback
   # The presenter(s) are notified via email when they receive their first piece of feedback. Subsequent notifications are purposefully
   # turned off. The email contains a link for them to see their feedback. Faculty feedback is
   # separated out from student feedback. (I've noticed that students tend to be more blunt then faculty.)
   # Any presenter can also see their feedback from previous presentations by clicking on "My Presentations"
   
   
   class Presentation < ActiveRecord::Base
     belongs_to :team
     belongs_to :course
     belongs_to :user, :foreign_key => :user_id
   
     has_many :feedbacks, :class_name => 'PresentationFeedback', :foreign_key => :presentation_id
   
     validates_presence_of :name, :presentation_date
     validate :team_or_user_for_presenter?
   
     accepts_nested_attributes_for :feedbacks
   
     def team_or_user_for_presenter?
       if team_id.blank? && user_id.blank?
         errors.add(:base, "Can't create a presentation without a team or person giving it")
       end
     end
   
     def is_team_presentation?
       !self.team.blank?
     end
   
     def presenter
       if self.is_team_presentation?
         team.name
       else
         user.human_name
       end
     end
   
     def presenter?(current_user)
       current_user == self.user || current_user.teams.include?(team)
     end
   
     def has_given_feedback?(user)
       @presentation_feedbacks = PresentationFeedback.where("evaluator_id = :uid AND presentation_id = :pid",
                                                            {:uid => user.id, :pid => self.id})
   
       if @presentation_feedbacks[0] == nil
         return false
       else
         return true
       end
     end
   
     def self.find_by_presenter(current_user)
       # Find everything where the passed in person is either the assignee
       # or is on the presentation's team
       teams = Team.find_by_person(current_user)
       Presentation.find_by_user_and_teams(current_user, teams)
     end
   
     def self.find_by_user_and_teams(current_user, teams)
       team_condition = ""
       if !teams.empty?
         team_condition = "team_id IN ("
         team_condition << teams.collect { |t| t.id }.join(',')
         team_condition << ") OR "
       end
       Presentation.where(team_condition + "(team_id IS NULL AND user_id = #{current_user.id})")
     end
   
     def can_view_feedback?(user)
       if presenter?(user) || user.is_staff? || user.is_admin
         return true
       end
       return false
     end
   
     def self.find_ratings (feedbacks, questions)
   
       #code for ratings
!!     presentation_answers = []
!!     question_ratings = Hash.new
!!     ratings= []
   
!!     feedbacks.each do |f|
!!       feedback_answers = PresentationFeedbackAnswer.find(:all, :conditions => {:feedback_id => f.id})
!!       presentation_answers << feedback_answers
       end
   
!!     questions.each do |q|
!!       unless q.deleted?
!!         question_ratings[q.id] = [0, 0, 0, 0]
         end
       end
   
!!     presentation_answers.each do |a|
!!       a.each do |ans|
!!         ratings = question_ratings[ans.question_id]
!!         ratings[ans.rating-1] += 1
         end
       end
!!     return question_ratings
     end
   
     def self.find_comments (feedbacks, questions)
   
       # code for comments
   
!!     feedback_ids = []
!!     question_comments = Hash.new
   
!!     feedbacks.each do |f|
!!       feedback_ids << f.id
       end
   
!!     questions.each do |q|
!!       unless q.deleted?
   
!!         comments = " "
!!         found_answers = PresentationFeedbackAnswer.where(:feedback_id => feedback_ids, :question_id => q.id)
!!         found_answers.each do |f|
!!           unless (f.comment == "") || (f.comment.nil?)
!!             comments = comments + "*- " + f.comment
             end
           end
!!         question_comments[q.id] = comments
         end
       end
!!     return question_comments
     end
   
     def user_email
       if !self.team_id.nil?
         self.team.email
       else
         self.user.email
       end
     end
   
     def send_presentation_feedback_email(url)
   
       mail_to = self.user_email
       message = "See feedback for your presentation "
       message += self.name + " for " + self.course.name
   
       subject = ""
       subject = subject + self.course.short_name unless self.course.short_name.nil?
       subject = subject + "Feedback for presentation " + self.name
   
       options = {:to => mail_to,
                  :subject => subject,
                  :message => message,
                  :url_label => "View feedback",
                  :url => url
       }
       GenericMailer.email(options).deliver
     end
   
   end

================================================================================
 ./app/models/presentation_feedback.rb
================================================================================
   class PresentationFeedback < ActiveRecord::Base
     belongs_to :presentation
     belongs_to :evaluator, :class_name => "User"
     has_many :answers, :class_name => "PresentationFeedbackAnswer", :foreign_key => "feedback_id"
     accepts_nested_attributes_for :presentation, :answers
   end

================================================================================
 ./app/models/presentation_feedback_answer.rb
================================================================================
   class PresentationFeedbackAnswer < ActiveRecord::Base
     belongs_to :feedback, :class_name => "PresentationFeedback", :foreign_key => "feedback_id"
     belongs_to :question, :class_name => "PresentationQuestion", :foreign_key => "question_id"
   
     accepts_nested_attributes_for :feedback
     validates_presence_of :rating
   
   end

================================================================================
 ./app/models/presentation_question.rb
================================================================================
   class PresentationQuestion < ActiveRecord::Base
   
     def self.existing_questions
       where(:deleted => false)
     end
   end

================================================================================
 ./app/models/registered_course.rb
================================================================================
   class RegisteredCourse < ActiveRecord::Base
     belongs_to :person
     belongs_to :course
   end
   

================================================================================
 ./app/models/registration.rb
================================================================================
   class Registration < ActiveRecord::Base
     belongs_to :user
     belongs_to :course
   end

================================================================================
 ./app/models/rss_feed.rb
================================================================================
   class RssFeed < ActiveRecord::Base
   end

================================================================================
 ./app/models/scotty_dog_saying.rb
================================================================================
   class ScottyDogSaying < ActiveRecord::Base
     belongs_to :user, :class_name => "Person", :foreign_key => "user_id"
   
     validates_presence_of :saying, :user_id
   
     def editable?(current_user)
       if (current_user && current_user.is_admin?)
         return true
       end
       if (current_user && current_user.id == user_id)
         return true
       end
       return false
     end
   
   end

================================================================================
 ./app/models/sponsored_project.rb
================================================================================
   class SponsoredProject < ActiveRecord::Base
     validates_presence_of :name, :sponsor_id
     validates_uniqueness_of :name
     validates_inclusion_of :is_archived, :in => [true, false]
   
     scope :current, :conditions => {:is_archived => false}
     scope :archived, :conditions => {:is_archived => true}
   
     default_scope :order => "SPONSOR_ID ASC, NAME ASC"
   
     belongs_to :sponsor, :class_name => "SponsoredProjectSponsor"
   end

================================================================================
 ./app/models/sponsored_project_allocation.rb
================================================================================
   class SponsoredProjectAllocation < ActiveRecord::Base
     belongs_to :user
     belongs_to :sponsored_project
     validates_presence_of :user_id, :sponsored_project_id
     validates_numericality_of :current_allocation, :greater_than_or_equal_to => 0
     validates_inclusion_of :is_archived, :in => [true, false]
     validate :unique_user_to_project_allocation?
   
     def unique_user_to_project_allocation?
       duplicate = SponsoredProjectAllocation.find_by_user_id_and_sponsored_project_id(self.user_id, self.sponsored_project_id)
       unless duplicate.nil? || duplicate.id == self.id
         errors.add(:base, "Can't create duplicate allocation for the same person to project.")
       end
     end
   
     scope :current, :conditions => {:is_archived => false}
     scope :archived, :conditions => {:is_archived => true}
   
     default_scope :order => "user_id ASC"
   
     def self.monthly_copy_to_sponsored_project_effort
       allocations = SponsoredProjectAllocation.current
       allocations.each do |allocation|
         SponsoredProjectEffort.new_from_sponsored_project_allocation(allocation)
       end
     end
   
     def self.emails_staff_requesting_confirmation_for_allocations
       efforts = SponsoredProjectEffort.for_all_users_for_a_given_month(1.month.ago.month, 1.month.ago.year)
       efforts.each do |effort|
         user = effort.sponsored_project_allocation.user
         unless effort.confirmed || user.emailed_recently(:sponsored_project_effort)
           SponsoredProjectEffortMailer.monthly_staff_email(user, effort.month, effort.year).deliver
           user.sponsored_project_effort_last_emailed = Time.now
           user.save
         end
       end
   
     end
   end

================================================================================
 ./app/models/sponsored_project_effort.rb
================================================================================
   class SponsoredProjectEffort < ActiveRecord::Base
     belongs_to :sponsored_project_allocation
     validates_presence_of :sponsored_project_allocation_id
     validates_inclusion_of :confirmed, :in => [true, false]
     validates_numericality_of :year, :month, :current_allocation, :greater_than_or_equal_to => 0
     validates_numericality_of :actual_allocation, :greater_than_or_equal_to => 0, :allow_blank => true
     validate :unique_month_year_allocation_id?
   
     def unique_month_year_allocation_id?
       duplicate = SponsoredProjectEffort.find_by_month_and_year_and_sponsored_project_allocation_id(self.month, self.year, self.sponsored_project_allocation_id)
       unless duplicate.nil? || duplicate.id == self.id
         errors.add(:base, "Can't create duplicate effort for the same month, year, and allocation.")
       end
     end
   
     scope :for_all_users_for_a_given_month,
           lambda { |month, year| {:conditions => ["month = ? and year = ?", month, year]} }
   
     scope :month_under_inspection_for_a_given_user,
           lambda { |user_id| {:include => :sponsored_project_allocation,
                               :conditions => ["month = ? and year = ? and sponsored_project_allocations.user_id = ?", 1.month.ago.month, 1.month.ago.year, user_id]} }
   
   
     def self.new_from_sponsored_project_allocation(allocation)
   
       SponsoredProjectEffort.create(:month => 1.month.ago.month, :year => 1.month.ago.year,
                                     :sponsored_project_allocation_id => allocation.id,
                                     :current_allocation => allocation.current_allocation,
                                     :actual_allocation => allocation.current_allocation,
                                     :confirmed => false)
     end
   
     def self.emails_business_manager(an_effort_id)
       effort = SponsoredProjectEffort.find(an_effort_id)
       SponsoredProjectEffortMailer.deliver_changed_allocation_email_to_business_manager(effort.sponsored_project_allocation.user,
                                                                                         effort.month, effort.year)
     end
   
   end

================================================================================
 ./app/models/sponsored_project_sponsor.rb
================================================================================
   class SponsoredProjectSponsor < ActiveRecord::Base
   
     validates_presence_of :name
     validates_uniqueness_of :name
     validates_inclusion_of :is_archived, :in => [true, false]
   
     scope :current, :conditions => {:is_archived => false}
     scope :archived, :conditions => {:is_archived => true}
   
     default_scope :order => "NAME ASC"
   
   end

================================================================================
 ./app/models/suggestion.rb
================================================================================
   class Suggestion < ActiveRecord::Base
     belongs_to :user, :class_name => "Person", :foreign_key => "user_id"
   
     validates_presence_of :comment
   
     def editable?(current_user)
       if (current_user && current_user.is_admin?)
         return true
       end
       if (current_user && current_user.id == user_id)
         return true
       end
       return false
     end
   
   end

================================================================================
 ./app/models/task_type.rb
================================================================================
   class TaskType < ActiveRecord::Base
   
   
     def locate_appropriate_by_user_type(current_user)
!!     if current_user.is_student? && current_user.is_staff?
!!       task_types = TaskType.find(:all)
       end
!!     if current_user.is_student? && !current_user.is_staff?
!!       task_types = TaskType.find(:all, :conditions => ['is_student = ?', true])
       end
!!     if !current_user.is_student? && current_user.is_staff?
!!       task_types = TaskType.find(:all, :conditions => ['is_staff = ?', true])
       end
!!     if !current_user.is_student? && !current_user.is_staff?
!!       task_types = TaskType.find(:all)
       end
!!     return task_types
     end
   
   
   end

================================================================================
 ./app/models/team.rb
================================================================================
   class Team < ActiveRecord::Base
     belongs_to :course
     belongs_to :primary_faculty, :class_name => 'User', :foreign_key => "primary_faculty_id"
     belongs_to :secondary_faculty, :class_name => 'User', :foreign_key => "secondary_faculty_id"
   
     has_many :team_assignments
     has_many :members, :through => :team_assignments, :source => :user
   
     has_many :presentations
   
     validate :validate_team_members
     validates_presence_of :course_id, :name
     validates_uniqueness_of :email, :allow_blank => true, :message => "The team name has already be used in this semester. Pick another name"
   
     attr :team_members_list_changed, true
   
     before_validation :clean_up_data, :update_email_address
     before_save :copy_peer_evaluation_dates_from_course, :need_to_update_google_list?, :update_members
     after_save :update_mailing_list
   
     before_destroy :remove_google_group
   
     #When assigning faculty to a page, the user types in a series of strings that then need to be processed
     #:members_override is a temporary variable that is used to do validation of the strings (to verify
     # that they are people in the system) and then to save the people in the faculty association.
     attr_accessor :members_override
   
     include PeopleInACollection
   
     def validate_team_members
       validate_members :members_override
     end
   
     def clean_up_data
       self.name = self.name.strip() unless self.name.blank?
     end
   
     def copy_peer_evaluation_dates_from_course
       self.peer_evaluation_first_email = self.course.peer_evaluation_first_email if self.peer_evaluation_first_email.blank?
       self.peer_evaluation_second_email = self.course.peer_evaluation_second_email if self.peer_evaluation_second_email.blank?
     end
   
     def need_to_update_google_list?
       if self.email_changed?
         self.updating_email = true
       end
     end
   
     def update_mailing_list
       tmp = self.updating_email
       if self.updating_email
         Delayed::Job.enqueue(GoogleMailingListJob.new(self.email, self.email_was, self.members, self.name, "#{self.name} for course #{self.course.name}", self.id, "teams"))
         self.course.updating_email = true
         self.course.save
       end
     end
   
   
     def google_group
!!     self.email.split('@')[0] #strips out @sv.cmu.edu
     end
   
     def self.find_by_person(user)
       Team.find_by_sql("SELECT t.* FROM  teams t INNER JOIN team_assignments ta ON ( t.id = ta.team_id) WHERE ta.user_id = #{user.id}")
     end
   
     def self.find_current_by_person(user)
!!     current_year = Date.today.year()
!!     current_semester = AcademicCalendar.current_semester()
!!     Team.find_by_sql(["SELECT t.* FROM  teams t INNER JOIN team_assignments ta ON ( t.id = ta.team_id) INNER JOIN courses c ON (t.course_id = c.id) WHERE ta.user_id = ? AND c.semester = ? AND c.year = ?", user.id, current_semester, current_year])
     end
   
     def self.find_past_by_person(user)
!!     current_year = Date.today.year()
!!     current_semester = AcademicCalendar.current_semester()
!!     Team.find_by_sql(["SELECT t.* FROM  teams t INNER JOIN team_assignments ta ON ( t.id = ta.team_id) INNER JOIN courses c ON (t.course_id = c.id) WHERE ta.user_id = ? AND (c.semester <> ? OR c.year <> ?)", user.id, current_semester, current_year])
     end
   
   
     def update_email_address
       self.email = generate_email_name unless self.name.blank?
     end
   
   
     #When modifying validate_members or update_members, modify the same code in course.rb
     #Todo - move to a higher class or try as a mixin
     def update_members
       return "" if members_override.nil?
   
       self.members_override = members_override.select { |name| name != nil && name.strip != "" }
       #if the list has changed
       if (self.members_override.sort != self.members.collect { |person| person.human_name }.sort)
         self.updating_email = true
         list = map_member_strings_to_users(self.members_override)
         raise "Error converting members_override to IDs!" if list.include?(nil)
         self.members = list
       end
       members_override = nil
     end
   
     def show_addresses_for_mailing_list
!!     begin
!!       @members = []
!!       google_apps_connection.retrieve_all_members(self.google_group).each do |member|
!!         @members << member.member_id.sub('@west.cmu.edu', '@sv.cmu.edu')
         end
!!       return @members
!!     rescue GDataError => e
!!       return [pretty_print_google_error(e)]
       end
     end
   
     def faculty_email_addresses
!!     faculty = []
!!     unless self.primary_faculty_id.nil?
!!       from_address = User.find_by_id(self.primary_faculty_id).email
!!       faculty << from_address
       end
!!     unless self.secondary_faculty_id.nil?
         #if there is a coach listed we want the email to come from the coach
!!       from_address = User.find_by_id(self.secondary_faculty_id).email
!!       faculty << from_address
       end
!!     return faculty
     end
   
     def is_person_on_team?(person)
!!     user = User.find(person.id)
!!     self.members.include?(user)
     end
   
     def is_user_on_team?(user)
       self.members.include?(user)
     end
   
     def peer_evaluation_message_one
!!     return "Action Required: please do this peer evaluation survey\n\n by the end of " + self.course.peer_evaluation_second_email.to_date.to_formatted_s(:long)
   
     end
   
     def clone_to_another_course(destination_course_id)
!!     destination_course = Course.find(destination_course_id)
!!     clone = self.clone
!!     clone.member_ids = self.member_ids
!!     clone.course_id = destination_course_id
!!     clone.name = self.name + " - " + destination_course.short_or_course_number
!!     clone.save
     end
   
   
     protected
     def generate_email_name
       email = "#{self.course.semester}-#{self.course.year}-#{self.name}".chomp.downcase.gsub(/ /, '-') + "@" + GOOGLE_DOMAIN
       email = email.gsub('&', 'and')
       email.sub('@west.cmu.edu', '@sv.cmu.edu')
     end
   
     def remove_google_group
!!     logger.debug "trying before_destroy"
!!     google_apps_connection.delete_group(self.email)
     rescue GDataError => e
!!     logger.error "Attempting to destroy group.  errorcode = #{e.code}, input : #{e.input}, reason : #{e.reason}"
     end
   
   end

================================================================================
 ./app/models/team_assignment.rb
================================================================================
   class TeamAssignment < ActiveRecord::Base
     belongs_to :user
     belongs_to :team
   
     set_table_name "team_assignments" #One day we'll be ready for this change
   end

================================================================================
 ./app/models/user.rb
================================================================================
   class User < ActiveRecord::Base
     # Include default devise modules. Others available are:
     # :token_authenticatable, :encryptable, :confirmable, :lockable, :timeoutable and :omniauthable
     devise :omniauthable, :rememberable, :trackable, :timeoutable
     #, :database_authenticatable, :registerable,
   
     # Setup accessible (or protected) attributes for your model
     attr_accessible :adobe_created, :biography, :email, :first_name, :github, :graduation_year, :human_name, :image_uri, :is_active, :is_adobe_connect_host, :is_ga_promised, :is_alumnus, :is_part_time, :is_staff, :is_student, :last_name, :legal_first_name, :local_near_remote, :login, :masters_program, :masters_track, :msdnaa_created, :office, :office_hours, :organization_name, :personal_email, :photo_first_content_type, :photo_first_file_name, :photo_second_content_type, :photo_second_file_name, :photo_custom_content_type, :photo_custom_file_name, :pronunciation, :skype, :sponsored_project_effort_last_emailed, :telephone1, :telephone1_label, :telephone2, :telephone2_label, :telephone3, :telephone3_label, :telephone4, :telephone4_label, :tigris, :title, :twiki_name, :user_text, :webiso_account, :work_city, :work_country, :work_state, :linked_in, :facebook, :twitter, :google_plus, :people_search_first_accessed_at, :is_profile_valid, :image_uri_first, :image_uri_second, :image_uri_custom, :photo_selection
     #These attributes are not accessible , :created_at, :current_sign_in_at, :current_sign_in_ip, :effort_log_warning_email, :google_created, :is_admin, :last_sign_in_at, :last_sign_in_ip, :remember_created_at,  :sign_in_count,  :sign_in_count_old,  :twiki_created,  :updated_at,  :updated_by_user_id,  :version,  :yammer_created, :course_tools_view, :course_index_view, :expires_at
   
     #We version the user table except for some system change reasons e.g. the Scotty Dog effort log warning email caused this save to happen
     acts_as_versioned :table_name => 'user_versions', :foreign_key => :user_id, :if => Proc.new { |user| !(user.effort_log_warning_email_changed? ||
         user.sponsored_project_effort_last_emailed_changed? ||
         user.course_tools_view_changed? ||
         user.course_index_view_changed? ||
         user.google_created_changed? ||
         user.remember_token_changed? ||
         user.remember_created_at_changed? ||
         user.last_sign_in_at_changed? ||
         user.current_sign_in_at_changed? ||
         user.sign_in_count_changed? ||
         user.twiki_created?) }
   
     has_many :registrations
     has_many :registered_courses, :through => :registrations, :source => :course
   
     has_many :faculty_assignments
     has_many :teaching_these_courses, :through => :faculty_assignments, :source => :course
   
     has_many :team_assignments
     has_many :teams, :through => :team_assignments, :source => :team
   
     has_many :people_search_defaults, :dependent => :destroy
   
     has_many :grades
   
     has_many :job_employees
     has_many :jobs_as_employee, :through => :job_employees, :source => :job
     has_many :job_supervisors
     has_many :jobs_as_supervisor, :through => :job_supervisors, :source => :job
   
     belongs_to :updated_by_user, :class_name => "User"
   
     before_validation :update_webiso_account
     before_save :person_before_save,
                 :update_is_profile_valid
   
     before_create :set_new_user_token
   
     validates_uniqueness_of :webiso_account, :case_sensitive => false
     validates_uniqueness_of :email, :case_sensitive => false
   
     has_attached_file :photo_first, :storage => :s3, :styles => {:original => "", :profile => "150x200>"},
                       :bucket => ENV['WHITEBOARD_S3_BUCKET'],
                       :s3_credentials => {:access_key_id => ENV['WHITEBOARD_S3_KEY'],
                                           :secret_access_key => ENV['WHITEBOARD_S3_SECRET']},
                       :path => "people/:id/photo_first/:style/:filename"
     has_attached_file :photo_second, :storage => :s3, :styles => {:original => "", :profile => "150x200>"},
                       :bucket => ENV['WHITEBOARD_S3_BUCKET'],
                       :s3_credentials => {:access_key_id => ENV['WHITEBOARD_S3_KEY'],
                                           :secret_access_key => ENV['WHITEBOARD_S3_SECRET']},
                       :path => "people/:id/photo_second/:style/:filename"
     has_attached_file :photo_custom, :storage => :s3, :styles => {:original => "", :profile => "150x200>"},
                       :bucket => ENV['WHITEBOARD_S3_BUCKET'],
                       :s3_credentials => {:access_key_id => ENV['WHITEBOARD_S3_KEY'],
                                           :secret_access_key => ENV['WHITEBOARD_S3_SECRET']},
                       :path => "people/:id/photo_custom/:style/:filename"
   
     validates_attachment_content_type :photo_first, :content_type => ["image/jpeg", "image/png", "image/gif"], :unless => "!photo_first.file?"
     validates_attachment_content_type :photo_second, :content_type => ["image/jpeg", "image/png", "image/gif"], :unless => "!photo_second.file?"
     validates_attachment_content_type :photo_custom, :content_type => ["image/jpeg", "image/png", "image/gif"], :unless => "!photo_custom.file?"
   
     scope :staff, :conditions => {:is_staff => true, :is_active => true}, :order => 'human_name ASC'
   
     scope :part_time_class_of, lambda { |program, year|
!!     where("is_part_time is TRUE and masters_program = ? and graduation_year = ?", program, year.to_s).order("human_name ASC")
     }
     scope :full_time_class_of, lambda { |program, year|
!!     where("is_part_time is FALSE and masters_program = ? and graduation_year = ?", program, year.to_s).order("human_name ASC")
     }
   
     def self.get_all_programs
       User.select(:masters_program).map(&:masters_program).uniq.reject { |e| e.blank? }.sort
     end
   
     def self.get_all_years
       User.select(:graduation_year).map(&:graduation_year).uniq.reject { |e| e.blank? }.sort.reverse
     end
   
   
     def to_param
       if twiki_name.blank?
!!       id.to_s
       else
         twiki_name
       end
     end
   
     def self.find_by_param(param)
       if param.to_i == 0 #This is a string
!!       User.find_by_twiki_name(param)
       else #This is a number
         User.find(param)
       end
     end
   
   
     def teaching_these_courses_during_current_semester
!!     teaching_these_courses.where(:semester => AcademicCalendar.current_semester, :year => Date.today.year)
     end
   
     def registered_for_these_courses_during_current_semester
       hub_registered_courses = registered_courses.where(:semester => AcademicCalendar.current_semester, :year => Date.today.year).all
   
       sql_str = "select c.* FROM courses c,teams t
                 where t.course_id=c.id and c.year=#{Date.today.year} and c.semester='#{AcademicCalendar.current_semester()}' and t.id in
                 (SELECT ta.team_id FROM team_assignments ta, users u where u.id=ta.user_id and u.id=#{self.id})"
       courses_assigned_on_teams = Course.find_by_sql(sql_str)
   
       @registered_courses = hub_registered_courses | courses_assigned_on_teams
     end
   
     def registered_for_these_courses_during_past_semesters
       self.registered_courses - self.registered_for_these_courses_during_current_semester
     end
   
   
     def self.find_for_google_apps_oauth(access_token, signed_in_resource=nil)
       data = access_token['info']
       email = switch_west_to_sv(data["email"]).downcase
       User.find_by_email(email)
     end
   
     def self.new_with_session(params, session)
!!     super.tap do |user|
!!       if data = session["devise.google_apps_data"] && session["devise.google_apps_data"]["extra"]["user_hash"]
!!         user.email = data["email"]
         end
       end
     end
   
   
     def emailed_recently(email_type)
       case email_type
         when :effort_log
           return self.effort_log_warning_email.nil? || (self.effort_log_warning_email < 1.day.ago) ? false : true
         when :sponsored_project_effort
           return self.sponsored_project_effort_last_emailed.nil? || (self.sponsored_project_effort_last_emailed < 1.day.ago) ? false : true
       end
     end
   
     #This method contributed by Team Juran
     def faculty_teams_map(person_id = self.id)
!!     faculty_teams = Team.find_by_sql(["SELECT t.* FROM  teams t WHERE t.primary_faculty_id = ? OR t.secondary_faculty_id = ?", person_id, person_id])
   
!!     teams_map = {}
!!     teams_students_map = {}
!!     for team in faculty_teams
!!       if teams_map[team.course.year].nil?
!!         teams_map[team.course.year] = {}
!!         teams_students_map[team.course.year] = {}
         end
!!       if teams_map[team.course.year][team.course.semester.downcase].nil?
!!         teams_map[team.course.year][team.course.semester.downcase] = []
!!         teams_students_map[team.course.year][team.course.semester.downcase] = 0
         end
!!       teams_map[team.course.year][team.course.semester.downcase].push(team)
!!       teams_students_map[team.course.year][team.course.semester.downcase] += team.members.count
       end
       # teams_map is a two dimentional hash holding arrays of courses
       # teams_students_map is a two dimentional hash holding an integer count
       # of students that are part of the courses for a given semester
!!     return [teams_map, teams_students_map]
     end
   
   
     def permission_level_of(role)
       case role
         when :student
           return (self.is_student? || self.is_staff? || self.is_admin?)
         when :staff
           return (self.is_staff? || self.is_admin?)
         when :admin
           return (self.is_admin?)
         else
!!         return false
       end
     end
   
   
     def telephones
!!     phones = []
!!     phones << "#{self.telephone1_label}: #{self.telephone1}" unless (self.telephone1_label.nil? || self.telephone1_label.empty?)
!!     phones << "#{self.telephone2_label}: #{self.telephone2}" unless (self.telephone2_label.nil? || self.telephone2_label.empty?)
!!     phones << "#{self.telephone3_label}: #{self.telephone3}" unless (self.telephone3_label.nil? || self.telephone3_label.empty?)
!!     phones << "#{self.telephone4_label}: #{self.telephone4}" unless (self.telephone4_label.nil? || self.telephone4_label.empty?)
!!     return phones
     end
   
     def telephones_hash
       phones = Hash.new
       phones[self.telephone1_label] = self.telephone1 unless (self.telephone1_label.nil? || self.telephone1_label.empty?)
       phones[self.telephone2_label] = self.telephone2 unless (self.telephone2_label.nil? || self.telephone2_label.empty?)
       phones[self.telephone3_label] = self.telephone3 unless (self.telephone3_label.nil? || self.telephone3_label.empty?)
       phones[self.telephone4_label] = self.telephone4 unless (self.telephone4_label.nil? || self.telephone4_label.empty?)
       return phones
     end
   
     # The regular expression matches on twiki usernames. Ie AliceSmithJones re
     # This does not work with numbers or characters in the firstname field
     # http://rubular.com/
     def self.camelcase_twiki_regex
       /([A-Z][a-z]*)([A-Z][\w]*)/
     end
   
     def self.parse_twiki(username)
       match = username.match camelcase_twiki_regex
       if match.nil?
         return nil
       else
         return [match[1], match[2]]
       end
     end
   
     def find_teams_by_semester(year, semester)
!!     s_teams = []
!!     self.teams.each do |team|
!!       s_teams << team if team.course.year == year and team.course.semester == semester
       end
!!     return s_teams
     end
   
   
     def initialize_human_name
!!     self.human_name = self.first_name + " " + self.last_name if self.human_name.nil?
     end
   
     def update_webiso_account
       self.webiso_account = Time.now.to_f.to_s if self.webiso_account.blank?
     end
   
     #Todo: This method looks similiar to one in helpers/teams_helper.rb -- if so DRY!
     def past_teams
!!     Team.find_by_sql(["SELECT t.* FROM  teams t INNER JOIN team_assignments ta ON ( t.id = ta.team_id) INNER JOIN users u ON (ta.user_id = u.id) INNER JOIN courses c ON (t.course_id = c.id) WHERE u.id = ? AND (c.semester <> ? OR c.year <> ?)", self.id, AcademicCalendar.current_semester(), Date.today.year])
     end
   
     # Given an array of team objects [Awesome, Devils, Alpha Omega]
     # Returns "Awesome, Devils, Alpha Omega"
     def formatted_teams(array)
       array.map { |team| team.name } * ", "
     end
   
   
     #
     # Creates a Google Apps for University account for the user. For legacy reasons,
     # the accounts are with the domain west.cmu.edu even though the preferred way
     # of talking about the account is with the domain sv.cmu.edu
     #
     # Input is a password
     # If this fails, it returns an error message as a string
     #
     def create_google_email(password)
       return "Empty email address" if self.email.blank?
       logger.debug("Attempting to create google email account for " + self.email)
       (username, domain) = switch_sv_to_west(self.email).split('@')
   
       if domain != GOOGLE_DOMAIN
!!       logger.debug("Domain (" + domain + ") is not the same as the google domain (" + GOOGLE_DOMAIN)
!!       return "Domain (" + domain + ") is not the same as the google domain (" + GOOGLE_DOMAIN + ")"
       end
   
       begin
         user = google_apps_connection.create_user(username,
                                                   self.first_name,
                                                   self.last_name,
                                                   password)
       rescue GDataError => e
         #error code : 1300, invalid input : Andrew.Carngie, reason : EntityExists
!!       return pretty_print_google_error(e)
       end
       self.google_created = Time.now()
       self.save
       return(user)
     end
   
   
     #
     # Creates a twiki account for the user
     #
     # You may need to modify mechanize as seen here
     # http://github.com/eric/mechanize/commit/7fd877c60cbb3855652c390c980df1dedfaed820
     def create_twiki_account
!!     require 'mechanize'
!!     agent = Mechanize.new
!!     agent.basic_auth(TWIKI_USERNAME, TWIKI_PASSWORD)
!!     agent.get(TWIKI_URL + '/do/view/TWiki/TWikiRegistration') do |page|
!!       registration_result = page.form_with(:action => '/do/register/Main/WebHome') do |registration|
!!         registration.Twk1FirstName = self.first_name
!!         registration.Twk1LastName = self.last_name
!!         registration.Twk1WikiName = self.twiki_name
!!         registration.Twk1Email = self.email
!!         registration.Twk0Password = 'just4now'
!!         registration.Twk0Confirm = 'just4now'
!!         registration.Twk1Country = 'USA'
           #      registration.action = 'register'
           #      registration.topic = 'TWikiRegistration'
           #      registration.rx = '%BLACKLISTPLUGIN{ action=\"magic\" }%'
         end.submit
         #   #<WWW::Mechanize::Page::Link "AndrewCarnegie" "/do/view/Main/AndrewCarnegie">
!!       link = registration_result.link_with(:text => self.twiki_name)
!!       if link.nil?
           #the user probably already exists
!!         pp registration_result
!!         return false
         end
!!       self.twiki_created = Time.now()
!!       self.save
!!       return true
       end
   
   
     end
   
     def reset_twiki_password
!!     require 'mechanize'
!!     agent = Mechanize.new
!!     agent.basic_auth(TWIKI_USERNAME, TWIKI_PASSWORD)
!!     agent.get(TWIKI_URL + '/do/view/TWiki/ResetPassword') do |page|
!!       reset_result_page = page.form_with(:action => '/do/resetpasswd/Main/WebHome') do |reset_page|
!!         reset_page.LoginName = self.twiki_name
         end.submit
   
!!       return false if reset_result_page.parser.css('.patternTopic h3').text == " Password reset failed "
!!       return true if reset_result_page.link_with(:text => 'change password')
   
!!       return true
       end
     end
   
     #def create_yammer_account
     #  #See lib/yammer.rb for code that would create the user account.
     #  #We can't use the yammer API until we upgrade the service
     #
     #  #The most simple way here is to invite the user to register
     #  #Note that yammer requires https://www.yammer.com/
     #  require 'mechanize'
     #  agent = Mechanize.new
     #  agent.get('https://www.yammer.com/') do |page|
     #    result_page = page.form_with(:action => '/users') do |invite_page|
     #      invite_page['user[email]'] = self.email
     #    end.submit
     #  end
     #
     #  self.yammer_created = Time.now()
     #  self.save
     #  return true
     #end
   
   
     #   def create_adobe_connect
     #     require 'mechanize'
     #     agent = Mechanize.new
     #     agent.get(ADOBE_CONNECT_NEW_USER_URL) do |login_page|
     #       login_page.login = ADOBE_CONNECT_USERNAME
     #       login_page.password = ADOBE_CONNECT_PASSWORD
     #       reset_result_page = page.form_with(:action => '/do/resetpasswd/Main/WebHome') do |reset_page|
     #           reset_page.LoginName = self.twiki_name
     #       end.submit
     #
     #       return false if reset_result_page.parser.css('.patternTopic h3').text == " Password reset failed "
     #       return true if reset_result_page.link_with(:text => 'change password')
     #
     #       return true
     #     end
     #   end
   
   
     # attribute :github
     # If the user has not set this attribute, then ask the user to do so
     def notify_about_missing_field(attribute, message)
       if self.send(attribute).blank?
         options = {:to => self.email,
                    :subject => "Your user account needs updating",
                    :message => message,
                    :url_label => "Modify your profile",
                    :url => Rails.application.routes.url_helpers.edit_user_url(self, :host => "whiteboard.sv.cmu.edu")
         }
         GenericMailer.email(options).deliver
       end
     end
   
     def should_be_redirected?
       if self.people_search_first_accessed_at.nil?
!!       self.people_search_first_accessed_at = Time.now
!!       self.save!
       end
       #self.first_access = nil
       #self.save!
       ((Time.now - self.people_search_first_accessed_at)>4.weeks) ? true : false
       #true
       #false
     end
   
     def self.expired_users_in_the_last_month
       User.where(is_active: true).where("expires_at >= ? AND expires_at < ?", Date.today - 1.month, Date.today)
     end
   
     def self.notify_it_about_expired_accounts
       email_list = ""
       self.expired_users_in_the_last_month.each do |user|
         email_list += "-" + Rails.application.routes.url_helpers.user_url(user, :host => "whiteboard.sv.cmu.edu") + "\n"
       end
       if email_list.length > 0
         options = {:to => 'help@sv.cmu.edu',
                    :subject => "Expired accounts between #{(Date.today - 1.month).to_s} and #{(Date.today - 1.day).to_s}",
                    :message => "\n#{email_list} \n\n Please executed the processes defined for expired accounts."
         }
         GenericMailer.email(options).deliver
       end
     end
   
     def set_new_user_token
       self.new_user_token = SecureRandom.urlsafe_base64
     end
   
     def set_password_reset_token
!!     self.password_reset_token = SecureRandom.urlsafe_base64
     end
   
     protected
   
     def person_before_save
       # We populate some reasonable defaults, but this can be overridden in the database
       self.human_name = self.first_name + " " + self.last_name if self.human_name.blank?
       self.email = self.first_name.gsub(" ", "") + "." + self.last_name.gsub(" ", "") + "@sv.cmu.edu" if self.email.blank?
   
       # update the image_uri if a photo was uploaded
   
       self.image_uri_first = self.photo_first.url(:profile).split('?')[0] unless (self.photo_first.blank? || self.photo_first.url == ActionController::Base.helpers.asset_path("mascot.jpg"))
       self.image_uri_second = self.photo_second.url(:profile).split('?')[0] unless (self.photo_second.blank? || self.photo_second.url == ActionController::Base.helpers.asset_path("mascot.jpg"))
       self.image_uri_custom = self.photo_custom.url(:profile).split('?')[0] unless (self.photo_custom.blank? || self.photo_custom.url == ActionController::Base.helpers.asset_path("mascot.jpg"))
   
       case self.photo_selection
         when "first"
           self.image_uri = self.image_uri_first
         when "second"
           self.image_uri = self.image_uri_second
         when "custom"
           self.image_uri = self.image_uri_custom
         when "anonymous"
           self.image_uri = ActionController::Base.helpers.asset_path("mascot.jpg")
       end
   
     end
   
     def update_is_profile_valid
       if ((self.biography.blank? && self.facebook.blank? && self.twitter.blank? && self.google_plus.blank? && self.linked_in.blank?) or
           (self.telephone1.blank? && self.telephone2.blank? && self.telephone3.blank? && self.telephone4.blank?))
         self.is_profile_valid = false
       else
         self.is_profile_valid= true
       end
       return true
     end
   
   
   end

================================================================================
 ./app/models/user_preference.rb
================================================================================
   class UserPreference < ActiveRecord::Base
   end

================================================================================
 ./app/services/academic_calendar.rb
================================================================================
   class AcademicCalendar
   
   #
   # Note: to check future dates, use the following code. Date.new(2010, 8, 23).cweek
   #
   
   
   # Looking at the calendar, we want current_semester to have these characteristics
   # Spring starts roughly around Christmas and ends 1 week after last day of semester
   # Summer starts 1 week before and end 1 week after semester
   # Fall starts 1 week before and goes to roughly around Christmas
   #
   # In reality, this should be based upon when grades are due.
     def self.current_semester_old
!!     cweek = Date.today.cweek()
!!     return "Spring" if cweek < AcademicCalendar.semester_start("Summer", Date.today.cwyear) - 1 || cweek > 51
!!     return "Summer" if cweek < AcademicCalendar.semester_start("Fall", Date.today.cwyear) - 1
!!     return "Fall"
     end
   
     def self.current_semester
       return "Spring" if Date.today <= AcademicCalendar.grades_due_for("Spring", Date.today.year)
!!     return "Summer" if Date.today <= AcademicCalendar.grades_due_for("Summer", Date.today.year)
!!     return "Fall"   if Date.today <= AcademicCalendar.grades_due_for("Fall", Date.today.year)
!!     return "Spring"
     end
   
     def self.current_semester_year
       cweek = Date.today.cweek()
       if cweek > 51
!!       Date.today.cwyear + 1
       else
         Date.today.cwyear
       end
     end
   
     def self.current_mini
       cweek = Date.today.cweek()
       cwyear = Date.today.cwyear()
   
       spring_a = AcademicCalendar.semester_start("Spring", cwyear)
       summer_a = AcademicCalendar.semester_start("Summer", cwyear)
       fall_a = AcademicCalendar.semester_start("Fall", cwyear)
   
       case cweek
         when (spring_a)..(spring_a + 6) then
!!         "A"
         when (spring_a + 9)..(spring_a + 15) then
           "B"
   
!!       when (summer_a)..(summer_a + 5) then
!!         "A"
!!       when (summer_a + 6)..(summer_a + 11) then
!!         "B"
   
!!       when (fall_a)..(fall_a + 6) then
!!         "A"
!!       when (fall_a + 8)..(fall_a + 14) then
!!         "B"
         else
!!         "Unknown"
       end
     end
   
     def self.next_semester
       case AcademicCalendar.current_semester
         when "Spring"
           return "Summer"
         when "Summer"
!!         return "Fall"
         when "Fall"
!!         return "Spring"
       end
     end
   
     def self.next_semester_year
       if AcademicCalendar.next_semester == "Spring" || Date.today.cweek > 51
!!         return Date.today.cwyear + 1
         else
           return Date.today.cwyear
       end
     end
   
     def self.next_semester_is_soon
       case self.current_mini
         when "A"
!!         false
         when "B"
           true
         when "Unknown"
!!         true
         else
!!         true
       end
     end
   
     def self.week_during_semester?(year, week_number)
       case week_number
         when self.semester_start("Spring", year)..(self.semester_start("Spring", year)+16)
           return true
         when self.semester_start("Summer", year)..(self.semester_start("Summer", year)+11)
           return true
         when self.semester_start("Fall", year)..(self.semester_start("Fall", year)+15)
           return true
         else
           return false
       end
     end
   
     def self.spring_break(year)
       case year
         when 2014
!!         return 10..11
         when 2013
!!         return 10..11
         when 2012
!!         return 10..11
         when 2011
!!         return 9..10
         when 2010
           return 9..10
         else
!!         options = {:to => "todd.sedano@sv.cmu.edu",
                      :subject => "Academic Calendar needs updating: spring_break",
                      :message => "Please modify app/services/AcademicCalendar.rb spring_break(#{year})",
                      :url_label => "",
                      :url => ""
           }
!!         GenericMailer.email(options).deliver
           return nil
       end
     end
   
   
     def self.term_length(semester, mini)
       case semester
         when "Fall"
!!         case mini
             when "A"
!!             7
             when "B"
!!             7
             when "Both"
!!             15
           end
         when "Spring"
           case mini
             when "A"
               7
             when "B"
               7
             when "Both"
               16
           end
         when "Summer"
!!         case mini
             when "A"
!!             6
             when "B"
!!             6
             when "Both"
!!             12
           end
       end
     end
   
     def self.break_length_between_minis(semester)
       case semester
         when "Fall"
!!         1
         when "Spring"
           2
         when "Summer"
!!         0
       end
     end
   
     def self.grades_due_for(semester, year)
       case year
         when 2014
         case semester
           when "Spring"
             return Date.new(2014, 5, 21) #Academic calendar doesn't exaclty say?
           when "Summer"
!!           return  Date.new(2014, 8, 12)
           when "Fall"
!!           return  Date.new(2014, 12, 18)
         end      
         when 2013
!!         case semester
             when "Spring"
!!             return Date.new(2013, 5, 22)
             when "Summer"
!!             return  Date.new(2013, 8, 13)
             when "Fall"
!!             return  Date.new(2013, 12, 18)
           end
         when 2012
!!         case semester
             when "Spring"
!!             return Date.new(2012, 5, 22)
             when "Summer"
!!             return  Date.new(2012, 8, 14)
             when "Fall"
!!             return  Date.new(2012, 12, 20)
           end
         when 2011
!!         case semester
             when "Spring"
!!             return Date.new(2011, 5, 17)
             when "Summer"
!!             return  Date.new(2011, 8, 9)
             when "Fall"
!!             return  Date.new(2011, 12, 22)
           end
         when 2010
!!         case semester
             when "Spring"
!!             return Date.new(2010, 5, 18)
             when "Summer"
!!             return  Date.new(2010, 8, 10)
             when "Fall"
!!             return  Date.new(2010, 12, 16)
           end
         else
!!         options = {:to => "todd.sedano@sv.cmu.edu",
                      :subject => "Academic Calendar needs updating: grades_due_for",
                      :message => "Please modify app/services/AcademicCalendar.rb grades_due_for(#{semester}, #{year})",
                      :url_label => "",
                      :url => ""
           }
!!         GenericMailer.email(options).deliver
       end
   
   
     end
   
     #Historically we have used semester start to determine what is the current semester, moving forward, lets do this
     #around the grades due deadline
   
   
     # First day of class
     # August 26, 2013
     # January 13, 2014
     # May 19, 2014
   
     # Last day of class
     # December 6, 2013
     # May 2, 2013
     # August 7, 2014
   
     def self.semester_start(semester, year)
       case year
         when 2015
!!         case semester
             when "Spring" #Not official yet (4/1/2014)
!!             return 3
             when "Summer" #Not official yet (4/1/2014)
!!             return 21
             when "Fall" #Not official yet (4/1/2014)
!!             return 35
           end
         when 2014
           case semester
             when "Spring"
               return 3
             when "Summer"
               return 21
             when "Fall" #Not official yet (1/2/2012)
               return 35
           end
         when 2013
!!         case semester
             when "Spring"
!!             return 3
             when "Summer"
!!             return 21
             when "Fall"
!!             return 35
           end
         when 2012
!!         case semester
             when "Spring"
!!             return 3
             when "Summer"
!!             return 21
             when "Fall"
!!             return 35
           end
         when 2011
           case semester
             when "Spring"
               return 2
             when "Summer"
               return 20
             when "Fall"
               return 35
           end
         when 2010
           case semester
             when "Spring"
               return 2
             when "Summer"
               return 20
             when "Fall"
               return 34
           end
         when 2009
!!         case semester
             when "Spring"
!!             return 3
             when "Summer"
!!             return 21
             when "Fall"
!!             return 34
           end
         when 2008 #This calendar is not aligned to the CMU Pittsburgh calendar
!!         case semester
             when "Spring"
!!             return 2
             when "Summer"
!!             return 16
             when "Fall"
!!             return 35
           end
         else
!!         options = {:to => "todd.sedano@sv.cmu.edu",
                      :subject => "Academic Calendar needs updating: semester_start",
                      :message => "Please modify app/services/AcademicCalendar.rb semester_start(#{semester}, #{year})",
                      :url_label => "",
                      :url => ""
           }
!!         GenericMailer.email(options).deliver
       end
   
     end
   
     def self.date_for_semester_start(semester, year)
       cweek = semester_start(semester, year)
       Date.commercial(year, cweek)
     end
   
     def self.date_for_semester_end(semester, year)
       cweek = semester_start(semester, year)
       cweek += self.term_length(semester, "Both")
       Date.commercial(year, cweek, 5) #Friday
     end
   
     def self.date_for_mini_start(semester, mini, year)
       cweek = semester_start(semester, year)
       if mini == "B"
         cweek += self.term_length(semester, mini) - 1
         cweek += self.break_length_between_minis(semester) + 1
       end
       Date.commercial(year, cweek, 1)
     end
   
     def self.date_for_mini_end(semester, mini, year)
       cweek = semester_start(semester, year)
       cweek += self.term_length(semester, "A") - 1
       if mini == "B"
         cweek += self.break_length_between_minis(semester)
         cweek += self.term_length(semester, mini)
       end
       Date.commercial(year, cweek, 5) #Friday
     end
   
     # F12, S12, M12
     def self.parse_HUB_semester(short_form)
       return "", "" if short_form.blank?
   
       case short_form[0]
         when 'F'
           semester = 'Fall'
         when 'S'
!!         semester = 'Spring'
         when 'M'
!!         semester = 'Summer'
         else
!!         semester = ""
       end
   
       year = '20' + short_form[1..2]
       year = year.to_i
       year = "" if year == 20
   
       return semester, year
     end
   
     def self.parse_semester_and_year(semester_year_string)
!!     semester = semester_year_string[0..-5]
!!     semester = semester.capitalize if semester
!!     year = semester_year_string[-4..-1].to_i
!!     year = "" if year == 0
!!     return semester, year
     end
   
   
     def self.valid_semester_and_year(string)
!!     (semester, year) = self.parse_semester_and_year(string)
!!     (semester, year) = self.parse_HUB_semester(string) if (semester.empty? || year.is_a?(String))
   
!!     semester = "" unless ["Fall", "Summer", "Spring"].include?(semester)
!!     if year.is_a?(Fixnum)
!!       year = "" unless year > 2007 && year <= (Date.today.year + 1)
       end
   
!!     return semester, year
     end
   
   end

================================================================================
 ./app/services/peer_evaluation_email.rb
================================================================================
   class PeerEvaluationEmail
   
   
     def self.please_do_peer_evaluation_email
   
!!     courses_with_first_date = Course.first_email_on_peer_evaluation_is_today
!!     courses_with_second_date = Course.second_email_on_peer_evaluation_is_today
!!     sent_emails = 0
   
!!     courses_with_first_date.each do |course|
!!       course.teams.each do |team|
!!         puts "Team: " + team.name + " (" + team.id.to_s + ") "
!!         send_peer_evaluation_email(team, team.peer_evaluation_message_one, team.peer_evaluation_message_one)
!!         sent_emails += 1
         end
       end
   
!!     courses_with_second_date.each do |course|
!!       course.teams.each do |team|
!!         puts "Team: " + team.name + " (" + team.id.to_s + ") "
!!         send_peer_evaluation_email(team, I18n.t(:peer_evaluation_message_two_done), I18n.t(:peer_evaluation_message_two_incomplete))
!!         sent_emails += 1
         end
       end
!!     sent_emails
     end
   
   
     def self.send_peer_evaluation_email(team, done_message, incomplete_message)
!!     faculty = team.faculty_email_addresses()
   
!!     to_address_done = []
!!     to_address_incomplete = []
!!     team.members.each do |user|
!!       if PeerEvaluationReview.is_completed_for?(user.id, team.id)
!!         to_address_done << user.email
         else
!!         to_address_incomplete << user.email
         end
       end
!!     send_email(team, faculty, to_address_done, done_message) unless to_address_done.empty?
!!     send_email(team, faculty, to_address_incomplete, incomplete_message) unless to_address_incomplete.empty?
     end
   
   
     def self.send_email(team, faculty, to_address, message)
!!     options = {:to => to_address, :cc => faculty, :bcc => "rails.app@sv.cmu.edu",
                  :subject => "peer evaluation for team #{team.name}",
                  :message => message, :url => "http://whiteboard.sv.cmu.edu/peer_evaluation/edit_evaluation/#{team.id}", # + edit_peer_evaluation_path(team))
                  :url_label => "Complete the survey now"}
!!     GenericMailer.email(options).deliver
     end
   
   
   
   
   end

================================================================================
 ./app/services/people_in_a_collection.rb
================================================================================
   module PeopleInACollection
   
     # When assigning faculty to a page, the user types in a series of strings that then need to be processed
     #:members_override is a temporary variable that is used to do validation of the strings (to verify
     # that they are people in the system) and then to save the people in the faculty association.
   
     def validate_members(override_symbol)
        override_list_of_strings = send(override_symbol)
        return "" if override_list_of_strings.nil?
   
        override_list_of_strings = remove_empty_fields(override_list_of_strings)
        send "#{override_symbol}=", override_list_of_strings
   
        override_list_of_users = map_member_strings_to_users(override_list_of_strings)
        override_list_of_users.each_with_index do |user, index|
          if user.nil?
            self.errors.add(:base, "Person " + override_list_of_strings[index] + " not found")
          end
        end
    	end
   
     def remove_empty_fields(list_of_strings)
       list_of_strings.select { |name| name != nil && name.strip != "" }
     end
   
     def map_member_strings_to_users(members_override_list)
       members_override_list.map { |member_name| User.find_by_human_name(member_name) }
     end
   
     # Example:
     #      include PeopleInACollection
     #      update_collection_members :supervisors_override, :supervisors, :update_log
     #
     #
     # override_symbol - the holds a string array of people's names
     # attribute_symbol - the association that needs to be updated
     # update_method_symbol - (optional) method to call with a list of added and removed users
     def update_collection_members override_symbol, attribute_symbol, update_method_symbol = nil
       override_list_of_strings = send(override_symbol)
       return "" if override_list_of_strings.nil?
   
       original_list_of_users = send "#{attribute_symbol}"
       original_list_of_strings = original_list_of_users.collect { |person| person.human_name }
   
       override_list_of_strings = remove_empty_fields(override_list_of_strings)
       send "#{override_symbol}=", override_list_of_strings
   
       override_list_of_users = map_member_strings_to_users(override_list_of_strings)
       added = added_people(override_list_of_users, original_list_of_users)
       removed = removed_people(override_list_of_users, original_list_of_users)
   
       raise "Error converting supervisors_override to IDs!" if override_list_of_users.include?(nil)
       send "#{attribute_symbol}=", override_list_of_users
       send "#{override_symbol}=", nil
   
       if update_method_symbol && (added.any? || removed.any?)
!!       send update_method_symbol, added, removed
       end
     end
   
     def detect_if_list_changed(override_list_of_strings, original_list_of_users)
!!     return (override_list_of_strings.sort != original_list_of_users.collect { |person| person.human_name }.sort)
     end
   
     def added_people(override_list_of_users, original_list_of_users)
       tmp =  (override_list_of_users - original_list_of_users)
       return tmp
     end
   
     def removed_people(override_list_of_users, original_list_of_users)
       tmp =  (original_list_of_users - override_list_of_users)
       return tmp
     end
   
   end
   

================================================================================
 ./config/application.rb
================================================================================
   require File.expand_path('../boot', __FILE__)
   
   require 'rails/all'
   
   # If you have a Gemfile, require the gems listed there, including any gems
   # you've limited to :test, :development, or :production.
   #Bundler.require(:default, Rails.env) if defined?(Bundler)
   if defined?(Bundler)
     # If you precompile assets before deploying to production,
   
     Bundler.require *Rails.groups(:assets => %w(development test))
     # If you want your assets lazily compiled in production,
   
     # Bundler.require(:default, :assets, Rails.env)
   end
   
   module CMUEducation
     class Application < Rails::Application
       # Settings in config/environments/* take precedence over those specified here.
       # Application configuration should go into files in config/initializers
       # -- all .rb files in that directory are automatically loaded.
       config.i18n.enforce_available_locales = false
       # Custom directories with classes and modules you want to be autoloadable.
       config.autoload_paths += Dir["#{config.root}/lib/**/"]
       config.autoload_paths += Dir["#{config.root}/app/services/**/"]
   
       # Only load the plugins named here, in the order given (default is alphabetical).
       # :all can be used as a placeholder for all plugins not explicitly named.
       # config.plugins = [ :exception_notification, :ssl_requirement, :all ]
   
       # Activate observers that should always be running.
       # config.active_record.observers = :cacher, :garbage_collector, :forum_observer
   
       # Set Time.zone default to the specified zone and make Active Record auto-convert to this zone.
       # Run "rake -D time" for a list of tasks for finding time zone names. Default is UTC.
       # config.time_zone = 'Central Time (US & Canada)'
       #config.time_zone = 'UTC'
       config.time_zone = "Pacific Time (US & Canada)"
   
       # The default locale is :en and all translations from config/locales/*.rb,yml are auto loaded.
       # config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}').to_s]
       # config.i18n.default_locale = :de
   
       # JavaScript files you want as :defaults (application.js is always included).
       # config.action_view.javascript_expansions[:defaults] = %w(jquery rails)
   
       # Configure the default encoding used in templates for Ruby 1.9.
       config.encoding = "utf-8"
   
       # Configure sensitive parameters which will be filtered from the log file.
       config.filter_parameters += [:password]
   
       OpenID.fetcher.ca_file = "#{Rails.root}/config/ca-bundle.crt"
       config.assets.enabled = true
       config.assets.version = '1.0'
       #config.assets.precompile = [/^[^_]/]
       #config.assets.precompile += %w( mobile.css )
   # config.autoload_paths += %W(#{config.root}/app/models/ckeditor)
   
     # Your secret key for verifying cookie session data integrity.
     # If you change this key, all old sessions will become invalid!
     # Make sure the secret is at least 30 characters and all random,
     # no regular words or you'll be exposed to dictionary attacks.
     config.session_store = {
       :session_key => '_CMUEducation_session',
       :secret      => '1d49995d604604d69d2c9dbb99eadb133c1385c9a2be3aa98d339732b76012b07e3c227f9ea10f2c281c6cfa678d27c02d552ef107ace23df59ba438aa81d47e'
     }     
   
     end
   end
   

================================================================================
 ./config/boot.rb
================================================================================
   require 'rubygems'
   
   # Set up gems listed in the Gemfile.
   ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)
   
   require 'bundler/setup' if File.exists?(ENV['BUNDLE_GEMFILE'])

================================================================================
 ./config/environment.rb
================================================================================
   # Load the rails application
   require File.expand_path('../application', __FILE__)
   
   # Initialize the rails application
   CMUEducation::Application.initialize!

================================================================================
 ./config/environments/test.rb
================================================================================
   
   CMUEducation::Application.configure do
     # Settings specified here will take precedence over those in config/application.rb
   
     # The test environment is used exclusively to run your application's
     # test suite.  You never need to work with it otherwise.  Remember that
     # your test database is "scratch space" for the test suite and is wiped
     # and recreated between test runs.  Don't rely on the data there!
     config.cache_classes = true
   
     # Configure static asset server for tests with Cache-Control for performance
     config.serve_static_assets = true
     config.static_cache_control = "public, max-age=3600"
   
     # Log error messages when you accidentally call methods on nil
     config.whiny_nils = true
   
     # Show full error reports and disable caching
     config.consider_all_requests_local       = true
     config.action_controller.perform_caching = false
   
     # Raise exceptions instead of rendering exception templates
     config.action_dispatch.show_exceptions = false
   
     # Disable request forgery protection in test environment
     config.action_controller.allow_forgery_protection    = false
   
     # Tell Action Mailer not to deliver emails to the real world.
     # The :test delivery method accumulates sent emails in the
     # ActionMailer::Base.deliveries array.
     config.action_mailer.delivery_method = :test
   
     # Use SQL instead of Active Record's schema dumper when creating the test database.
     # This is necessary if your schema can't be completely dumped by the schema dumper,
     # like if you have constraints or database-specific column types
     # config.active_record.schema_format = :sql
   
     # Print deprecation notices to the stderr
     config.active_support.deprecation = :stderr
   
     config.time_zone = "UTC"
    
   # This next line was left over from rails2 code, do we still need it?
   #  config.gem 'rspec-rails', :version => '>= 1.3.2', :lib => false unless File.directory?(File.join(Rails.root, 'vendor/plugins/rspec-rails'))
     #Paperclip.options[:command_path] = "usr/local/bin/identify"
   end

================================================================================
 ./config/initializers/asset_sync.rb
================================================================================
   # Since this gem is only loaded with the assets group, we have to check to
   # see if it's defined before configuring it.
   if defined?(AssetSync)
     AssetSync.configure do |config|
       config.fog_provider = 'AWS'
       config.aws_access_key_id = ENV['WHITEBOARD_S3_KEY']
       config.aws_secret_access_key =  ENV['WHITEBOARD_S3_SECRET']
       config.fog_directory = ENV['WHITEBOARD_S3_ASSET_BUCKET']
   
       # Fail silently.  Useful for environments such as Heroku
       config.fail_silently = false
     end
   end

================================================================================
 ./config/initializers/aws.rb
================================================================================
   #require 'aws/s3'
   #AWS::S3::Base.establish_connection!(
   #  :access_key_id     => ENV['S3_KEY'] || 'thedefaultkey',
   #  :secret_access_key => ENV['S3_SECRET'] || 'thedefaultsecret',
   #  :bucket            => ENV['S3_BUCKET'] || 'thedefaultbucket'
   #)
   #
   #
   #require 'aws'
   #
   #include AWS
   #config_path = File.expand_path(File.dirname(__FILE__)+"/../amazon_s3.yml")
   #AWS.config(YAML.load(File.read(config_path)))

================================================================================
 ./config/initializers/backtrace_silencers.rb
================================================================================
   # Be sure to restart your server when you modify this file.
   
   # You can add backtrace silencers for libraries that you're using but don't wish to see in your backtraces.
   # Rails.backtrace_cleaner.add_silencer { |line| line =~ /my_noisy_library/ }
   
   # You can also remove all the silencers if you're trying to debug a problem that might stem from framework code.
   # Rails.backtrace_cleaner.remove_silencers!

================================================================================
 ./config/initializers/delayed_job.rb
================================================================================
   Delayed::Worker.destroy_failed_jobs = false
   
   #Delayed::Worker.logger = Rails.logger

================================================================================
 ./config/initializers/devise.rb
================================================================================
   require 'openid/store/filesystem'
   
   # Use this hook to configure devise mailer, warden hooks and so forth. The first
   # four configuration values can also be set straight in your models.
   Devise.setup do |config|
     # ==> Mailer Configuration
     # Configure the e-mail address which will be shown in Devise::Mailer,
     # note that it will be overwritten if you use your own mailer class with default "from" parameter.
     config.mailer_sender = "scotty.dog@sv.cmu.edu"
   
     # Configure the class responsible to send e-mails.
     # config.mailer = "Devise::Mailer"
   
     # ==> ORM configuration
     # Load and configure the ORM. Supports :active_record (default) and
     # :mongoid (bson_ext recommended) by default. Other ORMs may be
     # available as additional gems.
     require 'devise/orm/active_record'
   
     # ==> Configuration for any authentication mechanism
     # Configure which keys are used when authenticating a user. The default is
     # just :email. You can configure it to use [:username, :subdomain], so for
     # authenticating a user, both parameters are required. Remember that those
     # parameters are used only when authenticating and not when retrieving from
     # session. If you need permissions, you should implement that in a before filter.
     # You can also supply a hash where the value is a boolean determining whether
     # or not authentication should be aborted when the value is not present.
     # config.authentication_keys = [ :email ]
   
     # Configure parameters from the request object used for authentication. Each entry
     # given should be a request method and it will automatically be passed to the
     # find_for_authentication method and considered in your model lookup. For instance,
     # if you set :request_keys to [:subdomain], :subdomain will be used on authentication.
     # The same considerations mentioned for authentication_keys also apply to request_keys.
     # config.request_keys = []
   
     # Configure which authentication keys should be case-insensitive.
     # These keys will be downcased upon creating or modifying a user and when used
     # to authenticate or find a user. Default is :email.
     config.case_insensitive_keys = [ :email ]
   
     # Configure which authentication keys should have whitespace stripped.
     # These keys will have whitespace before and after removed upon creating or
     # modifying a user and when used to authenticate or find a user. Default is :email.
     config.strip_whitespace_keys = [ :email ]
   
     # Tell if authentication through request.params is enabled. True by default.
     # config.params_authenticatable = true
   
     # Tell if authentication through HTTP Basic Auth is enabled. False by default.
     # config.http_authenticatable = false
   
     # If http headers should be returned for AJAX requests. True by default.
     # config.http_authenticatable_on_xhr = true
   
     # The realm used in Http Basic Authentication. "Application" by default.
     # config.http_authentication_realm = "Application"
   
     # It will change confirmation, password recovery and other workflows
     # to behave the same regardless if the e-mail provided was right or wrong.
     # Does not affect registerable.
     # config.paranoid = true
   
     # ==> Configuration for :database_authenticatable
     # For bcrypt, this is the cost for hashing the password and defaults to 10. If
     # using other encryptors, it sets how many times you want the password re-encrypted.
     #
     # Limiting the stretches to just one in testing will increase the performance of
     # your test suite dramatically. However, it is STRONGLY RECOMMENDED to not use
     # a value less than 10 in other environments.
     config.stretches = Rails.env.test? ? 1 : 10
   
     # Setup a pepper to generate the encrypted password.
     # config.pepper = "59b234ee647444b898646ee3b73d77833d0cc684fd0dd73687cb75878b79e50ee47121b227ffa6be02c68d0dacfa3d23b1c2db995fd6c0c57e9bedfd7027e0fa"
   
     # ==> Configuration for :confirmable
     # The time you want to give your user to confirm his account. During this time
     # he will be able to access your application without confirming. Default is 0.days
     # When confirm_within is zero, the user won't be able to sign in without confirming.
     # You can use this to let your user access some features of your application
     # without confirming the account, but blocking it after a certain period
     # (ie 2 days).
     # config.confirm_within = 2.days
   
     # Defines which key will be used when confirming an account
     # config.confirmation_keys = [ :email ]
   
     # ==> Configuration for :rememberable
     # The time the user will be remembered without asking for credentials again.
     # config.remember_for = 2.weeks
     config.remember_for = 1.day
   
     # If true, a valid remember token can be re-used between multiple browsers.
     # config.remember_across_browsers = true
   
     # If true, extends the user's remember period when remembered via cookie.
     # config.extend_remember_period = false
     config.extend_remember_period = true
   
     # If true, uses the password salt as remember token. This should be turned
     # to false if you are not using database authenticatable.
     #config.use_salt_as_remember_token = false
   
     # Options to be passed to the created cookie. For instance, you can set
     # :secure => true in order to force SSL only cookies.
     # config.cookie_options = {}
   
     # ==> Configuration for :validatable
     # Range for password length. Default is 6..128.
     # config.password_length = 6..128
   
     # Email regex used to validate email formats. It simply asserts that
     # an one (and only one) @ exists in the given string. This is mainly
     # to give user feedback and not to assert the e-mail validity.
     # config.email_regexp = /\A[^@]+@[^@]+\z/
   
     # ==> Configuration for :timeoutable
     # The time you want to timeout the user session without activity. After this
     # time the user will be asked for credentials again. Default is 30 minutes.
     # config.timeout_in = 30.minutes
      config.timeout_in = 1.day
   
     # ==> Configuration for :lockable
     # Defines which strategy will be used to lock an account.
     # :failed_attempts = Locks an account after a number of failed attempts to sign in.
     # :none            = No lock strategy. You should handle locking by yourself.
     # config.lock_strategy = :failed_attempts
   
     # Defines which key will be used when locking and unlocking an account
     # config.unlock_keys = [ :email ]
   
     # Defines which strategy will be used to unlock an account.
     # :email = Sends an unlock link to the user email
     # :time  = Re-enables login after a certain amount of time (see :unlock_in below)
     # :both  = Enables both strategies
     # :none  = No unlock strategy. You should handle unlocking by yourself.
     # config.unlock_strategy = :both
   
     # Number of authentication tries before locking an account if lock_strategy
     # is failed attempts.
     # config.maximum_attempts = 20
   
     # Time interval to unlock the account if :time is enabled as unlock_strategy.
     # config.unlock_in = 1.hour
   
     # ==> Configuration for :recoverable
     #
     # Defines which key will be used when recovering the password for an account
     # config.reset_password_keys = [ :email ]
   
     # Time interval you can reset your password with a reset password key.
     # Don't put a too small interval or your users won't have the time to
     # change their passwords.
     config.reset_password_within = 2.hours
   
     # ==> Configuration for :encryptable
     # Allow you to use another encryption algorithm besides bcrypt (default). You can use
     # :sha1, :sha512 or encryptors from others authentication tools as :clearance_sha1,
     # :authlogic_sha512 (then you should set stretches above to 20 for default behavior)
     # and :restful_authentication_sha1 (then you should set stretches to 10, and copy
     # REST_AUTH_SITE_KEY to pepper)
     # config.encryptor = :sha512
   
     # ==> Configuration for :token_authenticatable
     # Defines name of the authentication token params key
     # config.token_authentication_key = :auth_token
   
     # If true, authentication through token does not store user in session and needs
     # to be supplied on each request. Useful if you are using the token as API token.
     # config.stateless_token = false
   
     # ==> Scopes configuration
     # Turn scoped views on. Before rendering "sessions/new", it will first check for
     # "users/sessions/new". It's turned off by default because it's slower if you
     # are using only default views.
     # config.scoped_views = false
   
     # Configure the default scope given to Warden. By default it's the first
     # devise role declared in your routes (usually :user).
     # config.default_scope = :user
   
     # Configure sign_out behavior.
     # Sign_out action can be scoped (i.e. /users/sign_out affects only :user scope).
     # The default is true, which means any logout action will sign out all active scopes.
     # config.sign_out_all_scopes = true
   
     # ==> Navigation configuration
     # Lists the formats that should be treated as navigational. Formats like
     # :html, should redirect to the sign in page when the user does not have
     # access, but formats like :xml or :json, should return 401.
     #
     # If you have any extra navigational formats, like :iphone or :mobile, you
     # should add them to the navigational formats lists.
     #
     # The :"*/*" and "*/*" formats below is required to match Internet
     # Explorer requests.
     # config.navigational_formats = [:"*/*", "*/*", :html]
   
     # The default HTTP method used to sign out a resource. Default is :delete.
     config.sign_out_via = :delete
   
     # ==> OmniAuth
     # Add a new OmniAuth provider. Check the wiki for more information on setting
     # up on your models and hooks.
     # config.omniauth :github, 'APP_ID', 'APP_SECRET', :scope => 'user,public_repo'
     config.omniauth :google_apps, :store => OpenID::Store::Filesystem.new('./tmp'), :domain => 'west.cmu.edu'
   
     # ==> Warden configuration
     # If you want to use other strategies, that are not supported by Devise, or
     # change the failure app, you can configure them inside the config.warden block.
     #
     # config.warden do |manager|
     #   manager.failure_app   = AnotherApp
     #   manager.intercept_401 = false
     #   manager.default_strategies(:scope => :user).unshift :some_external_strategy
     # end
   end

================================================================================
 ./config/initializers/exception_notification.rb
================================================================================
   #ExceptionNotifier::Notifier.prepend_view_path File.join(Rails.root, 'app/views')

================================================================================
 ./config/initializers/google_apps.rb
================================================================================
   GOOGLE_USERNAME = ENV['WHITEBOARD_GOOGLE_USERNAME'] || "account@sandbox.sv.cmu.edu"
   GOOGLE_PASSWORD = ENV['WHITEBOARD_GOOGLE_PASSWORD'] || "password"
   GOOGLE_DOMAIN = ENV['WHITEBOARD_GOOGLE_DOMAIN'] || "sandbox.sv.cmu.edu"
   
   require 'gappsprovisioning/provisioningapi'
   include GAppsProvisioning
   def google_apps_connection
     @google_apps_connection ||= ProvisioningApi.new(GOOGLE_USERNAME, GOOGLE_PASSWORD)
   rescue
!!   Rails.logger.debug "had to rescue (ie reconnect) google apps"
!!   Rails.logger.info "had to rescue (ie reconnect) google apps"
!!   @google_apps_connection = ProvisioningApi.new(GOOGLE_USERNAME, GOOGLE_PASSWORD)
   end
   
   #This code works for a person's email address or a team's distribution list
   def switch_sv_to_west(email_address)
        return nil if email_address.nil?
        (name, domain) = email_address.split('@')
        if(domain == "sv.cmu.edu")
           email_address = name + "@west.cmu.edu"
        end
        return email_address
   end
   
   def switch_west_to_sv(email_address)
         return nil if email_address.nil?
        (name, domain) = email_address.split('@')
        if(domain == "west.cmu.edu")
           email_address = name + "@sv.cmu.edu"
        end
        return email_address
   end
   
   def pretty_print_google_error(e)
!!     logger.debug "errorcode = " +e.code + "input : " + e.input + "reason : "+e.reason
!!     return "Mailing list already exists." if e.code.to_i == 1300
!!     return "Mailing list does not exist." if e.code.to_i == 1301
!!     return e.reason + " (" + e.code + ") for " + e.input + "."
   end
   
   
   # The following was added to connect to the provisioning Google APPS API by Greg Hilton
   # I have not seen this code functioning.
   
   
   def wait_for_google_sync
   end
   #
   #def wait_for_google_sync
   #  until $google_thread_items.empty?
   #    sleep 1
   #  end
   #  sleep 0.2 # this delay is just to be save
   #  Rails.logger.debug "Synced with Google Apps at #{Time.now}"
   #end
   #
   #$google_thread_items = []
   #
   #
   #def async_google_add_member(user_email,team_name)
   #  $google_thread_items << Proc.new {
   #    begin
   #      google_apps = google_apps_connection
   #      #Rails.looger.debug "\n#{Time.now}: add #{user_email} form #{team_name}"
   #      unless google_apps.is_member(user_email, team_name)
   #        google_apps.add_member_to_group(user_email, team_name)
   #      end
   #    rescue GDataError => e
   #      Rails.logger.error "\n\nAttempting to populate group.  errorcode = #{e.code}, input : #{e.input}, reason : #{e.reason}\n\n"
   #    end
   #  }
   #end
   #def async_google_remove_member(user_email,team_name)
   #  $google_thread_items << Proc.new {
   #    begin
   #      google_apps = google_apps_connection
   #      #Rails.looger.debug "\n#{Time.now}: remove #{user_email} form #{team_name}"
   #      if google_apps.is_member(user_email, self.email_builder)
   #        google_apps.remove_member_from_group(user_email,team_name)
   #      end
   #    rescue GDataError => e
   #      Rails.logger.error "Attempting to remove member form group.  errorcode = " +e.code, "input : "+e.input, "reason : "+e.reason
   #    end
   #  }
   #end
   #
   #def async_google_update_mailing_list(old_email, new_email, team_name, course_name)
   #  $google_thread_items << Proc.new {
   #      google_apps = google_apps_connection
   #    #Rails.looger.debug "\n#{Time.now}: updating #{old_email} to #{new_email}"
   #    new_group_exists = 1
   #    old_group_exists = 0
   #    google_apps.retrieve_all_groups.each do |list|
   #      #Rails.looger.debug list.group_id
   #      group_name = list.group_id.split('@')[0]
   #      #Rails.looger.debug "DEBUG: #{group_name} vs #{self.old_email} vs #{self.email_builder}"
   #      if "#{old_email}" == "#{group_name}"
   #        #Rails.looger.debug "DEBUG:Will remove old"
   #        old_group_exists = 1
   #      end
   #      if "#{self.email_builder}" == "#{group_name}"
   #        #Rails.looger.debug "DEBUG:Will create group"
   #        new_group_exists = 0
   #      end
   #    end
   #    if old_group_exists == 1
   #      #Rails.looger.debug "\n\n\n\nDEBUG:  Deleting #{old_email}\n\n\n\n"
   #      google_apps.delete_group(old_email)
   #    end
   #    if new_group_exists == 0
   #      Rails.logger.info "\n\n\n\nDEBUG:  Creating #{new_email}\n\n\n\n"
   #      Rails.logger.info "#{new_email} -- #{team_name} course #{course_name}"
   #      google_apps.create_group(new_email, [team_name, "#{team_name} for course #{course_name}", "Domain"])
   #    end
   #  }
   #end
   #
   #def threading
   #  while true
   #    unless $google_thread_items.empty?
   #      logger.debug "Google thread - running process"
   #      $google_thread_items[0].call
   #      sleep 5
   #      $google_thread_items.shift
   #      logger.debug "Google thread - process complete"
   #    end
   #    sleep 0.5
   #    logger.debug "DEBUG THREADING #{Time.now}"
   #  end
   #end
   #@google_thread = Thread.new { threading }

================================================================================
 ./config/initializers/inflections.rb
================================================================================
   # Be sure to restart your server when you modify this file.
   
   # Add new inflection rules using the following format
   # (all these examples are active by default):
   # ActiveSupport::Inflector.inflections do |inflect|
   #   inflect.plural /^(ox)$/i, '\1en'
   #   inflect.singular /^(ox)en/i, '\1'
   #   inflect.irregular 'person', 'people'
   #   inflect.uncountable %w( fish sheep )
   # end

================================================================================
 ./config/initializers/ldap.rb
================================================================================
   class LDAPConfig
     def self.host
!!     ENV['LDAP_HOST'] || '127.0.0.1'
     end
   
     def self.port
!!     ENV['LDAP_PORT'] || '636'
     end
   
     def self.username
!!     ENV['LDAP_USERNAME'] || 'anyone'
     end
   
     def self.password
!!     ENV['LDAP_PASSWORD'] || 'anysecret'
     end
   
     def self.is_encrypted?
!!     ENV['LDAP_ENCRYPTED'] || true
     end
   end

================================================================================
 ./config/initializers/mail.rb
================================================================================

================================================================================
 ./config/initializers/mime_types.rb
================================================================================
   # Be sure to restart your server when you modify this file.
   
   # Add new mime types for use in respond_to blocks:
   # Mime::Type.register "text/richtext", :rtf
   # Mime::Type.register_alias "text/html", :iphone

================================================================================
 ./config/initializers/omniauth.rb
================================================================================
   #
   # Put omni auth configuration infromation into devise.rb
   #

================================================================================
 ./config/initializers/paperclip.rb
================================================================================
   require 'digest/md5'
   
   Paperclip.interpolates('random_hash') do |attachment, style|
!!   Digest::MD5.hexdigest(attachment.instance.id.to_s)
   end
   
   Paperclip.interpolates('deliverable_random_hash') do |attachment, style|
     Digest::MD5.hexdigest(attachment.instance.deliverable.id.to_s)
   end
   
   Paperclip.interpolates('course_name') do |attachment, style|
!!   attachment.instance.course.display_course_name
   end
   
   Paperclip.interpolates('course_year') do |attachment, style|
!!   attachment.instance.course.year
   end
   
   Paperclip.interpolates('deliverable_assignment_name') do |attachment, style|
     attachment.instance.deliverable.assignment.name
   end
   
   Paperclip.interpolates('deliverable_course_name') do |attachment, style|
     attachment.instance.deliverable.course.display_course_name
   end
   
   Paperclip.interpolates('deliverable_course_semester') do |attachment, style|
     attachment.instance.deliverable.course.semester
   end
   
   Paperclip.interpolates('deliverable_course_year') do |attachment, style|
     attachment.instance.deliverable.course.year
   end
   
   Paperclip.interpolates('deliverable_owner_name') do |attachment, style|
     attachment.instance.deliverable.owner_name_for_filename.parameterize.gsub('-', '_')
   
   end
   
   
   Paperclip.interpolates('page_id') do |attachment, style|
!!   attachment.instance.page.id
   end

================================================================================
 ./config/initializers/recaptcha.rb
================================================================================
   Recaptcha.configure do |config|
     config.public_key  = '6LfhP98SAAAAAMnnvCdL3ENLN5gZ1X7CkhW3G90N'
     config.private_key = '6LfhP98SAAAAAOtg1NcHbREldoWIQdt2WdsVpkVT'
   end

================================================================================
 ./config/initializers/secret_token.rb
================================================================================
   # Be sure to restart your server when you modify this file.
   
   # Your secret key for verifying the integrity of signed cookies.
   # If you change this key, all old signed cookies will become invalid!
   # Make sure the secret is at least 30 characters and all random,
   # no regular words or you'll be exposed to dictionary attacks.
   CMUEducation::Application.config.secret_token = '15a068ffeadeebfd1b1837ec0d699670873cbc40316ac3f3e1cc609517b1a0a0b061d0a3df8ababd5b790125cac09aeee64cf5720e5b56b185068715f24b2367'

================================================================================
 ./config/initializers/session_store.rb
================================================================================
   # Be sure to restart your server when you modify this file.
   
   CMUEducation::Application.config.session_store :cookie_store, :key => '_CMUEducation_session'
   
   # Use the database for sessions instead of the cookie-based default,
   # which shouldn't be used to store highly confidential information
   # (create the session table with "rails generate session_migration")
   # CMUEducation::Application.config.session_store :active_record_store
   
   #CMUEducation::Application.config.session_store :expire_after => 1.day

================================================================================
 ./config/initializers/site_keys.rb
================================================================================
   
   # A Site key gives additional protection against a dictionary attack if your
   # DB is ever compromised.  With no site key, we store
   #   DB_password = hash(user_password, DB_user_salt)
   # If your database were to be compromised you'd be vulnerable to a dictionary
   # attack on all your stupid users' passwords.  With a site key, we store
   #   DB_password = hash(user_password, DB_user_salt, Code_site_key)
   # That means an attacker needs access to both your site's code *and* its
   # database to mount an "offline dictionary attack.":http://www.dwheeler.com/secure-programs/Secure-Programs-HOWTO/web-authentication.html
   # 
   # It's probably of minor importance, but recommended by best practices: 'defense
   # in depth'.  Needless to say, if you upload this to github or the youtubes or
   # otherwise place it in public view you'll kinda defeat the point.  Your users'
   # passwords are still secure, and the world won't end, but defense_in_depth -= 1.
   # 
   # Please note: if you change this, all the passwords will be invalidated, so DO
   # keep it someplace secure.  Use the random value given or type in the lyrics to
   # your favorite Jay-Z song or something; any moderately long, unpredictable text.
   REST_AUTH_SITE_KEY         = '7cd2dc2db2cb12dfeba7fa06356bcfe2843f94b6'
     
   # Repeated applications of the hash make brute force (even with a compromised
   # database and site key) harder, and scale with Moore's law.
   #
   #   bq. "To squeeze the most security out of a limited-entropy password or
   #   passphrase, we can use two techniques [salting and stretching]... that are
   #   so simple and obvious that they should be used in every password system.
   #   There is really no excuse not to use them." http://tinyurl.com/37lb73
   #   Practical Security (Ferguson & Scheier) p350
   # 
   # A modest 10 foldings (the default here) adds 3ms.  This makes brute forcing 10
   # times harder, while reducing an app that otherwise serves 100 reqs/s to 78 signin
   # reqs/s, an app that does 10reqs/s to 9.7 reqs/s
   # 
   # More:
   # * http://www.owasp.org/index.php/Hashing_Java
   # * "An Illustrated Guide to Cryptographic Hashes":http://www.unixwiz.net/techtips/iguide-crypto-hashes.html
   
   REST_AUTH_DIGEST_STRETCHES = 10

================================================================================
 ./config/initializers/systems.rb
================================================================================
   
   TWIKI_USERNAME = ENV['WHITEBOARD_TWIKI_USERNAME'] || "AndrewCarengie"
   TWIKI_PASSWORD = ENV['WHITEBOARD_TWIKI_PASSWORD'] || "password"
   TWIKI_URL = ENV['WHITEBOARD_TWIKI_URL'] || 'http://info.sv.cmu.edu'
   

================================================================================
 ./config/initializers/time_formats.rb
================================================================================
   #See en.yml for timestamp formats
   # This allows the models to re-use the internationalization date formats
   #Date::DATE_FORMATS[:default] = lambda { |date| I18n.l(date) }

================================================================================
 ./config/initializers/vestal_versions.rb
================================================================================
   VestalVersions.configure do |config|
     # Place any global options here. For example, in order to specify your own version model to use
     # throughout the application, simply specify:
     #
     # config.class_name = "MyCustomVersion"
     #
     # Any options passed to the "versioned" method in the model itself will override this global
     # configuration.
   end

================================================================================
 ./config/initializers/wrap_parameters.rb
================================================================================
   # Be sure to restart your server when you modify this file.
   #
   # This file contains settings for ActionController::ParamsWrapper which
   # is enabled by default.
   
   # Enable parameter wrapping for JSON. You can disable this by setting :format to an empty array.
   ActiveSupport.on_load(:action_controller) do
     wrap_parameters format: [:json]
   end
   
   # Disable root element in JSON by default.
   ActiveSupport.on_load(:active_record) do
     self.include_root_in_json = false
   end

================================================================================
 ./config/routes.rb
================================================================================
   CMUEducation::Application.routes.draw do
   
   
     #temporary for Mel
     match 'courses/:course_id/team_deliverables' => 'deliverables#team_index_for_course', :as => :individual_deliverables
     match 'courses/:course_id/individual_deliverables' => 'deliverables#individual_index_for_course', :as => :team_deliverables
   
     devise_for :users, :controllers => { :omniauth_callbacks => "users/omniauth_callbacks" }
     devise_scope :user do
       get '/users/auth/:provider' => 'users/omniauth_callbacks#passthru'
       get 'logout' => 'devise/sessions#destroy', :as => :destroy_user_session
     end
   
     constraints(:host => /rails.sv.cmu.edu/) do
       match "/(*path)" => redirect {|params, req| "http://whiteboard.sv.cmu.edu/#{params[:path]}"}
     end
   
     resources :search, :only => [:index]
     #get    "/deliverables/get_assignments_for_student(.:format)" =>  "deliverables#get_assignments_for_student"
   
     resources :password_resets
   
     match '/deliverables/get_assignments_for_student(.:format)'=> 'deliverables#get_assignments_for_student' ,:as=> :get_assignments_for_student
     resources :deliverables
   
     match '/people/:id/my_deliverables' => 'deliverables#my_deliverables', :as => :my_deliverables
     match '/people/:id/my_presentations' => 'presentations#my_presentations', :as => :my_presentations
   
     match '/deliverables/:id/feedback' => 'deliverables#edit_feedback', :as => :deliverable_feedback
     match '/presentations/:id/show_feedback' => 'presentations#show_feedback', :as => :show_feedback_for_presentation, :via => :get
     match '/presentations/:id/edit_feedback' => 'presentations#update_feedback', :via => :put
     match '/presentations/:id/edit_feedback' => 'presentations#edit_feedback', :as => :edit_feedback_for_presentation, :via => :get
     match '/presentations/:id/feedback' => 'presentations#create_feedback', :via => :post
     match '/presentations/:id/feedback' => 'presentations#new_feedback', :as => :new_presentation_feedback, :via => :get
     match '/presentations/today' => 'presentations#today', :as => :today_presentations
     resources :presentations, :only => [:index]
   
     match '/jobs/assignments' => 'jobs#assignments', :as => :job_assignments
     resources :jobs
   
     match '/sponsored_projects/:id/archive' => 'sponsored_projects#archive', :as => :archive_sponsored_project
     match '/sponsored_project_sponsors/:id/archive' => 'sponsored_project_sponsors#archive', :as => :archive_sponsored_project_sponsor
     match '/sponsored_project_allocations/:id/archive' => 'sponsored_project_allocations#archive', :as => :archive_sponsored_project_allocation
     resources :sponsored_projects
     resources :sponsored_project_sponsors
     resources :sponsored_project_allocations
     resources :sponsored_project_efforts
     match 'delayed_system_jobs/' => 'delayed_system_jobs#index'
     resources :delayed_system_jobs
     resources :rss_feeds
     resources :page_comment_types
     resources :page_comments
     resources :scotty_dog_sayings
     resources :task_types
     match '/effort_logs/update_task_type_select' => 'effort_logs#update_task_type_select', :as => :update_task_type_select
     match '/effort_logs/effort_for_unregistered_courses' => 'effort_logs#effort_for_unregistered_courses'
     resources :effort_logs
     resources :effort_log_line_items
     resources :effort_log_line_items
     resources :course_numbers
     resources :course_configurations
   
     match '/courses/current_semester' => redirect("/courses/semester/#{AcademicCalendar.current_semester()}#{Date.today.year}"), :as => :current_semester
     match '/courses/next_semester' => redirect("/courses/semester/#{AcademicCalendar.next_semester()}#{AcademicCalendar.next_semester_year}"), :as => :next_semester
     match '/course/:course_id/grades/send_final_grade' => 'grades#send_final_grade', :as=>:send_final_grade, :via => :post
     match '/course/:course_id/grades/post_drafted_and_send' => 'grades#post_drafted_and_send', :as=>:post_drafted_and_send, :via => :post
     match '/course/:course_id/grades/save' => 'grades#save', :as=>:save, :via => :post
     match '/course/:course_id/grades/export' => 'grades#export', :as=>:export, :via => :post
     match '/course/:course_id/grades/import' => 'grades#import', :as=>:import, :via => :post
   
     resources :courses do
       resources :assignments
       resources :grades
     end
   
     match '/course/:course_id/assignments/reposition' => 'assignments#show', :as=>:assignments_show, :via => :get
     match '/course/:course_id/assignments/reposition' => 'assignments#reposition', :as=>:assignments_reposition, :via => :post
   
     constraints({:id => /.*/}) do
       resources :mailing_lists
       resources :pages do
         collection do
           post :reposition
           get :changed
         end
         member {post :revert}
       end
     end
   
     resources :page_attachments
   
     resources :course_navigations
     resources :courses do
       resources :teams do
       end
       member do
         get :configure
         get :tool_support
       end
       resources :presentations, :only => [:new, :edit, :create, :update]
     end
   
   
     match 'courses/semester/:semester' => 'courses#index_for_semester', :as => "semester_courses"
     match '/courses/:course_id/peer_evaluations' => 'peer_evaluation#index_for_course', :via => :get, :as => "peer_evaluations"
     match '/courses/:course_id/teams/:id/peer_evaluation' => 'teams#peer_evaluation', :via => :get, :as => "peer_evaluation"
     match '/courses/:course_id/teams/:id/peer_evaluation_update' => 'teams#peer_evaluation_update', :via => :post, :as => "peer_evaluation_update"
     match 'peer_evaluation/edit_setup/:id' => 'peer_evaluation#edit_setup', :as => :setup_peer_evaluation
     match 'peer_evaluation/edit_evaluation/:id' => 'peer_evaluation#edit_evaluation', :as => :edit_peer_evaluation
     match 'peer_evaluation/edit_report/:id' => 'peer_evaluation#edit_report', :as => :report_peer_evaluation
   
     match '/effort_reports/campus_week' => 'effort_reports#campus_week'
     match '/effort_reports/campus_semester' => 'effort_reports#campus_semester'
     match '/effort_reports/course/:course_id' => 'effort_reports#course'
     resources :effort_reports
     match '/people_autocomplete' => 'people#index_autocomplete'
     match '/people_search' => 'people#search'
   
     match '/people_csv' => 'people#download_csv'
     match '/people_vcf' => 'people#download_vcf'
   
     match '/people/class_profile' => 'people#class_profile'
     match '/people/ajax_check_if_email_exists' => 'people#ajax_check_if_email_exists'
     match '/people/ajax_check_if_webiso_account_exists' => 'people#ajax_check_if_webiso_account_exists'
     match '/people/advanced' => 'people#advanced' #Just in case anyone bookmarked this url
     match '/people/photo_book' => 'people#photo_book'
     match '/people/:id/my_courses_verbose' => 'people#my_courses_verbose', :as => :my_courses
     match '/people/:id/my_courses' => 'people#my_courses', :as => :my_courses
     match '/people/:id/my_teams' => 'people#my_teams', :as => :my_teams
     match '/people/:id/upload_photo' => 'people#upload_photo', :as => :people_photo_upload, :via => :put
     resources :people
     resources :users, :controller => 'people'
     resources :suggestions
     match '/teams' => 'teams#index_all', :as => :teams
   
   
   
     #resources :users
     #resource :user_session
   
     #match '/login_google' => 'user_sessions#login_google', :as => :login_google
     #match '/logout' => "user_sessions#destroy", :as => :logout
   
   
     match '/load_chart' => 'effort_reports#load_chart', :as => :load_chart
     match 'people/twiki/:twiki_name' => 'people#show_by_twiki'
     match 'twiki/teams' => 'teams#twiki_index'
     match 'twiki/teams/new' => 'teams#twiki_new', :via => :get
     match 'courses/:course_id/teams_photos' => 'teams#index_photos'
     match 'courses/:course_id/past_teams_list' => 'teams#past_teams_list', :as => :past_teams_list
     match 'courses/:course_id/export_to_csv_old' => 'teams#export_to_csv'
     match 'courses/:course_id/export_to_csv' => 'courses#export_to_csv'
     match 'courses/:course_id/team_formation_tool' => 'courses#team_formation_tool', :as => :team_formation_tool
     match 'courses/:course_id/student_grades' => 'grades#student_deliverables_and_grades_for_course', :as => :course_student_grades
     match 'courses/:course_id/deliverables' => 'deliverables#grading_queue_for_course', :as => :course_deliverables
     match 'courses/:course_id/get_deliverables' => 'deliverables#get_deliverables', :as => :get_deliverables
     match 'courses/:course_id/filter_deliverables' => 'deliverables#filter_deliverables', :as => :filter_deliverables
     match 'courses/:course_id/update_feedback' => 'deliverables#update_feedback', :as => :update_feedback
     match 'courses/:course_id/presentations' => 'presentations#index_for_course', :as => :course_presentations
   
   
   
     #match 'courses/:course_id/presentations/update' => 'presentations#create',:via => :post, :as => :new_course_presentation
     #match 'courses/:course_id/presentations/edit' => 'presentations#edit', :as => :new_course_presentation
     #match 'courses/:course_id/presentations/new' => 'presentations#create',:via => :post, :as => :new_course_presentation
     #match 'courses/:course_id/presentations/new' => 'presentations#new', :as => :new_course_presentation
   
     match 'effort_reports/:id/week/:week' => 'effort_reports#show_week'
     match '/:controller(/:action(/:id))'
   
     match 'static/:action' => 'static#:action'
     match '/new_features' => 'welcome#new_features', :as => :new_features
     match '/config' => 'welcome#configuration', :as => :config
     match '/' => 'welcome#index', :as => :root
   
   end
   

================================================================================
 ./lib/HUB_class_roster_handler.rb
================================================================================
   module HUBClassRosterHandler
     extend ActionView::Helpers::TextHelper
   
     def self.handle roster_text
       raise ArgumentError if roster_text.blank?
       roster_text = roster_text.gsub("\n", ' ').gsub("\r", ' ')
       parsed_courses = roster_text.split('CLASS ROSTER')
   
       unless parsed_courses.any?
!!       raise "Could not read your file, please check format."
       end
   
       users = User.all
   
       students_for_course = {}
       students_not_in_system_hash = {}
       no_courses_parsed = true
   
       parsed_courses.each do |parsed_course|
         if /Run Date: (.*) Course: (.*) Sect:\s*(\w+).*Semester: (.*)College:(.*)Department:(.*)Instructor\(s\): (.*)Name.*?_+(.*)/.match(parsed_course)
           no_courses_parsed = false
           course_number = $2.strip
           (semester, year) = AcademicCalendar.parse_HUB_semester($4.strip)
   
           student_webiso_accounts = $8.scan(/\d+\.\d.*?(\w+)/)
   
           course = Course.where(:semester => semester, :year => year, :number => course_number[0..1] + '-' + course_number[2..4]).first :include => [:registered_students]
           next unless course
           students_for_course[course] = students_for_course[course] || Set.new
           students_not_in_system_hash[course] = students_not_in_system_hash[course] || Set.new
   
           student_webiso_accounts.each do |webiso_account|
             student = users.select { |u| u.webiso_account == ("#{webiso_account[0]}@andrew.cmu.edu") }.first
             #next
             unless student
               self.email_help_about_missing_student(webiso_account[0], course)
               students_not_in_system_hash[course] << webiso_account[0]
               next
             end
             students_for_course[course] << student
           end
         end
       end
   
       if no_courses_parsed
!!       raise "Could not read your file, please check format."
       end
   
       Rails.logger.debug "Students_for_course::: #{students_for_course}"
       return self.handle_roster_changes students_for_course, students_not_in_system_hash
   #    return self.handle_roster_changes students_for_course
     end
   
     def self.handle_roster_changes students_for_course, students_not_in_system_hash
   #  def self.handle_roster_changes students_for_course
       roster_changes = {}
       changes = false
       students_for_course.each do |course, students|
         roster_changes[course] = {}
         roster_changes[course][:added] = students.to_a - course.registered_students
         roster_changes[course][:dropped] = course.registered_students - students.to_a
         roster_changes[course][:not_in_system] = students_not_in_system_hash[course]
   
         Rails.logger.debug "Added: #{roster_changes[course][:added]}"
         Rails.logger.debug "Dropped: #{roster_changes[course][:dropped]}"
   
         course.registered_students = course.registered_students - roster_changes[course][:dropped]
         course.registered_students = course.registered_students + roster_changes[course][:added]
   
         if roster_changes[course][:added].any? || roster_changes[course][:dropped].any?
           course.invalidate_distribution_list
           changes = true
         end
         course.save
       end
       Rails.logger.debug roster_changes
       self.send_emails roster_changes
       return changes
     end
   
     def self.email_help_about_missing_student webiso_account, course
       options = {:to => "todd.sedano@sv.cmu.edu", :subject => "Need to add this user #{webiso_account}@andrew.cmu.edu",
                  :message => "We were adding registered HUB users to the course #{course.name}, but they are not in the system.",
                  :url => "http://whiteboard.sv.cmu.edu/people/new?webiso_account=#{webiso_account}@andrew.cmu.edu&is_student=true",
                  :url_label => "Add person"}
       GenericMailer.email(options).deliver
     end
   
   
     def self.send_emails roster_changes
       roster_changes.each do |course, info|
         next if info[:added].blank? && info[:dropped].blank? && info[:not_in_system].blank?
         email_professors_about_added_and_dropped_students(course, info)
       end
     end
   
     def self.email_professors_about_added_and_dropped_students course, info
       faculty_emails = course.faculty.collect(&:email)
       if faculty_emails.any?
         options = {:to => faculty_emails, :subject => "Roster change for your course #{course.name}",
                    :message => self.roster_change_message(course, info[:added], info[:dropped], info[:not_in_system])}
   # The message handles this well...
   #                 :url_label => "Your course: " + course.number + " " + course.short_or_full_name,
   #                 :url => "http://whiteboard.sv.cmu.edu/courses/#{course.id}" }
       else
         options = {:to => "gerry.elizondo@sv.cmu.edu", :subject => "Please add faculty to this course",
                    :message => "The HUB importer code was just run, however this course has no faculty assigned to it. Thus, I could not email them.",
                    :url_label => "The course: " + course.number + " " + course.short_or_full_name,
                    :url => "http://whiteboard.sv.cmu.edu/courses/#{course.id}" }
       end
   
       GenericMailer.email(options).deliver
     end
   
     def self.roster_change_message course, added, dropped, not_in_system
   
       unless course
         message = "This email is supposed to contain information about course roster changes, but an error occurred while"
         message += "generating its contents.  Please contact <a href='mailto:todd.sedano@sv.cmu.edu?subject=Roster%20Email%20Error'>Todd Sedano</a>"
         return message += "to resolve any issues."
       end
   
       message = "** This is an experimental feature. ** "
       message += "The official registration list for your course can be <a href='https://acis.as.cmu.edu/grades/'>found here</a>.<br/><br/>"
       message += "By loading in HUB data we can auto create class email distribution lists. Also, if you create teams with the rails system, then you can see who has not been assigned to a team. This does not currently track students on wait-lists. We only have access to students registered in 96-xxx courses.<br/><br/>"
       message += "The HUB does not provide us with registration information on a daily basis. Periodically, we manually upload HUB registrations. This is a summary of changes since the last time we updated information from the HUB.<br/><br/>"
   
       unless not_in_system.blank?
         message += "#{pluralize(not_in_system.count, "registered student")} #{not_in_system.count > 1 ? "are" : "is"} not in any of our SV systems:<br/>"
         not_in_system.each { |student|
           escaped_student = ERB::Util.html_escape(student)
           message += "&nbsp;&nbsp;&nbsp;#{escaped_student}@andrew.cmu.edu<br/>"
         }
         message += "We can easily create accounts for #{not_in_system.count > 1 ? "these" : "this"} #{pluralize(not_in_system.count, "student")}. Please forward this email to help@sv.cmu.edu indicating which students you want added. (The rails system will create google and twiki accounts.)<br/><br/>"
       end
   
       unless added.blank?
         message += "#{pluralize(added.count, "student")} #{added.count > 1 ? "were" : "was"} added to the course:<br/>"
         added.each { |student|
           escaped_first_name = ERB::Util.html_escape(student.first_name)
           escaped_last_name = ERB::Util.html_escape(student.last_name)
           message += "&nbsp;&nbsp;&nbsp;#{escaped_first_name} #{escaped_last_name}<br/>"
         }
       end
   
       unless dropped.blank?
         message += "#{pluralize(dropped.count, "student")} #{dropped.count > 1 ? "were" : "was"} dropped from the course:<br/>"
         dropped.each { |student|
           escaped_first_name = ERB::Util.html_escape(student.first_name)
           escaped_last_name = ERB::Util.html_escape(student.last_name)
           message += "&nbsp;&nbsp;&nbsp;#{escaped_first_name} #{escaped_last_name}<br/>"
         }
       end
   
       escaped_course_email = ERB::Util.html_escape(course.email)
       message += "<br/>The system will be updating your course mailing list (#{escaped_course_email}) For more information, see your <a href='http://whiteboard.sv.cmu.edu/courses/#{course.id}'>course tools</a><br/><br/>"
   
       message
     end
   end

================================================================================
 ./lib/active_directory.rb
================================================================================
   require 'net/ldap'
   
   # This class provides active directory services
   class ActiveDirectory
   
   
     #
     # Creates an Active Directory account for the user
     # If this fails, it returns an error message as a string, else it returns true
     #
     def create_active_directory_account(user)
       # reject blank emails
!!     return "Empty email address" if user.email.blank?
   
       # log what is happening
!!     logger.debug("Attempting to create active directory account for " + user.email)
   
       # extract domain from email
!!     domain = user.email.split('@')[1]
   
       # Confirm domain name accuracy
!!     if domain != GOOGLE_DOMAIN
!!       logger.debug("Domain (" + domain + ") is not the same as the google domain (" + GOOGLE_DOMAIN)
!!       return "Domain (" + domain + ") is not the same as the google domain (" + GOOGLE_DOMAIN + ")"
       end
   
       # Attempt to create active directory account
!!     active_directory_service = ActiveDirectory.new
!!     if active_directory_service.create_account(user) == "Success"
!!       user.active_directory_account_created = Time.now()
!!       user.save
       end
     end
   
   
     # Initialize connection to active directory
     def self.initialize
!!     @connection = Net::LDAP.new(:host => LDAPConfig.host, :port => LDAPConfig.port)
!!     @connection.encryption(:method => :simple_tls) unless !LDAPConfig.is_encrypted?
!!     @connection.auth LDAPConfig.username, LDAPConfig.password unless LDAPConfig.username.nil? || LDAPConfig.password.nil?
     end
   
     # Attempt to bind to active directory, time out after N seconds, return true or false
     def bind
!!     return false unless !@connection.nil?
!!     begin
!!       Timeout::timeout(10) do
!!         return (@connection.bind) ? true : false
         end
!!     rescue Timeout::Error
!!       return false
       end
     end
   
     # Create a user account in active directory
     # Return message as "Success", "Unwilling to perform", "Entity exists" or "No such object"
     def create_account(user)
!!     if self.bind
!!       @connection.add(:dn => user.ldap_distinguished_name(user), :attributes => ldap_attributes(user))
!!       return @connection.get_operation_result.message
       else
!!       return false
       end
     end
   
     # Build attributes for active directory account
     # Code 512 creates standard user account and enables it
     def ldap_attributes(user)
!!     attributes = {
           :cn => user.human_name,
           :mail => user.email,
           :objectclass => ["top", "person", "organizationalPerson", "user"],
           :userPrincipalName => user.email,
           :unicodePwd => password_encode('Just4now' + Time.now.to_f.to_s[-4, 4]),
           :userAccountControl => "512",
           :sn => user.last_name,
           :givenName => user.first_name,
           :displayName => user.human_name
       }
!!     return attributes
     end
   
     # Build user distinguished name for active directory account
     def ldap_distinguished_name(user)
!!     distinguished_name = "cn=#{user.human_name},"
!!     base_distinguished_name = "dc=cmusv,dc=sv,dc=cmu,dc=local"
   
!!     if user.is_staff
!!       distinguished_name += "ou=Staff,ou=Sync,"
       elsif !user.masters_program.blank?
!!       distinguished_name += "ou=" + user.masters_program + ",ou=Students,ou=Sync,"
       else
!!       distinguished_name += "ou=Sync,"
       end
   
!!     distinguished_name += base_distinguished_name
!!     return distinguished_name
     end
   
     # Convert password to unicode format
     def password_encode(password)
!!     result = ""
!!     password = "\"" + password + "\""
!!     password.length.times { |i| result+= "#{password[i..i]}\000" }
!!     return result
     end
   
     # Send active directory password reset token
     def send_password_reset_token(user)
!!     user.set_password_reset_token
!!     self.password_reset_sent_at = Time.zone.now
!!     user.save!
!!     PasswordMailer.password_reset(user).deliver
     end
   
     # Reset active directory password
     def reset_password(user, new_pass)
!!     if self.bind
!!       distinguished_name = ldap_distinguished_name(user)
!!       @connection.replace_attribute distinguished_name, :unicodePwd, password_encode(new_pass)
!!       return @connection.get_operation_result.message
       else
!!       return false
       end
     end
   end

================================================================================
 ./lib/gappsprovisioning/connection.rb
================================================================================
   #!/usr/bin/ruby
   #
   # Licensed under the Apache License, Version 2.0 (the "License"); you may not
   # use this file except in compliance with the License. You may obtain a copy of
   # the License at
   #
   # http://www.apache.org/licenses/LICENSE-2.0 
   #
   # Unless required by applicable law or agreed to in writing, software
   # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   # License for the specific language governing permissions and limitations under
   # the License.
   #
   require 'net/https'
   require 'cgi'
   
   module GAppsProvisioning #:nodoc:
   	class Connection
   	attr_reader  :http_connection
   	
   		# Establishes SSL connection to Google host
   		def initialize(host, port, proxy=nil, proxy_port=nil, proxy_user=nil, proxy_passwd=nil)
   			conn = Net::HTTP.new(host, port, proxy, proxy_port, proxy_user, proxy_passwd)
   			conn.use_ssl = true
   			#conn.enable_post_connection_check=  true
   			#conn.verify_mode = OpenSSL::SSL::VERIFY_PEER
   			conn.verify_mode = OpenSSL::SSL::VERIFY_NONE 
   			# uncomment the previous line at your own risk : the certificate won't be verified !
   			store = OpenSSL::X509::Store.new
   			store.set_default_paths
   			conn.cert_store = store
   			conn.start
   			@http_connection = conn
   		end
   	
   		# Performs the http request and returns the http response
   		def perform(method, path, body=nil, header=nil)
   			req = Net::HTTPGenericRequest.new(method, !body.nil?, true, path)
   			req['Content-Type'] = header['Content-Type'] if header['Content-Type']
   			req['Authorization'] = header['Authorization'] if header['Authorization']
   			req['Content-length'] = body.length.to_s if body
   			resp = @http_connection.request(req, body)
   			return resp
   		end
   	end
   end

================================================================================
 ./lib/gappsprovisioning/exceptions.rb
================================================================================
   #!/usr/bin/ruby
   #
   # Licensed under the Apache License, Version 2.0 (the "License"); you may not
   # use this file except in compliance with the License. You may obtain a copy of
   # the License at
   #
   # http://www.apache.org/licenses/LICENSE-2.0 
   #
   # Unless required by applicable law or agreed to in writing, software
   # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   # License for the specific language governing permissions and limitations under
   # the License.
   module GAppsProvisioning #:nodoc:
   
   	class GDataError < RuntimeError
   		attr_accessor :code, :input, :reason
   	end
   end

================================================================================
 ./lib/gappsprovisioning/provisioningapi.rb
================================================================================
   #!/usr/bin/ruby
   	# == Google Apps Provisioning API client library
   	#
   	# This library allows you to manage your domain (accounts, email lists, aliases) within your Ruby code.
   	# It's based on the GDATA provisioning API v2.0.
   	# Reference : http://code.google.com/apis/apps/gdata_provisioning_api_v2.0_reference.html.
   	#
   	# All the public methods with _ruby_style_ names are aliased with _javaStyle_ names. Ex : create_user and createUser.
   	#
   	# Notice : because it uses REXML, your script using this library MUST be encoded in unicode (UTF-8).
   	#
   	# == Examples
   	#
   	#	#!/usr/bin/ruby
   	#	require 'gappsprovisioning/provisioningapi'
   	#	include GAppsProvisioning
   	#	adminuser = "root@mydomain.com"
   	#	password  = "PaSsWo4d!"
   	#	myapps = ProvisioningApi.new(adminuser,password)	
   	#	(see examples in  ProvisioningApi.new documentation for handling proxies)
   	#
   	#	new_user = myapps.create_user("jsmith", "john", "smith", "secret", nil, "2048")
   	#	puts new_user.family_name
   	#	puts new_user.given_name
   	#	
   	# Want to update a user ?
   	#
   	#	user = myapps.retrieve_user('jsmith')
   	#	user_updated = myapps.update_user(user.username, user.given_name, user.family_name, nil, nil, "true")
   	#
   	# Want to add an alias or nickname ?
   	#
   	#  	new_nickname = myapps.create_nickname("jsmith", "john.smith")
   	#
   	# Want to manage groups ? (i.e. mailing lists)
   	#
   	#     new_group = myapps.create_group("sales-dep", ['Sales Departement'])
   	#     new_member = myapps.add_member_to_group("jsmith", "sales-dep")
   	#     new_owner = myapps.add_owner_to_group("jsmith", "sales-dep")
   	#     (ATTENTION: an owner is added only if it's already member of the group!)
   	#
   	# Want to handle errors ?
   	#
   	#	begin
   	#		user = myapps.retrieve_user('noone')
   	#		puts "givenName : "+user.given_name, "familyName : "+user.family_name, "username : "+user.username"
   	#		puts "admin ? : "+user.admin
   	#	rescue GDataError => e
   	#		puts "errorcode = " +e.code, "input : "+e.input, "reason : "+e.reason
   	#	end
   	#
   	# Email lists (deprecated) ?
   	#
   	# 	new_list = myapps.create_email_list("sales-dep")
   	# 	new_address = myapps.add_address_to_email_list("sales-dep", "bibi@ruby-forge.org")
   	#
           # All methods described in the GAppsProvisioning::ProvisioningApi class documentation.
           #
   	# Authors :: Jrme Bousqui, Roberto Cerigato
   	# Ruby version :: from 1.8.6
   	# Licence :: Apache Licence, version 2
   #
   # Licensed under the Apache License, Version 2.0 (the "License"); you may not
   # use this file except in compliance with the License. You may obtain a copy of
   # the License at
   #
   # http://www.apache.org/licenses/LICENSE-2.0 
   #
   # Unless required by applicable law or agreed to in writing, software
   # distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   # WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
   # License for the specific language governing permissions and limitations under
   # the License.
   #
   
   require 'cgi'
   require 'rexml/document'
   
   require 'gappsprovisioning/connection'
   require 'gappsprovisioning/exceptions'
   
   include REXML
   
   
   
   module GAppsProvisioning #:nodoc:
   
   	# =Administrative object for accessing your domain
   	# Examples
   	#
   	#	adminuser = "root@mydomain.com"
   	#	password  = "PaSsWo4d!"
   	#	myapps = ProvisioningApi.new(adminuser,password)	
   	#	(see examples in  ProvisioningApi.new documentation for handling proxies)
   	#
   	#	new_user = myapps.create_user("jsmith", "john", "smith", "secret", nil, "2048")
   	#	puts new_user.family_name
   	#	puts new_user.given_name
   	#	
   	# Want to update a user ?
   	#
   	#	user = myapps.retrieve_user('jsmith')
   	#	user_updated = myapps.update_user(user.username, user.given_name, user.family_name, nil, nil, "true")
   	#
   	# Want to add an alias or nickname ?
   	#
   	#  	new_nickname = myapps.create_nickname("jsmith", "john.smith")
   	#
   	# Want to manage groups ? (i.e. mailing lists)
   	#
   	# 	new_group = myapps.create_group("sales-dep", ['Sales Departement'])
   	# 	new_member1 = myapps.add_member_to_group("john.doe@somedomain.com", "sales-dep")
   	# 	new_member2 = myapps.add_member_to_group("jsmith", "sales-dep")
   	# 	new_owner = myapps.add_owner_to_group("jsmith", "sales-dep")
           #               (ATTENTION: an owner is added only if it's already member of the group!)
           #
   	#
   	# Want to handle errors ?
   	#
   	#	begin
   	#		user = myapps.retrieve_user('noone')
   	#		puts "givenName : "+user.given_name, "familyName : "+user.family_name, "username : "+user.username"
   	#		puts "admin ? : "+user.admin
   	#	rescue GDataError => e
   	#		puts "errorcode = " +e.code, "input : "+e.input, "reason : "+e.reason
   	#	end
   	#
           #
   
   
   
   	class ProvisioningApi
   		@@google_host = 'apps-apis.google.com'
   		@@google_port = 443
   		# authentication token, valid up to 24 hours after the last connection
   		attr_reader :token
   
   
   	        # Creates a new ProvisioningApi object
   	        #
   	        # 	mail : Google Apps domain administrator e-mail (string)
   	        # 	passwd : Google Apps domain administrator password (string)
   	        # 	proxy : (optional) host name, or IP, of the proxy (string)
   	        # 	proxy_port : (optional) proxy port number (numeric)
   	        # 	proxy_user : (optional) login for authenticated proxy only (string)
   	        # 	proxy_passwd : (optional) password for authenticated proxy only (string)
   	        #
   	        # The domain name is extracted from the mail param value.
   	        #
   	        # Examples :
   	        # 	standard : no proxy
   	        # 	myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   	        # 	proxy :
   	        # 	myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd','domain.proxy.com',8080)
   	        # 	authenticated proxy :
   	        # 	myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd','domain.proxy.com',8080,'foo','bAr')
   		def initialize(mail, passwd, proxy=nil, proxy_port=nil, proxy_user=nil, proxy_passwd=nil)
   			domain = mail.split('@')[1]
   			@action = setup_actions(domain)
   			conn = Connection.new(@@google_host, @@google_port, proxy, proxy_port, proxy_user, proxy_passwd)
   			@connection = conn
   			@token = login(mail, passwd)
   			@headers = {'Content-Type'=>'application/atom+xml', 'Authorization'=> 'GoogleLogin auth='+token}
   			return @connection
   		end
   	
   		
   	
   		# Returns a UserEntry instance from a username
   		# 	ex :	
   		#			myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#			user = myapps.retrieve_user('jsmith')
   		#			puts "givenName : "+user.given_name
   		#			puts "familyName : "+user.family_name
   		def retrieve_user(username)
!! 			xml_response = request(:user_retrieve, username, @headers) 
!! 			user_entry = UserEntry.new(xml_response.elements["entry"])
   		end
    
   		# Returns a UserEntry array populated with all the users in the domain. May take a while depending on the number of users in your domain.
   		# 	ex : 	
   		#			myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#			list= myapps.retrieve_all_users
   		#			list.each{ |user| puts user.username} 
   		#			puts 'nb users : ',list.size
   		def retrieve_all_users
!! 			response = request(:user_retrieve_all,nil,@headers)
!! 			user_feed = Feed.new(response.elements["feed"],  UserEntry)
!! 			user_feed = add_next_feeds(user_feed, response, UserEntry)
   		end
   
   		# Returns a UserEntry array populated with 100 users, starting from a username
   		# 	ex : 	
   		#			myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#			list= myapps.retrieve_page_of_users("jsmtih")
   		#  		list.each{ |user| puts user.username}
   		def retrieve_page_of_users(start_username)
!! 			param='?startUsername='+start_username
!! 			response = request(:user_retrieve_all,param,@headers)
!! 			user_feed = Feed.new(response.elements["feed"],  UserEntry)
   		end
    
   		# Creates an account in your domain, returns a UserEntry instance
   		# 	params :
   		#			username, given_name, family_name and password are required
   		#			passwd_hash_function (optional) : nil (default) or "SHA-1"
   		#			quota (optional) : nil (default) or integer for limit in MB
   		# 	ex : 	
   		#			myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#			user = myapps.create('jsmith', 'John', 'Smith', 'p455wD')
   		#
   		# By default, a new user must change his password at first login. Please use update_user if you want to change this just after the creation.
   		def create_user(username, given_name, family_name, password, passwd_hash_function=nil, quota=nil)
!! 			msg = RequestMessage.new
!! 			msg.about_login(username,password,passwd_hash_function,"false","false", "true")
!! 			msg.about_name(family_name, given_name)
!! 			msg.about_quota(quota.to_s) if quota
!! 			response  = request(:user_create,nil,@headers, msg.to_s)
!! 			user_entry = UserEntry.new(response.elements["entry"])
   		end
   
   		# Updates an account in your domain, returns a UserEntry instance
   		# 	params :
   		#			username is required and can't be updated.
   		#			given_name and family_name are required, may be updated.
   		#			if set to nil, every other parameter won't update the attribute.
   		#				passwd_hash_function :  string "SHA-1", "MD5" or nil (default)
   		#				admin :  string "true" or string "false" or nil (no boolean : true or false). 
   		#				suspended :  string "true" or string "false" or nil (no boolean : true or false)
   		#				change_passwd :  string "true" or string "false" or nil (no boolean : true or false)
   		#				quota : limit en MB, ex :  string "2048"
   		#		ex :
   		#			myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#			user = myapps.update('jsmith', 'John', 'Smith', nil, nil, "true", nil, "true", nil)
   		#			puts user.admin		=> "true"
   		def update_user(username, given_name, family_name, password=nil, passwd_hash_function=nil, admin=nil, suspended=nil, changepasswd=nil, quota=nil)
!! 			msg = RequestMessage.new
!! 			msg.about_login(username,password,passwd_hash_function,admin,suspended, changepasswd)
!! 			msg.about_name(family_name, given_name)
!! 			msg.about_quota(quota) if quota
!! 			msg.add_path('https://'+@@google_host+@action[:user_update][:path]+username)
!! 			response  = request(:user_update,username,@headers, msg.to_s)
!! 			user_entry = UserEntry.new(response.elements["entry"])
   		end
   		
   		# Renames a user, returns a UserEntry instance
   		#		ex :
   		#
   		#			myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#			user = myapps.rename_user('jsmith','jdoe')
   		#
   		#		It is recommended to log out rhe user from all browser sessions and service before renaming.
   		#              Once renamed, the old username becomes a nickname of the new username.
   		#		Note from Google: Google Talk will lose all remembered chat invitations after renaming. 
   		#		The user must request permission to chat with friends again. 
   		# 		Also, when a user is renamed, the old username is retained as a nickname to ensure continuous mail delivery in the case of email forwarding settings. 
   		#		To remove the nickname, you should issue an HTTP DELETE to the nicknames feed after renaming.
   		def rename_user(username, new_username)
!! 			msg = RequestMessage.new
!! 			msg.about_login(new_username)
!! 			msg.add_path('https://'+@@google_host+@action[:user_rename][:path]+username)
!! 			response  = request(:user_update,username,@headers, msg.to_s)
   		end
   	
   		# Suspends an account in your domain, returns a UserEntry instance
   		#		ex :
   		#			myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#			user = myapps.suspend('jsmith')
   		#			puts user.suspended		=> "true"
   		def suspend_user(username)
!! 			msg = RequestMessage.new
!! 			msg.about_login(username,nil,nil,nil,"true")
!! 			msg.add_path('https://'+@@google_host+@action[:user_update][:path]+username)
!! 			response  = request(:user_update,username,@headers, msg.to_s)
!! 			user_entry = UserEntry.new(response.elements["entry"])
   		end
   
   		# Restores a suspended account in your domain, returns a UserEntry instance
   		#		ex :
   		#			myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#			user = myapps.restore('jsmith')
   		#			puts user.suspended		=> "false"
   		def restore_user(username)
!! 			msg = RequestMessage.new
!! 			msg.about_login(username,nil,nil,nil,"false")
!! 			msg.add_path('https://'+@@google_host+@action[:user_update][:path]+username)
!! 			response  = request(:user_update,username,@headers, msg.to_s)
!! 			user_entry = UserEntry.new(response.elements["entry"])
   		end
   
   		# Deletes an account in your domain
   		#		ex :
   		#			myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#			myapps.delete('jsmith')
   		def delete_user(username)
!! 			response  = request(:user_delete,username,@headers)
   		end
   
   		# Returns a NicknameEntry instance from a nickname
   		# 	ex :	
   		#			myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#			nickname = myapps.retrieve_nickname('jsmith')
   		#			puts "login : "+nickname.login
   		def retrieve_nickname(nickname)
!! 			xml_response = request(:nickname_retrieve, nickname, @headers)
!! 			nickname_entry = NicknameEntry.new(xml_response.elements["entry"])
   		end
   	
   		# Returns a NicknameEntry array from a username
   		#	ex : lists jsmith's nicknames
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		# 		mynicks = myapps.retrieve('jsmith')
   		#		mynicks.each {|nick| puts nick.nickname }
   		def retrieve_nicknames(username)
!! 			xml_response = request(:nickname_retrieve_all_for_user, username, @headers)
!! 			nicknames_feed = Feed.new(xml_response.elements["feed"],  NicknameEntry)
!! 			nicknames_feed = add_next_feeds(nicknames_feed, xml_response, NicknameEntry)
   		end
   	
   		# Returns a NicknameEntry array for the whole domain. May take a while depending on the number of users in your domain.
   		#	myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		# 	allnicks = myapps.retrieve_all_nicknames
   		# 	allnicks.each {|nick| puts nick.nickname }
   		def retrieve_all_nicknames
!! 			xml_response = request(:nickname_retrieve_all_in_domain, nil, @headers)
!! 			nicknames_feed = Feed.new(xml_response.elements["feed"],  NicknameEntry)
!! 			nicknames_feed = add_next_feeds(nicknames_feed, xml_response, NicknameEntry)
   		end
   
   		# Creates a nickname for the username in your domain and returns a NicknameEntry instance
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		# 		mynewnick = myapps.create_nickname('jsmith', 'john.smith')
   		def create_nickname(username,nickname)
!! 			msg = RequestMessage.new
!! 			msg.about_login(username)
!! 			msg.about_nickname(nickname)
!! 			response  = request(:nickname_create,nil,@headers, msg.to_s)
!! 			nickname_entry = NicknameEntry.new(response.elements["entry"])
   		end
   		
   		# Deletes the nickname  in your domain 
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		# 		myapps.delete_nickname('john.smith')
   		def delete_nickname(nickname)
!! 			response  = request(:nickname_delete,nickname,@headers)
   		end
   	
   		# Returns a NicknameEntry array populated with 100 nicknames, starting from a nickname
   		# 	ex : 	
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#		list= myapps.retrieve_page_of_nicknames("joe")
   		#  		list.each{ |nick| puts nick.login}
   		def retrieve_page_of_nicknames(start_nickname)
!! 			param='?startNickname='+start_nickname
!! 			xml_response = request(:nickname_retrieve_all_in_domain, param, @headers)
!! 			nicknames_feed = Feed.new(xml_response.elements["feed"],  NicknameEntry)
   		end
   	
   		# Deprecated. Please use Group management instead.
   		def retrieve_email_lists(email_adress)
!! 			puts("retrieve_email_lists : deprecated. Please use Group management instead.")
   		end	  
   	
   		# Deprecated. Please use Group management instead.
   		def retrieve_all_email_lists
!! 			puts("retrieve_all_email_lists : deprecated. Please use Group management instead.")
   		end
   	
   		# Deprecated. Please use Group management instead.
   		def retrieve_page_of_email_lists(start_listname)
!! 			puts("retrieve_page_of_email_lists : deprecated. Please use Group management instead.")
   		end
   		
   		# Deprecated. Please use Group management instead.
   		def create_email_list(name)
!! 			puts("create_email_list : deprecated. Please use Group management instead.")
   		end
   
   		# Deprecated. Please use Group management instead.
   		def delete_email_list(name)
!! 			puts("delete_email_list : deprecated. Please use Group management instead.")
   		end
   	
   		# Deprecated. Please use Group management instead.
   		def retrieve_all_recipients(email_list)
!! 			puts("retrieve_all_recipients : deprecated. Please use Group management instead.")
   		end
   	
   		# Deprecated. Please use Group management instead.
   		def retrieve_page_of_recipients(email_list, start_recipient)
!! 			puts("Deprecated. Please use Group management instead.")
   		end
   	
   		# Deprecated. Please use Group management instead.
   		def add_address_to_email_list(email_list,address)
!! 			puts("add_address_to_email_list : deprecated. Please use Group management instead.")
   		end
   	
   		# Deprecated. Please use Group management instead.
   		def remove_address_from_email_list(address,email_list)
!! 			puts("remove_address_from_email_list : deprecated. Please use Group management instead.")
   		end
                  
   		# Creates a group in your domain and returns a GroupEntry (ATTENTION: the group name is necessary!).
   		# 	ex : 	
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#		group= myapps.create_group("mygroup", ["My Group name", "My Group description", "<emailPermission>"]) 
   		def create_group(group_id, properties)
!! 			msg = RequestMessage.new
!! 			msg.about_group(group_id, properties)
!! 			response  = request(:group_create, nil, @headers, msg.to_s)
!! 			group_entry = GroupEntry.new(response.elements["entry"])
   		end
   
   		# Updates a group in your domain and returns a GroupEntry (ATTENTION: the group name is necessary!).
   		# 	ex : 	
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#		group= myapps.update_group("mygroup", ["My Group name", "My Group description", "<emailPermission>"]) 
   		def update_group(group_id, properties)
!! 			msg = RequestMessage.new
!! 			msg.about_group(group_id, properties)
!! 			response  = request(:group_update, group_id, @headers, msg.to_s)
!! 			group_entry = GroupEntry.new(response.elements["entry"])
   		end
   
   		# Deletes a group in your domain.
   		# 	ex : 	
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#		myapps.delete_group("mygroup")
   		def delete_group(group_id)
!! 			response  = request(:group_delete,group_id,@headers)
   		end
   
   		# Returns a GroupEntry array for a particular member of the domain (ATTENTION: it doesn't work for members of other domains!).
                   # The user parameter can be a complete email address or can be written without "@mydomain.com".
   		# 	ex :	
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#		mylists = myapps.retrieve_groups('jsmith')   # you can search for 'jsmith@mydomain.com' too
   		# 		mylists.each {|list| puts list.group_id }
   		def retrieve_groups(user)
!! 			xml_response = request(:groups_retrieve, user, @headers)
!! 			list_feed = Feed.new(xml_response.elements["feed"], GroupEntry) 
!! 			list_feed = add_next_feeds(list_feed, xml_response, GroupEntry)
   		end	  
   
   		# Returns a GroupEntry array for the whole domain.
   		# 	ex :	
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#		all_lists = myapps.retrieve_all_groups
   		# 		all_lists.each {|list| puts list.group_id }
   		def retrieve_all_groups
!! 			xml_response = request(:all_groups_retrieve, nil, @headers)
!! 			list_feed = Feed.new(xml_response.elements["feed"], GroupEntry) 
!! 			list_feed = add_next_feeds(list_feed, xml_response, GroupEntry)
   		end
   	
   		# Adds an email address (user or group) to a mailing list in your domain and returns a MemberEntry instance.
   		# You can add addresses from other domains to your mailing list.  Omit "@mydomain.com" in the group name.
   		#	ex :
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#		new_member = myapps.add_member_to_group('example@otherdomain.com', 'mygroup')
   		def add_member_to_group(email_address, group_id)
!! 			msg = RequestMessage.new
!! 			msg.about_member(email_address)
!! 			response  = request(:membership_add, group_id+'/member', @headers, msg.to_s)
!! 			member_entry = MemberEntry.new(response.elements["entry"])
   		end
   	
   		# Removes an email address (user or group) from a mailing list. Omit "@mydomain.com" in the group name.
   		# 	ex :
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#		myapps.remove_member_from_group('example@otherdomain.com', 'mygroup')
   		def remove_member_from_group(email_address, group_id)
!! 			response  = request(:membership_remove, group_id+'/member/'+email_address,@headers)
   		end
   
   		# Returns true if the email address (user or group) is member of the group, false otherwise.
   		# 	ex :	
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#		boolean = myapps.is_member('example@otherdomain.com', 'mylist')
   		def is_member(email_address, group_id)
!! 			xml_response = request(:membership_confirm, group_id+'/member/'+email_address, @headers)
                           # if the email_address is not member of the group, an error is raised, otherwise true is returned 
!!                         return true
   
                           rescue GDataError => e
!!                         return false if e.reason.eql?("EntityDoesNotExist")
   		end
   
   		# Returns a MemberEntry array with the members of a group.
   		# 	ex :	
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#		list = myapps.retrieve_all_members('mygroup')
   		# 		lists.each {|list| puts list.member_id }
   		def retrieve_all_members(group_id)
!! 			xml_response = request(:all_members_retrieve, group_id+'/member', @headers)
!! 			list_feed = Feed.new(xml_response.elements["feed"], MemberEntry)
!! 			list_feed = add_next_feeds(list_feed, xml_response, MemberEntry)
   		end
   	
   		# Adds a owner (user or group) to a mailing list in your domain and returns a OwnerEntry instance.
   		# You can add addresses from other domains to your mailing list.  Omit "@mydomain.com" in the group name.
                   # ATTENTION: a owner is added only if it's already member of the group, otherwise no action is done!
   		#	ex :
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#		new_member = myapps.add_owner_to_group('example@otherdomain.com', 'mygroup')
   		def add_owner_to_group(email_address, group_id)
!! 			msg = RequestMessage.new
!! 			msg.about_owner(email_address)
!! 			response  = request(:ownership_add, group_id+'/owner', @headers, msg.to_s)
!! 			owner_entry = OwnerEntry.new(response.elements["entry"])
   		end
   	
   		# Removes an owner from a mailing list. Omit "@mydomain.com" in the group name.
                   # ATTENTION: when a owner is removed, it loses the privileges but still remains member of the group!
   		# 	ex :
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#		myapps.remove_owner_from_group('example@otherdomain.com', 'mygroup')
   		def remove_owner_from_group(email_address, group_id)
!! 			response  = request(:ownership_remove, group_id+'/owner/'+email_address,@headers)
   		end
   
   		# Returns true if the email address (user or group) is owner of the group, false otherwise.
   		# 	ex :	
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#		boolean = myapps.is_owner('example@otherdomain.com', 'mylist')
   		def is_owner(email_address, group_id)
!! 			xml_response = request(:ownership_confirm, group_id+'/owner/'+email_address, @headers)
                           # if the email_address is not member of the group, an error is raised, otherwise true is returned 
!!                         return true
   
                           rescue GDataError => e
!!                         return false if e.reason.eql?("EntityDoesNotExist")
   		end
   
   		# Returns a OwnerEntry array with the owners of a group.
   		# 	ex :	
   		#		myapps = ProvisioningApi.new('root@mydomain.com','PaSsWoRd')
   		#		list = myapps.retrieve_all_owners('mygroup')
   		# 		lists.each {|list| puts list.owner_id }
   		def retrieve_all_owners(group_id)
!! 			xml_response = request(:all_owners_retrieve, group_id+'/owner', @headers)
!! 			list_feed = Feed.new(xml_response.elements["feed"], OwnerEntry)
!! 			list_feed = add_next_feeds(list_feed, xml_response, OwnerEntry)
   		end
   	
   		# Aliases
   		alias createUser create_user
   		alias retrieveUser retrieve_user
   		alias retrieveAllUsers retrieve_all_users
   		alias retrievePageOfUsers retrieve_page_of_users
   		alias updateUser update_user
   		alias renameUser rename_user
   		alias suspendUser suspend_user
   		alias restoreUser restore_user
   		alias deleteUser delete_user
   		alias createNickname create_nickname
   		alias retrieveNickname retrieve_nickname
   		alias retrieveNicknames retrieve_nicknames
   		alias retrieveAllNicknames retrieve_all_nicknames
   		alias retrievePageOfNicknames retrieve_page_of_nicknames
   		alias deleteNickname delete_nickname
   		alias retrieveAllRecipients retrieve_all_recipients
   		alias retrievePageOfRecipients retrieve_page_of_recipients
   		alias removeRecipientFromEmailList remove_address_from_email_list        
                   alias createGroup create_group
                   alias updateGroup update_group
                   alias deleteGroup delete_group
                   alias retrieveGroups retrieve_groups
                   alias retrieveAllGroups retrieve_all_groups
                   alias addMemberToGroup add_member_to_group
                   alias removeMemberFromGroup remove_member_from_group
                   alias isMember is_member
                   alias retrieveAllMembers retrieve_all_members
                   alias addOwnerToGroup add_owner_to_group
                   alias removeOwnerFromGroup remove_owner_from_group
                   alias isOwner is_owner
                   alias retrieveAllOwners retrieve_all_owners
   
   
   		# private methods
   		private #:nodoc:
   		
   		# Associates methods, http verbs and URL for REST access
   		def setup_actions(domain)
   			path_user = '/a/feeds/'+domain+'/user/2.0'
   			path_nickname = '/a/feeds/'+domain+'/nickname/2.0'
   			path_group = '/a/feeds/group/2.0/'+domain # path for Google groups
   
   			action = Hash.new
   			action[:domain_login] = {:method => 'POST', :path => '/accounts/ClientLogin' }
   			action[:user_create] = { :method => 'POST', :path => path_user }
   			action[:user_retrieve] = { :method => 'GET', :path => path_user+'/' }
   			action[:user_retrieve_all] = { :method => 'GET', :path => path_user } 
   			action[:user_update] = { :method => 'PUT', :path => path_user +'/' }
   			action[:user_rename] = { :method => 'PUT', :path => path_user +'/' }
   			action[:user_delete] = { :method => 'DELETE', :path => path_user +'/' }
   			action[:nickname_create] = { :method => 'POST', :path =>path_nickname }
   			action[:nickname_retrieve] = { :method => 'GET', :path =>path_nickname+'/' }
   			action[:nickname_retrieve_all_for_user] = { :method => 'GET', :path =>path_nickname+'?username=' }
   			action[:nickname_retrieve_all_in_domain] = { :method => 'GET', :path =>path_nickname }
   			action[:nickname_delete] = { :method => 'DELETE', :path =>path_nickname+'/' }
   			action[:group_create] = { :method => 'POST', :path =>path_group }
   			action[:group_update] = { :method => 'PUT', :path =>path_group+'/' }
   			action[:group_delete] = { :method => 'DELETE', :path =>path_group+'/' }
   			action[:groups_retrieve] = { :method => 'GET', :path =>path_group+'?member=' }
   			action[:all_groups_retrieve] = { :method => 'GET', :path =>path_group }
   			action[:membership_add] = { :method => 'POST', :path =>path_group+'/' }
   			action[:membership_remove] = { :method => 'DELETE', :path =>path_group+'/' }
   			action[:membership_confirm] = { :method => 'GET', :path =>path_group+'/' }
   			action[:all_members_retrieve] = { :method => 'GET', :path =>path_group+'/' }
   			action[:ownership_add] = { :method => 'POST', :path =>path_group+'/' }
   			action[:ownership_remove] = { :method => 'DELETE', :path =>path_group+'/' }
   			action[:ownership_confirm] = { :method => 'GET', :path =>path_group+'/' }
   			action[:all_owners_retrieve] = { :method => 'GET', :path =>path_group+'/' }
   	
   			# special action "next" for linked feed results. :path will be affected with URL received in a link tag.
   			action[:next] = {:method => 'GET', :path =>nil }
   			return action  	
   		end		
   	
   		# Sends credentials and returns an authentication token
   		def login(mail, passwd)
   			request_body = '&Email='+CGI.escape(mail)+'&Passwd='+CGI.escape(passwd)+'&accountType=HOSTED&service=apps'
   			res = request(:domain_login, nil, {'Content-Type'=>'application/x-www-form-urlencoded'}, request_body)
   			return /^Auth=(.+)$/.match(res.to_s)[1]
   			# res.to_s needed, because res.class is REXML::Document
   		end
   	
   
   	        # Completes the feed by following et requesting the URL links
   		def add_next_feeds(current_feed, xml_content, element_class)
!! 			xml_content.elements.each("feed/link") {|link|
!! 			if link.attributes["rel"] == "next"
!! 				@action[:next] = {:method => 'GET', :path=> link.attributes["href"]}
!! 				next_response = request(:next,nil,@headers)
!! 				current_feed.concat(Feed.new(next_response.elements["feed"], element_class))
!! 				current_feed = add_next_feeds(current_feed, next_response, element_class)
   			end
   			}
!! 			return current_feed
   		end
   
   		# Perfoms a REST request based on the action hash (cf setup_actions)
   		# ex : request (:user_retrieve, 'jsmith') sends a http GET www.google.com/a/feeds/domain/user/2.0/jsmith	
   		# returns  REXML Document
   		def request(action, value=nil, header=nil, message=nil)
   			#param value : value to be concatenated to action path ex: GET host/path/value
   			method = @action[action][:method]
   			value = '' if !value
   			path = @action[action][:path]+value
   			response = @connection.perform(method, path, message, header)
   			response_xml = Document.new(response.body)
   			test_errors(response_xml)
   			return response_xml
   		end
   
   		# parses xml response for an API error tag. If an error, constructs and raises a GDataError.
   		def test_errors(xml)
   			error = xml.elements["AppsForYourDomainErrors/error"]
   			if  error
!! 			gdata_error = GDataError.new
!! 			gdata_error.code = error.attributes["errorCode"]
!! 			gdata_error.input = error.attributes["invalidInput"]
!! 			gdata_error.reason = error.attributes["reason"]
!! 			msg = "error code : "+gdata_error.code+", invalid input : "+gdata_error.input+", reason : "+gdata_error.reason
!! 			raise gdata_error, msg
   			end
   		end
   	end
   
   
   	# UserEntry object.
   	#
   	# Handles API responses relative to a user
   	#
   	# Attributes :
   	#	username : string
   	#	given_name : string
   	#	family_name : string
   	#	suspended : string "true" or string "false"
   	#	ip_whitelisted : string "true" or string "false"
   	#	admin : string "true" or string "false"
   	#	change_password_at_next_login : string "true" or string "false"
   	#	agreed_to_terms : string "true" or string "false"
   	#	quota_limit : string (value in MB)
   	class UserEntry  
   	attr_reader :given_name, :family_name, :username, :suspended, :ip_whitelisted, :admin, :change_password_at_next_login, :agreed_to_terms, :quota_limit
   	
   		# UserEntry constructor. Needs a REXML::Element <entry> as parameter
   		def initialize(entry) #:nodoc:
!! 			@family_name = entry.elements["apps:name"].attributes["familyName"]
!! 			@given_name = entry.elements["apps:name"].attributes["givenName"]
!! 			@username = entry.elements["apps:login"].attributes["userName"]
!! 			@suspended = entry.elements["apps:login"].attributes["suspended"]
!! 			@ip_whitelisted = entry.elements["apps:login"].attributes["ipWhitelisted"]
!! 			@admin = entry.elements["apps:login"].attributes["admin"]
!! 			@change_password_at_next_login = entry.elements["apps:login"].attributes["changePasswordAtNextLogin"]
!! 			@agreed_to_terms = entry.elements["apps:login"].attributes["agreedToTerms"]
!! 			@quota_limit = entry.elements["apps:quota"].attributes["limit"]
   		end
   	end
   
   
   	# NicknameEntry object.
   	#
   	# Handles API responses relative to a nickname
   	#
   	# Attributes :
   	#	login : string
   	#	nickname : string
   	class NicknameEntry
   	attr_reader :login, :nickname
   	
   		# NicknameEntry constructor. Needs a REXML::Element <entry> as parameter
   		def initialize(entry) #:nodoc:
!! 		@login = entry.elements["apps:login"].attributes["userName"]
!! 		@nickname = entry.elements["apps:nickname"].attributes["name"]
   		end	
   	end
   
   
   	# UserFeed object : Array populated with Element_class objects (UserEntry, NicknameEntry, EmailListEntry or EmailListRecipientEntry)
   	class Feed < Array #:nodoc:
   	
   		# UserFeed constructor. Populates an array with Element_class objects. Each object is an xml <entry> parsed from the REXML::Element <feed>.
   		# Ex : user_feed = Feed.new(xml_feed, UserEntry)
   		#	    	nickname_feed = Feed.new(xml_feed, NicknameEntry)
   		def initialize(xml_feed, element_class)
!! 			xml_feed.elements.each("entry"){ |entry| self << element_class.new(entry) }
   		end
   	end
   
   
   
   	# GroupEntry object.
   	#
   	# Handles API responses relative to a group.
   	#
   	# Attributes :
   	#	group_id : string . The group_id is written without "@" and everything following.
   	class GroupEntry
   	attr_reader :group_id
   	
   		# GroupEntry constructor. Needs a REXML::Element <entry> as parameter
   		def initialize(entry) #:nodoc:
!! 		entry.elements.each("apps:property"){ |e| @group_id = e.attributes["value"] if e.attributes["name"].eql?("groupId") }
   		end	
   	end
   
   
   	# MemberEntry object.
   	#
   	# Handles API responses relative to a meber of a group.
   	#
   	# Attributes :
   	#	member_id : string . The member_id is a complete email address.
   	class MemberEntry
   	attr_reader :member_id
   	
   		# MemberEntry constructor. Needs a REXML::Element <entry> as parameter
   		def initialize(entry) #:nodoc:
!! 		entry.elements.each("apps:property"){ |e| @member_id = e.attributes["value"] if e.attributes["name"].eql?("memberId") }
   		end	
   	end
   
   
   	# OwnerEntry object.
   	#
   	# Handles API responses relative to a owner of a group.
   	#
   	# Attributes :
   	#	owner_id : string . The owner_id is a complete email address.
   	class OwnerEntry
   	attr_reader :owner_id
   	
   		# OwnerEntry constructor. Needs a REXML::Element <entry> as parameter
   		def initialize(entry) #:nodoc:
!! 		entry.elements.each("apps:property"){ |e| @owner_id = e.attributes["value"] if e.attributes["name"].eql?("email") }
   		end	
   	end
   
   
   	class RequestMessage < Document #:nodoc:
   		# Request message constructor.
   		# parameter type : "user", "nickname" or "emailList"  
   		
   		# creates the object and initiates the construction
   		def initialize
!! 			super '<?xml version="1.0" encoding="UTF-8"?>' 
!! 			self.add_element "atom:entry", {"xmlns:apps" => "http://schemas.google.com/apps/2006",
   								"xmlns:gd" => "http://schemas.google.com/g/2005",
   								"xmlns:atom" => "http://www.w3.org/2005/Atom"}
!! 			self.elements["atom:entry"].add_element "atom:category", {"scheme" => "http://schemas.google.com/g/2005#kind"}
   		end
    
   		# adds <atom:id> element in the message body. Url is inserted as a text.
   		def add_path(url)
!! 			self.elements["atom:entry"].add_element "atom:id"
!! 			self.elements["atom:entry/atom:id"].text = url
   		end
    
   		# adds <apps:emailList> element in the message body.
   		def about_email_list(email_list)
!! 			self.elements["atom:entry/atom:category"].add_attribute("term", "http://schemas.google.com/apps/2006#emailList")
!! 			self.elements["atom:entry"].add_element "apps:emailList", {"name" => email_list } 
   		end
    
   		# adds <apps:property> element in the message body for a group.
   		def about_group(group_id, properties)
!! 			self.elements["atom:entry/atom:category"].add_attribute("term", "http://schemas.google.com/apps/2006#emailList")
!! 			self.elements["atom:entry"].add_element "apps:property", {"name" => "groupId", "value" => group_id } 
!! 			self.elements["atom:entry"].add_element "apps:property", {"name" => "groupName", "value" => properties[0] } 
!! 			self.elements["atom:entry"].add_element "apps:property", {"name" => "description", "value" => properties[1] } 
!! 			self.elements["atom:entry"].add_element "apps:property", {"name" => "emailPermission", "value" => properties[2] } 
   		end
   
   		# adds <apps:property> element in the message body for a member.
   		def about_member(email_address)
!! 			self.elements["atom:entry/atom:category"].add_attribute("term", "http://schemas.google.com/apps/2006#user")
!! 			self.elements["atom:entry"].add_element "apps:property", {"name" => "memberId", "value" => email_address } 
                   end
    
   		# adds <apps:property> element in the message body for an owner.
   		def about_owner(email_address)
!! 			self.elements["atom:entry/atom:category"].add_attribute("term", "http://schemas.google.com/apps/2006#user")
!! 			self.elements["atom:entry"].add_element "apps:property", {"name" => "email", "value" => email_address } 
                   end
   
   
   		# adds <apps:login> element in the message body.
   		# warning : if valued admin, suspended, or change_passwd_at_next_login must be the STRINGS "true" or "false", not the boolean true or false
   		# when needed to construct the message, should always been used before other "about_" methods so that the category tag can be overwritten
   		# only values permitted for hash_function_function_name : "SHA-1", "MD5" or nil
   		def about_login(user_name, passwd=nil, hash_function_name=nil, admin=nil, suspended=nil, change_passwd_at_next_login=nil)
!! 			self.elements["atom:entry/atom:category"].add_attribute("term", "http://schemas.google.com/apps/2006#user")
!! 			self.elements["atom:entry"].add_element "apps:login", {"userName" => user_name } 
!! 			self.elements["atom:entry/apps:login"].add_attribute("password", passwd) if not passwd.nil?
!! 			self.elements["atom:entry/apps:login"].add_attribute("hashFunctionName", hash_function_name) if not hash_function_name.nil?
!! 			self.elements["atom:entry/apps:login"].add_attribute("admin", admin) if not admin.nil?
!! 			self.elements["atom:entry/apps:login"].add_attribute("suspended", suspended) if not suspended.nil?
!! 			self.elements["atom:entry/apps:login"].add_attribute("changePasswordAtNextLogin", change_passwd_at_next_login) if not change_passwd_at_next_login.nil?
!! 			return self
   		end
   	 
   		# adds <apps:quota> in the message body.
   		# limit in MB: integer
   		def about_quota(limit)
!! 			self.elements["atom:entry"].add_element "apps:quota", {"limit" => limit }  
!! 			return self
   		end	   
    
   		# adds <apps:name> in the message body.
   		def about_name(family_name, given_name)
!! 			self.elements["atom:entry"].add_element "apps:name", {"familyName" => family_name, "givenName" => given_name } 
!! 			return self
   		end
   
   		# adds <apps:nickname> in the message body.
   		def about_nickname(name)
!! 			self.elements["atom:entry/atom:category"].add_attribute("term", "http://schemas.google.com/apps/2006#nickname")
!! 			self.elements["atom:entry"].add_element "apps:nickname", {"name" => name} 
!! 			return self
   		end
    
   		# adds <gd:who> in the message body.
   		def about_who(email)
!! 			self.elements["atom:entry"].add_element "gd:who", {"email" => email } 
!! 			return self
   		end
   		
   	end
   
   end

================================================================================
 ./lib/google_mailing_list_job.rb
================================================================================
   class GoogleMailingListJob < Struct.new(:new_distribution_list, :old_distribution_list, :emails_array, :name, :description, :model_id, :table_name)
   
     def perform
!!     Rails.logger.info("#{table_name}.update_google_mailing_list(#{new_distribution_list}, #{old_distribution_list}, #{model_id}) executed")
   
!!     new_group = new_distribution_list.split('@')[0] unless new_distribution_list.blank?
!!     old_group = old_distribution_list.split('@')[0] unless old_distribution_list.blank?
   
!!     new_group_exists = false
!!     old_group_exists = false
!!     google_apps_connection.retrieve_all_groups.each do |list|
!!       group_name = list.group_id.split('@')[0]
!!       old_group_exists = true if old_group == group_name
!!       new_group_exists = true if new_group == group_name
       end
!!     if old_group_exists
!!       Rails.logger.info "Deleting #{old_group}"
!!       google_apps_connection.delete_group(old_group)
!!       new_group_exists = false if old_group == new_group
       end
   
!!     if !new_group_exists
!!       Rails.logger.info "Creating #{new_group}"
!!       google_apps_connection.create_group(new_group, [name, description, "Domain"])
       end
!!     emails_array.each do |member|
!!       Rails.logger.info "#{table_name}:adding #{member.email}"
!!       google_apps_connection.add_member_to_group(member.email, new_group)
       end
   
   
       #verify that this method worked. If it didn't an error will be raised and it will be run again through delayed job
!!     all_team_members = google_apps_connection.retrieve_all_members(new_group)
!!     google_list = all_team_members.map { |l| l.member_id }.sort
!!     team_list = emails_array.map { |l| l.email }.sort
!!     unless google_list.eql?(team_list)
!!       Rails.logger.warn("The people on the google list isn't right")
!!       Rails.logger.warn("google list: #{google_list} ")
!!       Rails.logger.warn("rails list: #{team_list} ")
!!       raise Exception.new("The people on the google list isn't right \n" + "google list: #{google_list} " + "\n rails list: #{team_list} \n")
       end
   
!!     ActiveRecord::Base.connection.execute "UPDATE #{table_name} SET updating_email=false WHERE id=#{model_id}";
!!     Rails.logger.info "#{model_id} -- finished"
   
     end
   
   end

================================================================================
 ./lib/reminder_handler.rb
================================================================================
   # Module responsible for handling reminders that need to be sent out to users
   module ReminderHandler
   
     # Send users a reminder to update pages. Reminders are only sent if the
     # page was last updated by the user on this day and month in previous years.
     # If the user updated multiple pages on that day, only one email will be sent
     # containing urls to all the pages that need to be updated. Reminders for pages
     # that were last updated on Feb 29th in previous years will be sent out on Feb 28
     #
     # ==== Attributes
     #
     # * +ref_time+ - Time value used for reference. Reminders will only be sent if the
     #   page was last updated on this day and month but in previous years.
      def self.send_page_update_reminders ref_time
       pages_to_update_by_user_id(ref_time).each do |user, pages|
         options = {
           :subject => "Some pages need your attention",
           :message => "I noticed that you were the last one to update #{pages.length > 1 ? "these pages" : "this page"}. " +
                     "Please take a few minutes to update #{pages.length > 1 ? "them" : "it"} again.",
           :urls => self.page_urls_with_labels(pages),
           :to => user.email
         }
         ReminderMailer.email(options).deliver
       end
     end
   
     # Creates a hash to keep track of pages last updated by a user. Pages that
     # were last updated on this day and month in previous years get added to the hash.
     # The key is the ID of the user and the value is an array of page records that
     # were last updated by that user.
     #
     # ==== Attributes
     #
     # * +ref_time+ - Time value used for reference. Reminders will only be sent if the
     #   page was last updated on this day and month but in previous years.
     def self.pages_to_update_by_user_id ref_time
       pages_by_u_id = {}
       Page.all.each do |page|
         next if page.updated_at.nil?
   
         # If page was updated on Feb 29, then use Feb 28 instead for comparison.
         m = page.updated_at.month
         d = (m == 2 && page.updated_at.day == 29) ? 28 : page.updated_at.day
         y = page.updated_at.year
   
         # Select pages that were updated on 'd' day and 'm' month in previous years
         next unless (d == ref_time.day &&
                      m == ref_time.month &&
                      y < ref_time.year)
   
         pages_by_u_id[page.updated_by] ||= []
         pages_by_u_id[page.updated_by] << page
       end
       pages_by_u_id
     end
   
     # Creates a hash that associates page url with the page title like
     # "{ http://whiteboard.sv.cmu.edu/pages/1/edit => Syllabus }".
     #
     # ==== Attributes
     #
     # * +pages+ - Page records
     def self.page_urls_with_labels pages
       urls = {}
       pages.each do |page|
         url = Rails.application.routes.url_helpers::edit_page_url(page.id,
                                                                   :host => "whiteboard.sv.cmu.edu")
         urls[url] = page.title
       end
       urls
     end
   end

================================================================================
 ./spec/controllers/assignments_controller_spec.rb
================================================================================
   require 'spec_helper'
   #require 'rubygems'
   #require 'ruby-debug'
   
   # This spec was generated by rspec-rails when you ran the scaffold generator.
   # It demonstrates how one might use RSpec to specify the controller code that
   # was generated by Rails when you ran the scaffold generator.
   #
   # It assumes that the implementation code is generated by the rails scaffold
   # generator.  If you are using any extension libraries to generate different
   # controller code, this generated spec may or may not pass.
   #
   # It only uses APIs available in rails and/or rspec-rails.  There are a number
   # of tools you can use to make these specs even more expressive, but we're
   # sticking to rails and rspec-rails APIs to keep things simple and stable.
   #
   # Compared to earlier versions of this generator, there is very limited use of
   # stubs and message expectations in this spec.  Stubs are only used when there
   # is no simpler way to get a handle on the object needed for the example.
   # Message expectations are only used when there is no simpler way to specify
   # that an instance is receiving a specific message.
   
   describe AssignmentsController do
   
     # This should return the minimal set of attributes required to create a valid
     # Assignment. As you add validations to Assignment, be sure to
     # update the return value of this method accordingly.
   
     before do
   
       @assignment = FactoryGirl.create(:assignment_fse)
       @course = @assignment.course
       #debugger
       login(FactoryGirl.create(:faculty_frank))
   
     end
     def valid_due_date_parameters; {:date=>Date.today.strftime("%Y-%m-%d"), :hour=>'23', :minute=>'59'} end
   
     def valid_attributes
       {:maximum_score=>100, :course_id=>@course.id,:assignment_order=>1, :task_number=>1}
     end
   
     describe "GET index" do
       it "assigns all assignments as @assignments" do
         assignments = @course.assignments
         get :index, :course_id => @course.id
         assigns(:assignments).should eq(assignments)
       end
     end
   
   
   
     describe "GET new" do
       it "assigns a new assignment as @assignment" do
         get :new, :course_id => @course.id
         assigns(:assignment).should be_a_new(Assignment)
       end
     end
   
     describe "GET edit" do
       it "assigns the requested assignment as @assignment" do
        # assignment = Assignment.create! valid_attributes
         get :edit, :id => @assignment.id.to_s  , :course_id => @course.id
         assigns(:assignment).should eq(@assignment)
       end
     end
   
     describe "POST create" do
       describe "with valid params" do
         it "creates a new Assignment" do
           expect {
             post :create,:course_id => @course, :assignment => valid_attributes, :due_date => valid_due_date_parameters
           }.to change(Assignment, :count).by(1)
         end
   
         it "assigns a newly created assignment as @assignment" do
           post :create, :course_id => @course, :assignment => valid_attributes, :due_date => valid_due_date_parameters
           assigns(:assignment).should be_a(Assignment)
!!         assigns(:assignment).should be_persisted
         end
   
         it "redirects to the created assignment" do
           post :create,:course_id => @course, :assignment => valid_attributes, :due_date => valid_due_date_parameters
           response.should redirect_to(course_assignments_path)
         end
       end
   
       describe "with invalid params" do
         it "assigns a newly created but unsaved assignment as @assignment" do
           # Trigger the behavior that occurs when invalid params are submitted
           Assignment.any_instance.stub(:save).and_return(false)
           post :create, :course_id => @course,:assignment => {}, :due_date => valid_due_date_parameters
           assigns(:assignment).should be_a_new(Assignment)
         end
   
         it "re-renders the 'new' template" do
           # Trigger the behavior that occurs when invalid params are submitted
           Assignment.any_instance.stub(:save).and_return(false)
           post :create,:course_id => @course, :assignment => {}, :due_date => valid_due_date_parameters
           response.should render_template("new")
         end
       end
     end
   
     describe "PUT update" do
       describe "with valid params" do
         it "updates the requested assignment" do
           assignment = Assignment.create! valid_attributes
           # Assuming there are no other assignments in the database, this
           # specifies that the Assignment created on the previous line
           # receives the :update_attributes message with whatever params are
           # submitted in the request.
           Assignment.any_instance.should_receive(:update_attributes).with({'these' => 'params'})
           put :update,:course_id => @course, :id => assignment.id, :assignment => {'these' => 'params'}
         end
   
         it "assigns the requested assignment as @assignment" do
           assignment = Assignment.create! valid_attributes
           put :update, :course_id => @course,:id => assignment.id, :assignment => valid_attributes, :due_date => valid_due_date_parameters
           assigns(:assignment).should eq(assignment)
         end
   
         it "redirects to the assignment" do
           assignment = Assignment.create! valid_attributes
           put :update, :course_id => @course,:id => assignment.id, :assignment => valid_attributes, :due_date=>valid_due_date_parameters
           response.should redirect_to(course_assignments_path)
         end
       end
   
       describe "with invalid params" do
         it "assigns the assignment as @assignment" do
           assignment = Assignment.create! valid_attributes
           # Trigger the behavior that occurs when invalid params are submitted
           Assignment.any_instance.stub(:save).and_return(false)
           put :update,:course_id => @course, :id => assignment.id.to_s, :assignment => {}, :due_date => valid_due_date_parameters
           assigns(:assignment).should eq(assignment)
         end
   
         it "re-renders the 'edit' template" do
           assignment = Assignment.create! valid_attributes
           # Trigger the behavior that occurs when invalid params are submitted
           Assignment.any_instance.stub(:save).and_return(false)
           put :update,:course_id => @course, :id => assignment.id.to_s, :assignment => {}, :due_date => valid_due_date_parameters
           response.should render_template("edit")
         end
       end
     end
   
   
   end

================================================================================
 ./spec/controllers/course_navigations_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe CourseNavigationsController do
   
     let(:course) { FactoryGirl.create(:course) }
   
     context "any user can" do
       before do
         login(FactoryGirl.create(:student_sam))
       end
   
       describe "GET show" do
         before do
           get :show, :id => course.to_param
         end
   
         it "can't access page" do
           response.should redirect_to(root_path)
         end
       end
   
     end
   
     context "any faculty can" do
       before do
         login(FactoryGirl.create(:faculty_frank))
       end
   
       describe "GET show" do
         before do
           get :show, :id => course.to_param
         end
   
         specify { assigns(:course).should_not be_nil }
         specify { assigns(:pages).should_not be_nil }
   
       end
   
     end
   
   
   #  context "any faculty can" do
   #    before do
   #      login(FactoryGirl.create(:faculty_frank))
   #    end
   #
   #    describe "GET reposition" do
   #
   #      it ''
   #
   #    end
   #  end
   
   end

================================================================================
 ./spec/controllers/course_numbers_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe CourseNumbersController do
   
     let(:course) { FactoryGirl.create(:course) }
   
     context "any user can" do
       before do
         login FactoryGirl.create(:student_sam)
       end
   
       describe "GET index" do
         before do
           get :index
         end
   
         specify { assigns(:courses).should_not be_nil }
       end
   
     end
   
   end

================================================================================
 ./spec/controllers/courses_controller_spec.rb
================================================================================
   require 'spec_helper'
   require 'controllers/permission_behavior'
   
   describe CoursesController do
   
   
     let(:course) { FactoryGirl.create(:course) }
   
     shared_examples_for "courses_for_a_given_semester" do
       specify { assigns(:courses).should_not be_nil }
       specify { assigns(:semester).should_not be_nil }
       specify { assigns(:year).should_not be_nil }
       specify { assigns(:all_courses).should == false }
     end
   
     context "any user can" do
       before do
         login(FactoryGirl.create(:student_sam))
       end
   
       describe "GET index for semester" do
         before do
           FactoryGirl.create(:course, :mini => "A")
           FactoryGirl.create(:course, :mini => "B")
           FactoryGirl.create(:course, :mini => "Both")
           get :index_for_semester, :semester => "Fall2012"
         end
   
         specify { assigns(:semester_length_courses).should_not be_nil }
         specify { assigns(:mini_a_courses).should_not be_nil }
         specify { assigns(:mini_b_courses).should_not be_nil }
   
         it_should_behave_like "courses_for_a_given_semester"
       end
   
       describe "GET index" do
         before do
           get :index
         end
   
         specify { assigns(:courses).should_not be_nil }
         specify { assigns(:all_courses).should == true }
       end
   
       describe "GET show" do
         before do
           get :show, :id => course.to_param
         end
   
         specify { assigns(:course).should_not be_nil }
   
       end
   
       describe "not GET new" do
         before do
           get :new
         end
   
         it_should_behave_like "cancan permission denied"
       end
   
   
       describe "not GET configure" do
         before do
           get :configure, :id => course.to_param
         end
   
         it_should_behave_like "cancan permission denied"
       end
   
       describe "not POST create" do
         before do
           @course = FactoryGirl.build(:course)
           post :create, :course => @course.attributes
         end
   
         it_should_behave_like "cancan permission denied"
       end
   
       describe "not PUT update" do
         before do
           put :update, :id => course.to_param, :course => {:name => 'NNNNN'}
         end
   
         it_should_behave_like "cancan permission denied"
       end
   
       describe "not DELETE destroy" do
         before do
           delete :destroy, :id => course.to_param
         end
   
         it_should_behave_like "permission denied"
       end
   
     end
   
     context "any staff can" do
       before do
         login(FactoryGirl.create(:faculty_frank))
       end
   
       describe "GET new" do
         before do
           get :new
         end
   
         specify { assigns(:course).should_not be_nil }
       end
   
       describe "GET edit" do
         before do
           get :edit, :id => course.to_param
         end
   
         specify { assigns(:course).should == course }
       end
   
       describe "GET configure" do
         before do
           get :configure, :id => course.to_param
         end
   
         specify { assigns(:course).should == course }
       end
   
   
       describe "POST create" do
   
         describe "with valid params for new course number" do
           before(:each) do
             @course = FactoryGirl.build(:course)
           end
   
           it "saves a newly created item" do
             lambda {
               post :create, :course => {"number"=>"96-NEW", "semester"=>"Summer", "year"=>"2011"}
             }.should change(Course, :count).by(1)
           end
   
           it "redirects to edit course" do
             post :create, :course => @course.attributes
             @new_course = assigns(:course)
             response.should redirect_to(edit_course_path(@new_course))
           end
         end
   
         describe "with valid params for an existing course number" do
   
           before(:each) do
             @number = "96-700"
             @course = FactoryGirl.create(:course, :number => @number)
           end
   
           it "saves a newly created item" do
             lambda {
               post :create, :course => {"number"=>@number, "semester"=>"Summer", "year"=>"2011"}
             }.should change(Course, :count).by(1)
           end
   
           it "redirects to edit course" do
             post :create, :course => @course.attributes
             @new_course = assigns(:course)
             response.should redirect_to(edit_course_path(@new_course))
           end
   
         end
   
         describe "with invalid params" do
           it "assigns a newly created but unsaved item as item" do
             lambda {
               post :create, :course => {}
             }.should_not change(Course, :count)
             assigns(:course).should_not be_nil
!!           assigns(:course).should be_kind_of(Course)
           end
   
           it "re-renders the 'new' template" do
             post :create, :course => {}
             response.should render_template("new")
           end
         end
       end
   
       describe "PUT update" do
   
         describe "with valid params" do
   
           before do
             put :update, :id => course.to_param, :course => {:name => 'NNNNN'}
           end
   
           it "updates the requested course name" do
             #error has to do with course model being versioned. Making it un-versioned lets the test pass
             course.reload.name.should == "NNNNN"
           end
   
           it "should assign @course" do
             assigns(:course).should_not be_nil
           end
   
           it "redirects to the course" do
             response.should redirect_to(course_path(course))
           end
         end
   
         describe "with invalid params" do
           before do
             put :update, :id => course.to_param, :course => {:name => ''}
           end
   
           it "should assign @course" do
             assigns(:course).should_not be_nil
           end
   
           it "re-renders the 'edit' template" do
             response.should render_template("configure")
           end
         end
   
       end
   
       describe "not DELETE destroy" do
         before do
           delete :destroy, :id => course.to_param
         end
   
         it_should_behave_like "permission denied"
       end
     end
   
   
     context "any admin can" do
   #    before do
   #      login(FactoryGirl.create(:admin_andy))
   #    end
   
       describe "DELETE destroy" do
   
         it "destroys the course" do
   #       course.should_receive(:destroy)
   
   #        lambda {
   #          a = Course.count
   #          c = course
   #          delete :destroy, :id => course.to_param
   #          b = Course.count
   #          t = 1
   #        }.should change(Course, :count).by(1)
         end
   
       end
   
     end
   end

================================================================================
 ./spec/controllers/delayed_system_jobs_controller_spec.rb
================================================================================
   require 'spec_helper'
   require 'controllers/permission_behavior'
   
   describe DelayedSystemJobsController do
   
   
     let(:delayed_system_job) { FactoryGirl.create(:delayed_system_job) }
   
   
     context "any user can" do
       before do
         login(FactoryGirl.create(:student_sam))
       end
   
       describe "GET index" do
         before do
           get :index
         end
   
         it_should_behave_like "permission denied"
       end
   
   
       describe "DELETE destroy" do
         before do
           delete :destroy, :id => delayed_system_job.to_param
         end
   
         it_should_behave_like "permission denied"
       end
   
     end
   
     context "any admin can" do
       before do
         login(FactoryGirl.create(:admin_andy))
       end
   
       describe "GET index" do
         before do
           get :index
         end
         
         specify { assigns(:delayed_system_jobs).should_not be_nil }
   
       end
   
         it "destroys the course" do
   #       course.should_receive(:destroy)
   
   #        lambda {
   #          a = Course.count
   #          c = course
   #          delete :destroy, :id => course.to_param
   #          b = Course.count
   #          t = 1
   #        }.should change(Course, :count).by(1)
         end
   
     end
     
   
   end

================================================================================
 ./spec/controllers/deliverables_controller_spec.rb
================================================================================
   require 'spec_helper'
   require 'controllers/permission_behavior'
   
   describe DeliverablesController do
   
     before do
       @admin_andy = FactoryGirl.create(:admin_andy)
       @faculty_frank = FactoryGirl.create(:faculty_frank_user)
       @faculty_fagan = FactoryGirl.create(:faculty_fagan)
       @student_sam = FactoryGirl.create(:student_sam)
       @student_sally = FactoryGirl.create(:student_sally)
   
   
     end
   
     describe "GET index for course" do
   
       ## beg add Team turing
       before(:each) do
         @course = FactoryGirl.create(:fse, faculty: [@faculty_frank])
   
         @assignment_ungraded = FactoryGirl.create(:assignment_1,:course => @course, :name => "Assignment Ungraded",
                                                   :task_number => 1)
         @assignment_drafted = FactoryGirl.create(:assignment_1,:course => @course, :name => "Assignment Drafted",
                                                  :task_number => 3)
         @assignment_graded = FactoryGirl.create(:assignment_1,:course => @course, :name => "Assignment Graded",
                                                 :task_number => 2)
   
         @turing_grade_graded = FactoryGirl.create(:grade_visible, :course => @course, :student =>@student_sam,
                                                   :assignment => @assignment_graded)
         @turing_grade_drafted = FactoryGirl.create(:grade_invisible, :course => @course, :student => @student_sam,
                                                    :assignment =>  @assignment_drafted)
         @turing_grade_ungraded = nil
   
   
        @test_grade_ungraded =  FactoryGirl.create(:grade_invisible_turing, :course => @course,
                                                   :student => @student_sally, :assignment =>  @assignment_graded)
   
         @team_turing =  FactoryGirl.create(:team_turing, :course=>@course)
         @team_test =  FactoryGirl.create(:team_test, :course=>@course)
   
         @team_turing.members = [@student_sam]
         @team_test.members = [@student_sally]
   
         @deliverable_turing_ungraded = FactoryGirl.create(:team_turing_deliverable_1,:course => @course,
                                 :team => @team_turing,:assignment => @assignment_ungraded, :creator => @student_sam,
                                 :grade_status => "ungraded")
         @deliverable_turing_drafted = FactoryGirl.create(:team_turing_deliverable_1,:course => @course,
                                 :team => @team_turing,:assignment => @assignment_drafted, :creator => @student_sam,
                                 :grade_status => "drafted")
         @deliverable_turing_graded = FactoryGirl.create(:team_turing_deliverable_1,:course => @course,
                                 :team => @team_turing,:assignment => @assignment_graded, :creator => @student_sam,
                                 :grade_status => "graded")
         @deliverable_test_ungraded = FactoryGirl.create(:team_test_deliverable_1,:course => @course,
                                 :team => @team_test,:assignment => @assignment_ungraded, :grade_status => "ungraded")
   
         @da_turing_ungraded =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable_turing_ungraded,
                                 :submitter => @student_sam)
         @da_turing_drafted =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable_turing_drafted,
                                 :submitter => @student_sam)
         @da_turing_graded =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable_turing_graded,
                                 :submitter => @student_sam)
         @da_test_ungraded =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable_test_ungraded,
                                 :submitter => @student_sam)
   
         @course.stub(:grading_rule).and_return(true)
         @course.stub_chain(:grading_rule, :default_values?).and_return(true)
         Course.stub(:find).and_return(@course)
   
       end
   
       context "as the faculty owner of the course" do
         before do
           Deliverable.stub(:grading_queue_display).and_return([@deliverable_turing_ungraded, @deliverable_turing_drafted,
                                                                @deliverable_turing_graded])
           login(@faculty_frank)
         end
   
         it 'shows the assignments names for my course only' do
           get :grading_queue_for_course, :course_id =>  @course.id , :faculty_id =>@faculty_frank.id
!!         @expected_assignments = assigns(:assignments)
   
!!         @expected_assignments.should have(3).items
!!         @expected_assignments[0].should == @assignment_ungraded
!!         @expected_assignments[1].should == @assignment_drafted
!!         @expected_assignments[2].should == @assignment_graded
   
         end
   
         #default behavior
         it 'shows ungraded deliverables of only my teams both, team and individual deliverables' do
           get :grading_queue_for_course, :course_id =>  @course.id , :faculty_id =>@faculty_frank.id
!!         @expected_deliverable = assigns(:deliverables)
   
!!         @expected_deliverable.should have(2).items
!!         @expected_deliverable.include?(@deliverable_turing_ungraded).should be_true
!!         @expected_deliverable.include?(@deliverable_turing_drafted).should be_true
         end
   
         #default behavior
         it 'shows the deliverables that matches the selected deliverable name' do
           get :get_deliverables, :filter_options => {:graded => "1", :ungraded => "1", :drafted => "1",
               :assignment_id => @assignment_ungraded.id.to_s, :is_my_teams => 'yes', :search_box => ""},
               :course_id =>  @course.id
   
!!         @expected_deliverable = assigns(:deliverables)
!!         @expected_deliverable.should have(1).items
!!         @expected_deliverable[0].should == @deliverable_turing_ungraded
         end
   
         it 'shows graded deliverables if graded buttons is clicked' do
           get :get_deliverables, :filter_options => {:graded => "1", :assignment_id => "-1",
           :is_my_teams => 'yes', :search_box => ""}, :course_id =>  @course.id
   
!!         @expected_deliverable = assigns(:deliverables)
!!         @expected_deliverable.should have(1).items
!!         @expected_deliverable[0].should == @deliverable_turing_graded
         end
   
         it 'shows graded and ungraded deliverables of only my teams if graded and ungraded buttons are clicked' do
           get :get_deliverables, :filter_options => {:graded => "1", :ungraded => "1", :assignment_id => "-1",
           :is_my_teams => 'yes', :search_box => ""}, :course_id =>  @course.id
   
!!         @expected_deliverable = assigns(:deliverables)
!!         @expected_deliverable.should have(2).items
!!         @expected_deliverable.include?(@deliverable_turing_graded).should be_true
!!         @expected_deliverable.include?(@deliverable_turing_ungraded).should be_true
   
         end
   
         it 'shows all deliverables of only my teams is clicked' do
           get :get_deliverables, :filter_options => {:assignment_id => "-1", :is_my_teams => 'yes', :search_box => ""},
               :course_id =>  @course.id
   
!!         @expected_deliverable = assigns(:deliverables)
!!         @expected_deliverable.should have(3).items
!!         @expected_deliverable.include?(@deliverable_turing_graded).should be_true
!!         @expected_deliverable.include?(@deliverable_turing_ungraded).should be_true
!!         @expected_deliverable.include?(@deliverable_turing_drafted).should be_true
   
         end
   
   
         context "search function is enabled" do
   
           before do
   
             @team_member = FactoryGirl.create(:team_member)
   
             @team_ruby_racer = FactoryGirl.create(:team_ruby_racer, :course=>@course)
   
             @team_ruby_racer.members = [@team_member]
   
             @ruby_racer_grade_graded = FactoryGirl.create(:grade_visible, :course => @course, :student =>@team_member,
                                                           :assignment => @assignment_graded)
             @ruby_racer_grade_drafted = FactoryGirl.create(:grade_invisible, :course => @course,
                                                            :student => @team_member, :assignment =>  @assignment_drafted)
             @ruby_racer_grade_ungraded = nil
   
             @deliverable_ruby_racer_ungraded = FactoryGirl.create(:team_ruby_racer_deliverable_1,:course => @course,
                               :team => @team_ruby_racer,:assignment => @assignment_ungraded, :creator => @team_member)
             @deliverable_ruby_racer_drafted = FactoryGirl.create(:team_ruby_racer_deliverable_1,:course => @course,
                               :team => @team_ruby_racer,:assignment => @assignment_drafted, :creator => @team_member)
             @deliverable_ruby_racer_graded = FactoryGirl.create(:team_ruby_racer_deliverable_1,:course => @course,
                               :team => @team_ruby_racer,:assignment => @assignment_graded, :creator => @team_member)
   
             @da_ruby_racer_ungraded =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable_ruby_racer_ungraded,
                                       :submitter => @team_member)
             @da_ruby_racer_drafted =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable_ruby_racer_drafted,
                                       :submitter => @team_member)
             @da_ruby_racer_graded =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable_ruby_racer_graded,
                                       :submitter => @team_member)
   
           end
   
   
           it 'shows all deliverables of only my teams and search box is entered' do
             get :get_deliverables, :filter_options => {:assignment_id => "-1", :is_my_teams => 'yes',
                                                        :search_box => "Member"}, :course_id =>  @course.id
   
!!           @expected_deliverable = assigns(:deliverables)
!!           @expected_deliverable.should have(3).items
!!           @expected_deliverable.include?(@deliverable_ruby_racer_ungraded).should be_true
!!           @expected_deliverable.include?(@deliverable_ruby_racer_graded).should be_true
!!           @expected_deliverable.include?(@deliverable_ruby_racer_drafted).should be_true
   
           end
         end
         ## end add Team turing
   
       end
   
   
       context "as any other user" do
         before do
           login(@faculty_fagan)
           get :grading_queue_for_course, :course_id => @course.id
         end
   
         it_should_behave_like "permission denied"
       end
     end
   
   
     describe "GET my_deliverables" do
       before(:each) do
         @course = mock_model(Course, :faculty => [@faculty_frank], :course_id => 42)
         @past_course = mock_model(Course, :faculty => [@faculty_frank], :course_id => 41)
         @deliverable = stub_model(Deliverable, :course_id => @course.id, :owner_id => @student_sam.id)
         @current_assignment = stub_model(Assignment, :course_id => @course.id)
         @past_assignment = stub_model(Assignment, :course_id => @past_course.id)
         Deliverable.stub(:find_current_by_user).and_return([@deliverable, @deliverable])
         Deliverable.stub(:find_past_by_user).and_return([@deliverable, @deliverable])
         Assignment.stub(:list_assignments_for_student).with(@student_sam.id , :current).and_return([@current_assignment])
         Assignment.stub(:list_assignments_for_student).with(@student_sam.id , :past).and_return([@past_assignment])
         Course.stub(:find).and_return(@course)
         User.any_instance.stub(:registered_for_these_courses_during_current_semester).and_return([@course])
         User.any_instance.stub(:registered_for_these_courses_during_past_semesters).and_return([@past_course])
       end
   
       context "as the owner of the deliverable" do
         before do
           login(@student_sam)
         end
   
         it 'assigns deliverables' do
           get :my_deliverables, :id => @student_sam.id
           #assigns(:current_deliverables).should == [@deliverable, @deliverable]
           #assigns(:past_deliverables).should == [@deliverable, @deliverable]
!!         assigns(:current_courses).should == [@course]
!!         assigns(:past_courses).should == [@past_course]
!!         assigns(:current_assignments).should == [@current_assignment]
!!         assigns(:past_assignments).should == [@past_assignment]
         end
       end
   
       context "as an faculty" do
   
         before do
           login(@faculty_frank)
         end
   
         it 'assigns @deliverables' do
           get :my_deliverables, :id => @student_sam.id
!!         assigns(:current_deliverables).should == [@deliverable, @deliverable]
!!         assigns(:past_deliverables).should == [@deliverable, @deliverable]
         end
       end
   
       context "as any other student" do
         before do
           login(@student_sally)
           get :my_deliverables, :id => @student_sam.id
         end
   
         it_should_behave_like "permission denied for person deliverable"
       end
     end
   
   
     describe "GET show" do
       before(:each) do
         @course = mock_model(Course, :faculty => [@faculty_frank], :course_id => 42)
         @current_assignment = mock_model(Assignment, :course_id => @course.id, :is_team_deliverable => true)
         @deliverable = stub_model(Deliverable, :course_id => @course.id, :owner_id => @student_sam.id, :assignment=>@current_assignment)
         @deliverable.course = @course
         @team = stub_model(Team)
         Deliverable.stub(:find).and_return(@deliverable)
         @deliverable.stub(:team).and_return(@team)
   
         @course.stub(:grading_rule).and_return(true)
         @course.stub_chain(:grading_rule, :default_values?).and_return(true)
         @course = Course.stub(:find).and_return(@course)
   
       end
   
       context "for a team deliverable" do
   
         it 'the owner can see it' do
           login(@student_sam)
           @team.stub(:is_user_on_team?).and_return(true)
           get :show, :id => @deliverable.id
!!         assigns(:deliverable).should == @deliverable
         end
   
         it "someone else on the team can see it" do
           login(@student_sam)
           @team.stub(:is_user_on_team?).and_return(true)
           get :show, :id => @deliverable.id
!!         assigns(:deliverable).should == @deliverable
         end
   
         it "any faculty can see it" do
           login(@faculty_frank)
           @team.stub(:is_user_on_team?).and_return(false)
           get :show, :id => @deliverable.id
!!         assigns(:deliverable).should == @deliverable
         end
   
         context "no other student can see it" do
           before do
             @team.stub(:is_user_on_team?).and_return(false)
             login(@student_sally)
             get :show, :id => @deliverable.id
           end
   
           it_should_behave_like "permission denied for person deliverable"
         end
       end
     end
   
   
   #    describe "GET edit" do
   #
   #      it 'assigns @efforts' do
   #        efforts = [stub_model(SponsoredProjectEffort)]
   #        SponsoredProjectEffort.should_receive(:month_under_inspection_for_a_given_user).with(@faculty_frank.id).and_return(efforts)
   #        get :edit, :id => @faculty_frank.twiki_name
   #        assigns(:efforts).should == efforts
   #        assigns(:month).should == efforts[0].month
   #        assigns(:year).should == efforts[0].year
   #      end
   #    end
   #
   #    describe "PUT update" do
   #
   #      before(:each) do
   #        @effort_1 = stub_model(SponsoredProjectEffort)
   #        @effort_2 = stub_model(SponsoredProjectEffort)
   #
   #        @effort_1.stub(:valid).and_return(true)
   #        @effort_2.stub(:valid).and_return(true)
   #
   #        @effort_1.stub(:unique_month_year_allocation_id?).and_return(true)
   #        @effort_2.stub(:unique_month_year_allocation_id?).and_return(true)
   #
   #        SponsoredProjectEffort.should_receive(:find).with("0").and_return(@effort_1)
   #        SponsoredProjectEffort.should_receive(:find).with("1").and_return(@effort_2)
   #
   #        subject.should_receive(:setup_edit).and_return(true)
   #
   #        SponsoredProjectEffort.stub(:emails_business_manager)
   #      end
   #
   #
   #      describe "with valid params" do
   #
   #        it "updates the actual allocations" do
   #          @effort_1.should_receive(:actual_allocation=).with("25")
   #          @effort_2.should_receive(:actual_allocation=).with("75")
   #          put :update, :id => "AndrewCarnegie", :effort_id_values => {"0" => "25", "1" => "75"}
   #        end
   #
   #        it 'updates the confirmed value' do
   #          @effort_1.should_receive(:confirmed=).with(true)
   #          @effort_2.should_receive(:confirmed=).with(true)
   #          put :update, :id => "AndrewCarnegie", :effort_id_values => {"0" => "25", "1" => "75"}
   #        end
   #
   ##        it 'sets the flash' do
   ##          put :update, :id => "AndrewCarnegie", :effort_id_values => {"0" => "25", "1" => "75"}
   ##          flash.now[:notice].should_not be_nil
   ##        end
   #
   #        it "re-renders the 'edit' template" do
   #          put :update, :id => "AndrewCarnegie", :effort_id_values => {"0" => "25", "1" => "75"}
   #          response.should render_template("edit")
   #        end
   #
   #        it "emails the business manager when actual != confirmed" do
   #          SponsoredProjectEffort.should_receive(:emails_business_manager)
   #          put :update, :id => "AndrewCarnegie", :effort_id_values => {"0" => "25", "1" => "75"}
   #        end
   #      end
   #
   #      describe "with invalid params" do
   #
   #        it 'sets the flash to error' do
   #          @effort_2.should_receive(:save).and_return(false)
   #          put :update, :id => "AndrewCarnegie", :effort_id_values => {"0" => "25", "1" => "75"}
   #          assigns(:failed).should == true
   #          #flash.now[:error].should == "Your allocations did not save."
   #        end
   #
   #        it "re-renders the 'edit' template" do
   #          @effort_2.should_receive(:save).and_return(false)
   #          put :update, :id => "AndrewCarnegie", :effort_id_values => {"0" => "25", "1" => "75"}
   #          response.should render_template("edit")
   #        end
   #      end
   #    end
   
   
   end

================================================================================
 ./spec/controllers/effort_logs_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe EffortLogsController do
   
     describe "#index" do
       context "when it is the first week of the year" do
         before do
           Date.any_instance.stub(:cweek).and_return(1)
           Date.any_instance.stub(:cwyear).and_return(2011)
           login(FactoryGirl.create(:student_sam))
           get(:index)
         end
   
         specify { assigns(:prior_week_number).should == 52 }
         specify { assigns(:year).should == 2010 }
       end
   
       context "when it is not the first week of the year" do
         before do
           Date.any_instance.stub(:cweek).and_return(32)
           Date.any_instance.stub(:cwyear).and_return(2011)
           login(FactoryGirl.create(:student_sam))
           get(:index)
         end
   
         specify { assigns(:prior_week_number).should == 31 }
         specify { assigns(:year).should == 2011 }
       end
   
       context "when the day of the week is Monday" do
         before do
           Date.any_instance.stub(:cwday).and_return(1)
         end
         context "and there is no effort log" do
           before do
             login(FactoryGirl.create(:student_sam))
             get(:index)
           end
           specify { assigns(:show_new_link).should be }
           specify { assigns(:show_prior_week).should be }
         end
   
         context "and there are effort logs" do
           before do
             @effort_logs = [EffortLog.new(:year => 2011, :week_number => 12, :sum => 8),
                             EffortLog.new(:year => 2011, :week_number => 12, :sum => 8)]
             EffortLog.stub(:find_effort_logs).and_return(@effort_logs)
           end
   
           it "and the effort logs are in the current period" do
             Date.any_instance.stub(:cwyear).and_return(@effort_logs[0].year)
             Date.any_instance.stub(:cweek).and_return(@effort_logs[0].week_number)
             login(FactoryGirl.create(:student_sam))
             get(:index)
             assigns(:show_new_link).should_not be
             assigns(:show_prior_week).should_not be
           end
   
           it "and the effort logs are not in the current period" do
             Date.any_instance.stub(:cweek).and_return(@effort_logs[0].week_number - 1)
             login(FactoryGirl.create(:student_sam))
             get(:index)
             assigns(:show_new_link).should be
!!           assigns(:show_prior_week).should_not be
           end
         end
       end
   
       context "when the day of the week is not Monday" do
         before do
           Date.any_instance.stub(:cwday).and_return(3)
         end
         context "and there is no effort log" do
           before do
             login(FactoryGirl.create(:student_sam))
             get(:index)
           end
           specify { assigns(:show_new_link).should be }
           specify { assigns(:show_prior_week).should_not be }
         end
   
         context "and there are effort logs" do
           before do
             @effort_logs = [EffortLog.new(:year => 2011, :week_number => 12, :sum => 8),
                             EffortLog.new(:year => 2011, :week_number => 12, :sum => 8)]
             EffortLog.stub(:find_effort_logs).and_return(@effort_logs)
           end
   
           it "and the effort logs are in the current period" do
             Date.any_instance.stub(:cwyear).and_return(@effort_logs[0].year)
             Date.any_instance.stub(:cweek).and_return(@effort_logs[0].week_number)
             login(FactoryGirl.create(:student_sam))
             get(:index)
             assigns(:show_new_link).should_not be
             assigns(:show_prior_week).should_not be
           end
   
           it "and the effort logs are not in the current period" do
             Date.any_instance.stub(:cweek).and_return(@effort_logs[0].week_number - 1)
             login(FactoryGirl.create(:student_sam))
             get(:index)
             assigns(:show_new_link).should be
!!           assigns(:show_prior_week).should_not be
           end
         end
       end
     end
   
     describe "#create_midweek_warning_email" do
       before do
         ScottyDogSaying.stub(:all).and_return([ScottyDogSaying.new(:saying => "random saying")])
         User.any_instance.stub(:save).and_return(true)
       end
   
       it "it should not send any emails when it is not an effort log week" do
         EffortLog.stub(:log_effort_week?).and_return(false)
         subject.should_not_receive(:create_midweek_warning_email_send_it)
         subject.create_midweek_warning_email
       end
   
       context "when it is an effort log week" do
         before do
           EffortLog.stub(:log_effort_week?).and_return(true)
         end
   
         context "and there are courses that have students" do
           before do
             Course.stub(:remind_about_effort_course_list).and_return([FactoryGirl.create(:mfse)])
             @person = User.new(:first_name => "Frodo", :last_name => "Baggins", :human_name => "Frodo Baggins")
             Course.any_instance.stub(:registered_students).and_return([@person])
           end
   
           context "and there are no effort logs" do
             before do
               EffortLog.stub(:where).and_return([])
             end
   
             it "it should send an email if the person has never been emailed" do
               @person.effort_log_warning_email = nil
               EffortLogMailer.should_receive(:midweek_warning).and_return(double(EffortLogMailer, :deliver => true))
               subject.create_midweek_warning_email
             end
   
             it "it should send an email if the person not been emailed recently " do
               @person.effort_log_warning_email = Time.now - 3.day
               EffortLogMailer.should_receive(:midweek_warning).and_return(double(EffortLogMailer, :deliver => true))
               subject.create_midweek_warning_email
             end
   
             it "it should not send an email if the person has been emailed recently" do
               @person.effort_log_warning_email = Time.now
               EffortLogMailer.should_not_receive(:midweek_warning)
               subject.create_midweek_warning_email
             end
           end
   
           context "and there are effort logs" do
             context "and the first effort logs sums to 0" do
               before do
                 EffortLog.stub(:where).and_return([EffortLog.new(:sum => 0), FactoryGirl.create(:effort2)])
               end
   
             it "it should send an email if the person has never been emailed" do
               @person.effort_log_warning_email = nil
               EffortLogMailer.should_receive(:midweek_warning).and_return(double(EffortLogMailer, :deliver => true))
               subject.create_midweek_warning_email
             end
   
             it "it should send an email if the person not been emailed recently " do
               @person.effort_log_warning_email = Time.now - 3.day
               EffortLogMailer.should_receive(:midweek_warning).and_return(double(EffortLogMailer, :deliver => true))
               subject.create_midweek_warning_email
             end
   
             it "it should not send an email if the person has been emailed recently" do
               @person.effort_log_warning_email = Time.now
               EffortLogMailer.should_not_receive(:midweek_warning)
               subject.create_midweek_warning_email
             end
             end
           end
         end
       end
     end
   
     describe "#create_midweek_warning_email_for_course" do
       it "it should not throw an error for nil Scotty dog saying" do
         subject.create_midweek_warning_email_for_course(nil, FactoryGirl.create(:mfse).id)
       end
     end
   
   
   end

================================================================================
 ./spec/controllers/effort_reports_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe EffortReportsController do
   
     it "should have the correct url for the google charting api" # do
   #    login(users(:student_sam))
   #
   #    foundations = FactoryGirl.create(:fse)
   #    line1 = FactoryGirl.create(:effort1)
   #    line2 = FactoryGirl.create(:effort2, :person => line1.person)
   #    line3 = FactoryGirl.create(:effort3, :person => line1.person)
   #
   #    get :campus_week
   #    assert_response :success
   #    url = assigns(:chart_url)
   #
   #
   #    line_items = [line1.sum, line2.sum, line3.sum].sort
   #
   #    minimum, lower25, median, upper25, maximum = getvals(line_items)
   #    course_dimensions =
   #            "chd=t0:-1,#{"%.02f"%minimum},-1|-1,#{"%.02f"%lower25},-1|-1,#{"%.02f"%upper25},-1|-1,#{"%.02f"%maximum},-1|-1,#{"%.02f"%median},-1"
   #    assert_match course_dimensions, url, "Course name should be correct"
   #  end
   
     def getvals(ary)
!!     maximum = ary.max
!!     minimum = ary.min
!!     median = median(ary)
!!     if ary.count % 2 == 1
!!       lower25 = median(ary[0..((ary.count / 2).ceil)], 0.25)
!!       upper25 = median(ary[((ary.count / 2).floor)..-1], 0.75)
       else
!!       lower25 = median(ary[0...(1 + ary.count / 2)], 0.25)
!!       upper25 = median(ary[(-1 + ary.count / 2)..-1], 0.75)
       end
   
!!     minimum *= 100.0 / maximum
!!     median  *= 100.0 / maximum
!!     lower25 *= 100.0 / maximum
!!     upper25 *= 100.0 / maximum
!!     maximum = 100.0
   
!!     [minimum, lower25, median, upper25, maximum]
     end
   
     def median(ary, pct = 0.5)
!!     middle = (ary.count + 1)/2.0
!!     middle -= 1 # convert from set index to array index (count from 0)
!!     if ary.nil? or ary.count == 0
         nil
!!     elsif ary.count == 1
!!       ary[0]
!!     elsif ary.count % 2 == 1
!!       ary[middle.floor]
       else
!!       ary[middle.floor] + (pct * (ary[middle.ceil] - ary[middle.floor]))
       end
     end
   
     before(:each) do
       login(FactoryGirl.create(:student_sam))
     end
   
     describe "#index" do
       it "should be successful" do
         get :index
         response.should be_success
       end
     end
   
     describe "#show_week" do
       it "should be successful" do
         get :show_week
         response.should be_success
       end
   
       context "when the week is passed and is in last year" do
         before do
           get :show_week, :week => '-1'
         end
   
         specify { assigns(:week_number).should == 1 }
         specify { assigns(:next_week_number).should == 2 }
         specify { assigns(:prev_week_number).should == 0 }
       end
   
       context "when the week is passed and is in the middle of the year" do
         before do
           get :show_week, :week => '26'
         end
   
         specify { assigns(:week_number).should == 26 }
         specify { assigns(:next_week_number).should == 27 }
         specify { assigns(:prev_week_number).should == 25 }
       end
   
       context "when the week is passed and is in the next year" do
         before do
           get :show_week, :week => '53'
         end
   
         specify { assigns(:week_number).should == 1 }
         specify { assigns(:next_week_number).should == 2 }
         specify { assigns(:prev_week_number).should == 0 }
       end
   
       context "when the week is in the middle of the year" do
         before do
           Date.any_instance.stub(:cweek).and_return(26)
           get :show_week
         end
   
         specify { assigns(:week_number).should == 26 }
         specify { assigns(:next_week_number).should == 27 }
         specify { assigns(:prev_week_number).should == 25 }
       end
     end
   end

================================================================================
 ./spec/controllers/generic_ajax_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe GenericAjaxController do
   
     context "get update_model_with_value" do
   
       context "for a valid request" do
         before :each do
           @user = FactoryGirl.create(:student_sam_user)
           login(@user)
           @instance = @user
           User.stub(:find_by_id).and_return(@instance)
         end
   
         it 'should call can? for authorization check' do
           ability = Object.new
           ability.extend(CanCan::Ability)
           controller.stub(:current_ability).and_return(ability)
           ability.should_receive(:can?)
   
           post :update_model_with_value, :model => 'User', :id => @user.id, :attribute => 'course_tools_view', :value => 'links'
         end
   
         it 'should update the value for a model ' do
           #@user = FactoryGirl.create(:faculty_frank)
           #login @user
   
           User.should_receive(:find_by_id)
   #        @instance.should_receive(:course_tools_view=).with('links')
           @instance.should_receive(:update_attribute).with('course_tools_view','links')
           post :update_model_with_value, :model => 'User', :id => @user.id, :attribute => 'course_tools_view', :value => 'links'
         end
       end
   
   
       context 'should handle invalid inputs' do
         it 'like a model that does not exist'
         it "like a row that isn't in the database"
         it "like a method that the model doesn't have"
       end
   
     end
   
   
   end

================================================================================
 ./spec/controllers/grades_controller_spec.rb
================================================================================
   require 'spec_helper'
   require 'controllers/permission_behavior'
   
   describe GradesController do
   
     before do
       @admin_andy = FactoryGirl.create(:admin_andy)
       @faculty_frank = FactoryGirl.create(:faculty_frank_user)
       @faculty_fagan = FactoryGirl.create(:faculty_fagan)
       @student_sam = FactoryGirl.create(:student_sam)
       @student_sally = FactoryGirl.create(:student_sally)
       @assign_1 = mock_model(Assignment, :id => 1)
       @course = mock_model(Course, :faculty => [@faculty_frank], :id => 1, :registered_students => [@student_sam, @student_sally], :assignments => [@assign_1, @assignment_2])
       Grade.delete_all
       @grade_sam_assign1   = stub_model(Grade, :course_id => @course.id, :assignment_id => @assign_1.id, :student_id => @student_sam.id, :score => "100")
       @grade_sally_assign1 = stub_model(Grade, :course_id => @course.id, :assignment_id => @assign_1.id, :student_id => @student_sally.id, :score => "100")
       Course.stub(:find).and_return(@course)
     end
   
     after do
       @admin_andy.delete
       @faculty_frank.delete
       @faculty_fagan.delete
       @student_sam.delete
       @student_sally.delete
     end
   
     describe "GET index for grades" do
   
       before(:each) do
         @course.stub(:registered_students_or_on_teams).and_return([@student_sam, @student_sally])
         @course.stub(:teams).and_return([Team.new, Team.new])
         @grading_rule = FactoryGirl.build(:grading_rule)
         @course.stub(:grading_rule).and_return(@grading_rule)
         Grade.stub(:get_grades_for_student_per_course).with(@course, @student_sam).and_return({@assign_1.id => @grade_sam_assign1})
         Grade.stub(:get_grades_for_student_per_course).with(@course, @student_sally).and_return({@assign_1.id => @grade_sally_assign1})
         @expected_grades = {@student_sam => {@assign_1.id => @grade_sam_assign1},
                             @student_sally => {@assign_1.id => @grade_sally_assign1}}
       end
   
       context "as the faculty owner of the course" do
         before do
           login(@faculty_frank)
         end
   
         it "assigns @grades" do
           get :index, :course_id => @course.id
           assigns(:grades).should  == @expected_grades
         end
       end
   
       context "as an admin" do
         before do
           login(@admin_andy)
         end
   
         it "assigns @grades" do
           get :index, :course_id => @course.id
           assigns(:grades).should  == @expected_grades
         end
       end
   
       context "as other users" do
         before do
           login(@faculty_fagan)
           get :index, :course_id => @course.id
         end
   
         it_should_behave_like "permission denied"
       end
   
     end
   
     describe "GET student_deliverables_for_course" do
       it 'assigns assignments' do
         login(@student_sam)
         @course = FactoryGirl.build(:course)
         @assignment = FactoryGirl.build(:assignment)
         Course.stub(:find).and_return(@course)
         @course.stub(:assignments).and_return([@assignment])
         get :student_deliverables_and_grades_for_course, :course_id => @course.id
         assigns(:assignments).should == [@assignment]
       end
     end
   
   
   end

================================================================================
 ./spec/controllers/page_attachments_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe PageAttachmentsController do
     context "As a faculty member," do
       before :each do
         @user = FactoryGirl.create(:faculty_frank)
         login @user
         @page = FactoryGirl.create(:page, :is_editable_by_all => false)
         @attachment = FactoryGirl.create(:page_attachment, :page => @page, :user => @user)
       end
   
       describe "performing PUT update on a page attachment" do
         before do
           put :update, :id => @attachment.id, :page_attachment => @attachment.attributes
         end
   
         it "should redirect to the page" do
!!         should redirect_to @page
         end
       end
   
       describe "POST create" do
         def do_post
           post :create, :page_attachment => FactoryGirl.build(:page_attachment, :page_id => @page.id).attributes
         end
   
         it "should create the attachment" do
           expect do
             do_post
           end.to change { PageAttachment.count }.by(1)
         end
   
         it "should redirect to the page" do
           do_post
!!         should redirect_to @page
         end
   
         context "if there is no file" do
           before do
             @blank_attachment = FactoryGirl.build(:blank_page_attachment, :page => @page)
           end
   
           def do_post
             post :create, :page_attachment => @blank_attachment.attributes
           end
   
           it "should not create the attachment" do
             PageAttachment.stub(:new).and_return(@blank_attachment)
             @blank_attachment.page.should_receive(:editable?).and_return(true)
             @blank_attachment.page_attachment.should_receive(:present?)
             @blank_attachment.should_not_receive(:save)
             do_post
           end
   
           it "should flash an error" do
             do_post
!!           flash[:error].should_not be_nil
           end
         end
       end
   
       describe "DELETE destroy" do
         def do_delete
           delete :destroy, :id => @attachment.id
   
         end
   
         it "should delete the attachment", :skip_on_build_machine => true  do
           @attachment.page.should_receive(:editable?).and_return(true)
           @attachment.should_receive(:destroy)
   
           PageAttachment.stub(:find).with(@attachment.id.to_s).and_return(@attachment)
           do_delete
         end
   
         it "should flash a notice", :skip_on_build_machine => true do
           @attachment.page.should_receive(:editable?).and_return(true)
           @attachment.stub(:destroy)
           PageAttachment.stub(:find).with(@attachment.id.to_s).and_return(@attachment)
   
           do_delete
           flash[:notice].should_not be_nil
         end
   
   
   
       end
     end
   
     context "As a student, on a page that is not editable by everyone," do
       before :each do
         @user = FactoryGirl.create(:student_sam)
         login @user
         @page = FactoryGirl.create(:page, :is_editable_by_all => false)
         @attachment = FactoryGirl.create(:page_attachment, :page => @page, :user_id => 1)
       end
   
       describe "performing PUT update on a page attachment" do
         before do
           put :update, :id => @attachment.id, :page_attachment => @attachment.attributes
         end
   
         it "should flash an error" do
!!         flash[:error].should_not be_nil
         end
   
         it "should redirect to the page" do
!!         should redirect_to @page
         end
       end
   
       describe "POST create" do
         def do_post
           post :create, :page_attachment => FactoryGirl.build(:page_attachment, :page_id => @page.id.to_s).attributes
         end
   
         it "should not create the attachment" do
           expect do
             do_post
           end.to change { PageAttachment.count }.by(0)
         end
   
         it "should flash an error" do
           do_post
!!         flash[:error].should_not be_nil
         end
   
         it "should redirect to the page" do
           do_post
!!         should redirect_to @page
         end
       end
   
       describe "DELETE destroy" do
         it "should not delete the attachment" do
           expect do
             delete :destroy, :id => @attachment.id
           end.to change { PageAttachment.count }.by(0)
         end
       end
     end
   end

================================================================================
 ./spec/controllers/page_comment_types_controller_spec.rb
================================================================================
   require 'spec_helper'
   require 'controllers/permission_behavior'
   
   describe PageCommentTypesController do
   
     let(:page_comment_type) { FactoryGirl.create(:page_comment_type) }
   
     context "any user can" do
       before do
         login(FactoryGirl.create(:student_sam))
         @redirect_url = page_comment_types_url
       end
   
       describe "GET index" do
         before do
           get :index
         end
   
         specify { assigns(:page_comment_types).should_not be_nil }
       end
   
   
       describe "GET show" do
         before do
           get :show, :id => page_comment_type.to_param
         end
   
         specify { assigns(:page_comment_type).should_not be_nil }
       end
   
       describe "GET new" do
         before do
           get :new
         end
   
         it_should_behave_like "permission denied"
       end
   
       describe "POST create" do
         before do
           @page_comment_type = FactoryGirl.build(:page_comment_type)
           post :create, :page_comment_type => @page_comment_type.attributes
         end
   
         it_should_behave_like "permission denied"
       end
   
       describe "PUT update" do
         before do
           put :update, :id => page_comment_type.to_param, :page_comment_type => {:name => 'NNNNN'}
         end
   
         it_should_behave_like "permission denied"
       end
   
       describe "DELETE destroy" do
         before do
           delete :destroy, :id => page_comment_type.to_param
         end
   
         it_should_behave_like "permission denied"
       end
   
     end
   
     context "any staff can" do
       before do
         login(FactoryGirl.create(:faculty_frank))
         @redirect_url = page_comment_types_url
       end
   
       describe "GET new " do
         before do
           get :new
         end
   
         specify { assigns(:page_comment_type).should_not be_nil }
       end
   
       describe "GET edit" do
         before do
           get :edit, :id => page_comment_type.to_param
         end
   
         specify { assigns(:page_comment_type).should == page_comment_type }
       end
   
   
       describe "POST create" do
   
         describe "with valid params" do
           before(:each) do
             @page_comment_type = FactoryGirl.build(:page_comment_type)
           end
   
           it "saves a newly created" do
             lambda {
               post :create, :page_comment_type => @page_comment_type.attributes
             }.should change(PageCommentType, :count).by(1)
           end
   
           it "redirects to the item" do
             post :create, :page_comment_type => @page_comment_type.attributes
             response.should redirect_to(page_comment_type_path(assigns(:page_comment_type).id))
           end
         end
   
         describe "with invalid params" do
           it "assigns a newly created but unsaved item as item" do
             lambda {
               post :create, :page_comment_type => {}
             }.should_not change(PageCommentType, :count)
             assigns(:page_comment_type).should_not be_nil
!!           assigns(:page_comment_type).should be_kind_of(PageCommentType)
           end
   
           it "re-renders the 'new' template" do
             post :create, :page_comment_type => {}
             response.should render_template("new")
           end
         end
       end
   
       describe "PUT update" do
   
         describe "with valid params" do
   
           before do
             put :update, :id => page_comment_type.to_param, :page_comment_type => {:name => 'NNNNN'}
           end
   
           it "updates the requested page_comment_type name" do
             page_comment_type.reload.name.should == "NNNNN"
           end
   
           it "should assign @page_comment_type" do
             assigns(:page_comment_type).should_not be_nil
           end
   
           it "redirects to the page_comment_type" do
             response.should redirect_to(page_comment_type_path(page_comment_type))
           end
         end
   
         describe "with invalid params" do
           before do
             put :update, :id => page_comment_type.to_param, :page_comment_type => {:name => ''}
           end
   
           it "should assign @page_comment_type" do
             assigns(:page_comment_type).should_not be_nil
           end
   
           it "re-renders the 'edit' template" do
             response.should render_template("edit")
           end
         end
   
       end
   
       describe "DELETE destroy" do
         before do
           delete :destroy, :id => page_comment_type.to_param
         end
   
         it_should_behave_like "permission denied"
       end
     end
   
   
     context "any admin can" do
   #    before do
   #      login(FactoryGirl.create(:admin_andy))
   #    end
   
       describe "DELETE destroy" do
   
         it "destroys the page_comment_type" do
   #       page_comment_type.should_receive(:destroy)
   
   #        lambda {
   #          a = Course.count
   #          c = page_comment_type
   #          delete :destroy, :id => page_comment_type.to_param
   #          b = Course.count
   #          t = 1
   #        }.should change(PageCommentType, :count).by(1)
         end
   
       end
   
     end
   end

================================================================================
 ./spec/controllers/page_comments_controller_spec.rb
================================================================================
   #require 'spec_helper'
   #require 'controllers/permission_behavior'
   #
   #describe PageCommentsController do
   #
   #
   #  let(:page_comment) { FactoryGirl.create(:page_comment) }
   #
   #
   #  context "any user can" do
   #    before do
   #      login(FactoryGirl.create(:student_sam))
   #    end
   #
   #    describe "GET index" do
   #      before do
   #        get :index
   #      end
   #
   #      specify { assigns(:page_comments).should_not be_nil }
   #    end
   #
   #
   #    describe "GET show" do
   #      before do
   #        get :show, :id => page_comment.to_param
   #      end
   #
   #      specify { assigns(:page_comment).should_not be_nil }
   #    end
   #
   #    describe "GET new " do
   #      before do
   #        get :new
   #      end
   #
   #      specify { assigns(:page_comment).should_not be_nil }
   #      specify { assigns(:types).should_not be_nil }
   #    end
   #
   #    describe "GET edit" do
   #      before do
   #        get :edit, :id => page_comment.to_param
   #      end
   #
   #      specify { assigns(:page_comment).should == page_comment }
   #      specify { assigns(:types).should_not be_nil }
   #    end
   #
   #    describe "POST create" do
   #
   #      describe "with valid params" do
   #        before(:each) do
   #          @page_comment = FactoryGirl.build(:page_comment)
   #        end
   #
   #        it "saves a newly created" do
   #          lambda {
   #            post :create, :page_comment => @page_comment.attributes
   #          }.should change(PageComment, :count).by(1)
   #        end
   #
   #        it "redirects to the item" do
   #          post :create, :page_comment => @page_comment.attributes
   #        end
   #
   #        it "emails the comment" do
   #          mailer = double("mailer")
   #          mailer.stub(:deliver)
   #          PageCommentMailer.should_receive(:comment_update).and_return(mailer)
   #          post :create, :page_comment => @page_comment.attributes
   #        end
   #      end
   #
   #      describe "with invalid params" do
   #        it "assigns a newly created but unsaved item as item" do
   #          lambda {
   #            post :create, :page_comment => {}
   #          }.should_not change(PageComment, :count)
   #          assigns(:page_comment).should_not be_nil
   #          assigns(:page_comment).should be_kind_of(PageComment)
   #        end
   #
   #        it "re-renders the 'new' template" do
   #          post :create, :page_comment => {}
   #          response.should render_template("new")
   #        end
   #      end
   #    end
   #
   #    describe "PUT update" do
   #      before do
   #        put :update, :id => page_comment.to_param, :page_comment => {:comment => 'NNNNN'}
   #      end
   #
   #      it_should_behave_like "permission denied"
   #    end
   #
   #    describe "DELETE destroy" do
   #      before do
   #        delete :destroy, :id => page_comment.to_param
   #      end
   #
   #      it_should_behave_like "permission denied"
   #    end
   #  end
   #
   #
   #  context "the author can" do
   #    before do
   #      login(FactoryGirl.create(:faculty_frank))
   #    end
   #
   #
   #    describe "PUT update" do
   #
   #      describe "with valid params" do
   #
   #        before do
   #          put :update, :id => page_comment.to_param, :page_comment => {:comment => 'NNNNN'}
   #        end
   #
   ##        it "updates the requested page_comment comment" do
   ##          page_comment.reload.comment.should == "NNNNN"
   ##        end
   #
   #        it "should assign @page_comment" do
   #          assigns(:page_comment).should_not be_nil
   #        end
   #
   #      end
   #
   #      describe "with invalid params" do
   #        before do
   #          put :update, :id => page_comment.to_param, :page_comment => {:comment => ''}
   #        end
   #
   #        it "should assign @page_comment" do
   #          assigns(:page_comment).should_not be_nil
   #        end
   #
   ##        it "re-renders the 'edit' template" do
   ##          response.should render_template("edit")
   ##        end
   #      end
   #
   #    end
   #
   #    describe "DELETE destroy" do
   #      before do
   #        delete :destroy, :id => page_comment.to_param
   #      end
   #
   #      it_should_behave_like "permission denied"
   #    end
   #  end
   #
   #
   #  context "any admin can" do
   ##    before do
   ##      login(FactoryGirl.create(:admin_andy))
   ##    end
   #
   #    describe "DELETE destroy" do
   #
   #      it "destroys the page_comment" do
   ##       page_comment.should_receive(:destroy)
   #
   ##        lambda {
   ##          a = Course.count
   ##          c = page_comment
   ##          delete :destroy, :id => page_comment.to_param
   ##          b = Course.count
   ##          t = 1
   ##        }.should change(PageComment, :count).by(1)
   #      end
   #
   #    end
   #
   #  end
   #end

================================================================================
 ./spec/controllers/pages_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe PagesController do
     shared_examples_for "finding page" do
!!   before(:each) do
!!     Page.any_instance.stub(:update_search_index)
!!     Page.any_instance.stub(:delete_from_search)
     end
   
!!   context "any user can" do
!!     before do
!!       Page.delete_all
!!       login(FactoryGirl.create(:student_sam))
!!       @page = FactoryGirl.create(:page)
       end
   
   
!!       it "assigns page" do
!!         assigns(:page).should == @page
         end
   
   
!!     describe "GET index" do
!!       it "assigns all pages as @pages" do
!!         get :index
!!         assigns(:pages).should_not be_nil
         end
       end
   
!!     describe "GET show" do
!!       before do
!!         get :show, :id => @page.to_param
         end
!!       it_should_behave_like "finding page"
       end
   
!!     describe "when requesting a page that does not exist" do
!!       before do
!!         @nonexistent_page_id = "some_page"
!!         get :show, :id => @nonexistent_page_id
         end
   
!!       it "should redirect to GET new" do
!!         response.should redirect_to(:controller => :pages, :action => :new, :url => @nonexistent_page_id)
         end
   
!!       it "should prepopulate the requested name" do
!!         get :new, :url => @nonexistent_page_id
!!         assigns(:page).url.should == @nonexistent_page_id
         end
   
!!       it "should display a helpful message" do
!!         flash[:error].should == "Page with an id of #{@nonexistent_page_id} is not in this system. You may create it using the form below."
         end
       end
   
!!     describe "GET new" do
!!       it "assigns a new page as page" do
!!         get :new
!!         assigns(:page).should_not be_nil
         end
       end
   
!!     describe "GET edit" do
!!       before do
!!         get :edit, :id => @page.to_param
         end
!!       it_should_behave_like "finding page"
       end
!!     describe "GET show with non-exist page" do
!!       it "redirects to the pages index" do
!!         @page_name = 'some_new_page_i_made_up'
!!         @stylized_page_name = 'Some New Page I Made Up'
!!         get :show, :id => @page_name
!!         response.code.should == "302"
!!         response.should redirect_to(new_page_url(:url => @page_name))
!!         flash[:error].should == "Page with an id of #{@page_name} is not in this system. You may create it using the form below."
         end
   
!!       it "new should handle the title GET parameter and assign it to page title and page url" do
!!         @page_name = 'some_new_page_i_made_up'
!!         @stylized_page_name = 'Some New Page I Made Up'
!!         get :new, :url => @page_name
!!         response.code.should == "200"
!!         assigns(:page).title.should == @stylized_page_name
!!         assigns(:page).url.should == @page_name
         end
   
!!       it "should handle titles with no underscores" do
!!         @page_name = "hello"
!!         @stylized_page_name = "Hello"
!!         get :new, :url => @page_name
!!         response.code.should == "200"
!!         assigns(:page).title.should == @stylized_page_name
!!         assigns(:page).url.should == @page_name
         end
   
!!       it "should handle title with non-alphabetic characters after an underscore" do
!!         @page_name = "page_name_%goes_$here"
!!         @stylized_page_name = "Page Name %goes $here"
!!         get :new, :url => @page_name
!!         response.code.should == "200"
!!         assigns(:page).title.should == @stylized_page_name
!!         assigns(:page).url.should == @page_name
         end
   
!!       it "should truncate underscores that are at the end of the title" do
!!         @page_name = "page_name_with_trailing_underscore_"
!!         @stylized_page_name = "Page Name With Trailing Underscore"
!!         get :new, :url => @page_name
!!         response.code.should == "200"
!!         assigns(:page).title.should == @stylized_page_name
!!         assigns(:page).url.should == @page_name
         end
       end
     end
   
!!   context "as a student can" do
!!     before do
!!       Page.delete_all
!!       login(FactoryGirl.create(:student_sam))
!!       @page = FactoryGirl.create(:page, :title => "new title", :viewable_by => "staff", :is_editable_by_all => false)
       end
   
!!     describe "GET show" do
!!       it "but not for a page that is viewable only by faculty" do
!!         get :show, :id => @page.to_param
!!         response.should redirect_to(root_url)
         end
       end
   
!!     describe "GET edit" do
!!       it "but not for a page that is editable only by faculty" do
!!         get :edit, :id => @page.to_param
!!         response.should redirect_to(page_url)
         end
       end
   
!!     describe "POST update" do
!!       it "but not for a page that is editable only by faculty" do
!!         @page.is_editable_by_all = false
!!         @page.save
!!         post :update, :page => @page.attributes, :id => @page.to_param
!!         response.should redirect_to(page_url)
!!         flash[:error].should == "You don't have permission to do this action."
         end
   
!!       it "will update updated_by_user_id"
       end
   
!!     describe "POST revert" do
!!       it "a page that is editable by all" do
!!         @page.update_attributes :viewable_by => "users", :is_editable_by_all => true
!!         post :revert, :id => @page.to_param, :version => 1
!!         current_version = @page.versions.find_by_number 3
!!         current_version.reverted_from.should == 1
!!         response.should redirect_to(page_url)
         end
   
!!       it "but not for a page that is editable only by faculty" do
!!         post :revert, :id => @page.to_param, :version => 1
!!         response.should redirect_to(page_url)
         end
       end
     end
   
!!   context "as a faculty member can" do
!!     before do
!!       login(FactoryGirl.create(:faculty_frank))
   
!!       @page = FactoryGirl.create(:page, :title => "new title", :viewable_by => "staff", :is_editable_by_all => false)
       end
   
!!     describe "GET show" do
!!       context "for a page that is not vieweable by all" do
!!         before do
!!           get :show, :id => @page.to_param
           end
!!         it_should_behave_like "finding page"
         end
       end
   
!!     describe "GET edit" do
!!       context "for a page that is not editable by all" do
!!         before do
!!           get :edit, :id => @page.to_param
           end
!!         it_should_behave_like "finding page"
   
!!         it "should show a notice when someone else is editing the page" do
!!           sign_out @current_user
!!           login(FactoryGirl.create(:faculty_fagan))
!!           get :edit, :id => @page.to_param
!!           flash[:notice].should include("Faculty Frank")
           end
   
!!         it "shouldn't show a notice when someone has been editing the page for more than 30 minutes" do
!!           sign_out @current_user
!!           login(FactoryGirl.create(:faculty_fagan))
!!           @page.current_edit_started_at = 30.minutes.ago
!!           @page.save
!!           get :edit, :id => @page.to_param
!!           flash[:notice].should be_nil
           end
   
!!         it "shouldn't show a notice when someone has finished editing a page" do
!!           post :update, :page => @page.attributes, :id => @page.to_param
!!           sign_out @current_user
!!           login(FactoryGirl.create(:faculty_fagan))
!!           get :edit, :id => @page.to_param
!!           flash[:notice].should_not include("editing")
           end
   
!!         it "shouldn't show a notice when the same person is editing the page" do
!!           get :edit, :id => @page.to_param
!!           flash[:notice].should be_nil
           end
         end
       end
   
!!     describe "POST revert" do
!!       it "a page that is editable by faculty" do
!!         @page.update_attribute :title, "the title for next version"
!!         post :revert, :id => @page.to_param, :version => 1
!!         current_version = @page.versions.find_by_number 3
!!         current_version.reverted_from.should == 1
!!         response.should redirect_to(page_url)
         end
       end
     end
   
   
   #  it "allows named pages in the url" do
   #     @ppm = FactoryGirl.create(:ppm)
   #       { :get => "/pages/#{@ppm.url}" }.should be_routable
   #       get "/pages/#{@ppm.url}"
   #       response.code.should == "302"
   #  end
   
   #  it "allows named urls with additional / " do
   #    { :get => "/pages/ppm/announcements" }.should be_routable
   #     get "/pages/ppm/announcements"
   ##       need to create ppm model in test database
   ##       response.code.should == "302"
   #  end
   
   
   #  describe "SHOW page" do
   #    context "all pages" do
   #      it "should allow anyone to add comments to the page"
   #    end
   #
   #    context "three tab page" do
   #      it "should show three tabs"
   #      it "should show all the tasks in the course"
   #    end
   #
   #    context "normal page" do
   #      it ""
   #    end
   #
   #  end
   #
   #
   #  describe "SOMETHING ELSE" do
   #    it "should allow faculty to bundle pages together in an order"
   #    it "should allow faculty to reorder the items in the bundle"
   #    it "should allow a bundle to be copied for another course"
   #  end
   #
   #  describe "NEW page" do
   #    it "should allow faculty to upload attachments"
   #    it "should allow faculty to choose between normal page or three tabs"
   #  end
   #
   #
   #  describe "EDIT page" do
   #    it "should do everything that NEW page does"
   #    it "should allow faculty to replace an attachment"
   #    it "should saves previous versions of the page"
   #    it "should allow faculty to comment about the changes"
   #    it "should allow three tab page to be converted to normal page without loosing three tab content"
   #    it "should allow normal page to be converted to three tab page with contents ending in tab one"
   #
   #  end
   
     end
   end
   

================================================================================
 ./spec/controllers/password_resets_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe PasswordResetsController do
   
     describe 'GET index' do
       before do
         get :index
       end
       it 'should redirect to new password resets path' do
         response.should redirect_to( new_password_reset_path )
       end
     end
   
     describe 'POST create' do
       before do
         @student_sam = FactoryGirl.create(:student_sam_user,
                                           :password_reset_token=>"ToKeN",
                                           :password_reset_sent_at=>Time.now)
           @active_directory_services = ActiveDirectory.new
       end
   
       context "valid personal email" do
         it 'should send password reset instructions' do
           User.stub(:find_by_email) { @student_sam }
           ActiveDirectory.stub(:new) { @active_directory_services }
           @active_directory_services.should_receive(:send_password_reset_token)
           post :create, :primaryEmail=>@student_sam.email
         end
       end
   
       context "invalid personal email" do
         before do
           post :create, :primaryEmail=>"invalid_email"
         end
         it 'should redirect to root_url' do
           response.should redirect_to( new_password_reset_path )
         end
         it 'flash error message' do
           flash[:error].should_not be_nil
         end
       end
     end
   
     describe 'GET edit' do
       before do
         get :edit, :id => "invalid_url"
       end
       it 'should redirect to new password reset path if reset_link is invalid' do
         response.should redirect_to( new_password_reset_path )
       end
       it 'should flash error if reset_link is invalid' do
         flash[:error].should == "Password reset link has expired."
       end
     end
   
     describe 'POST update' do
       before do
         @ldap_server = Ladle::Server.new(:quiet => true, :port=>3897).start
!!       @student_sam = FactoryGirl.create(:student_sam_user,
                                           :password_reset_token=>"ToKeN",
                                           :password_reset_sent_at=>Time.now)
!!       @active_directory_services = ActiveDirectory.new
!!       ActiveDirectory.stub(:new).and_return(@active_directory_services)
       end
       after do
         @ldap_server.stop if @ldap_server
       end
   
       context "success" do
         before do
!!         @active_directory_services.stub(:reset_password).with(@student_sam, "newPass").and_return("Success")
!!         put :update, :id => @student_sam.password_reset_token, :newPassword=>"newPass"
         end
         it 'should flash notice with success' do
!!         flash[:notice].should == "Password has been reset!"
         end
         it 'should redirect to root url' do
!!         response.should redirect_to( root_url )
         end
       end
   
       context "failure" do
         before do
!!         @active_directory_services.stub(:reset_password).with(@student_sam, "newPass").and_return("Any other message")
!!         put :update, :id => @student_sam.password_reset_token, :newPassword=>"newPass"
         end
         it 'should flash error' do
!!         flash[:error].should_not be_nil
         end
         it 'should redirect to new_password_reset_path' do
!!         response.should redirect_to( edit_password_reset_path )
         end
       end
     end
   end

================================================================================
 ./spec/controllers/peer_evaluation_controller_spec.rb
================================================================================

================================================================================
 ./spec/controllers/people_controller_spec.rb
================================================================================
   require "spec_helper"
   
   describe PeopleController do
     context "admin user can" do
       before do
   
         @admin_andy = FactoryGirl.create(:admin_andy)
         login(@admin_andy)
         controller.stub(:image_path)
       end
   
       describe "POST people#upload_photo" do
         before(:each) do
           @faculty_frank = FactoryGirl.create(:faculty_frank_user)
           @photo = fixture_file_upload('/sample_photo.png', 'image/png')
           controller.stub(:image_path)
         end
   
         it "can upload first photo", :skip_on_build_machine => true do
           @faculty_frank.photo_first = @photo
           post :upload_photo, {:id => @faculty_frank.id, :user => @faculty_frank.attributes.merge({:photo_first => @faculty_frank.photo_first}) }
           User.find(@faculty_frank.id).image_uri_first.should include "people/46/photo_first/profile/sample_photo.png"
!!         response.should redirect_to(edit_person_path(@faculty_frank))
         end
   
         it "can upload second photo", :skip_on_build_machine => true do
           @faculty_frank.photo_second = @photo
           post :upload_photo, {:id => @faculty_frank.id, :user => @faculty_frank.attributes.merge({:photo_second => @faculty_frank.photo_second}) }
           User.find(@faculty_frank.id).image_uri_second.should include "people/46/photo_second/profile/sample_photo.png"
!!         response.should redirect_to(edit_person_path(@faculty_frank))
         end
   
         it "can upload custom photo", :skip_on_build_machine => true do
           @faculty_frank.photo_custom = @photo
           post :upload_photo, {:id => @faculty_frank.id, :user => @faculty_frank.attributes.merge({:photo_custom => @faculty_frank.photo_custom}) }
           User.find(@faculty_frank.id).image_uri_custom.should include "people/46/photo_custom/profile/sample_photo.png"
!!         response.should redirect_to(edit_person_path(@faculty_frank))
         end
   
         it "can select first photo", :skip_on_build_machine => true do
           @faculty_frank.photo_first = @photo
           @faculty_frank.photo_selection = "first"
           post :upload_photo, {:id => @faculty_frank.id, :user => @faculty_frank.attributes.merge({:photo_first => @faculty_frank.photo_first}) }
           User.find(@faculty_frank.id).image_uri.should include "people/46/photo_first/profile/sample_photo.png"
!!         response.should redirect_to(edit_person_path(@faculty_frank))
         end
   
         it "can select second photo", :skip_on_build_machine => true do
           @faculty_frank.photo_second = @photo
           @faculty_frank.photo_selection = "second"
           post :upload_photo, {:id => @faculty_frank.id, :user => @faculty_frank.attributes.merge({:photo_second => @faculty_frank.photo_second}) }
           User.find(@faculty_frank.id).image_uri.should include "people/46/photo_second/profile/sample_photo.png"
!!         response.should redirect_to(edit_person_path(@faculty_frank))
         end
   
         it "can select custom photo", :skip_on_build_machine => true do
           @faculty_frank.photo_custom = @photo
           @faculty_frank.photo_selection = "custom"
           post :upload_photo, {:id => @faculty_frank.id, :user => @faculty_frank.attributes.merge({:photo_first => @faculty_frank.photo_custom}) }
           User.find(@faculty_frank.id).image_uri.should include "people/46/photo_custom/profile/sample_photo.png"
!!         response.should redirect_to(edit_person_path(@faculty_frank))
         end
   
         it "can select anonymous photo" do
           @faculty_frank.photo_selection = "anonymous"
           post :upload_photo, {:id => @faculty_frank.id, :user => @faculty_frank.attributes }
           User.find(@faculty_frank.id).image_uri.should include "mascot.jpg"
           response.should redirect_to(edit_person_path(@faculty_frank))
         end
       end
     end
   
   
     context "any user can" do
       before do
         @student_sam = FactoryGirl.create(:student_sam_user, :is_part_time=>'f', :masters_program=>'SE', :is_active=>'t')
         login(@student_sam)
         controller.stub(:image_path)
       end
   
       # describe "GET index" do
       #   it "should assign all active people to people" do
       #     get :index
       #     assigns(:people).should  == [@student_sam]
       #   end
   
       #   it "should sort people by name" do
       #     get :index
       #     assigns(:people).should == [@student_sam]
       #   end
       # end
       describe "POST people#upload_photo" do
         before(:each) do
           @faculty_frank = FactoryGirl.create(:faculty_frank_user)
           @photo = fixture_file_upload('/sample_photo.png', 'image/png')
         end
   
         it "cannot upload first photo" do
           @faculty_frank.photo_first = @photo
           post :upload_photo, {:id => @faculty_frank.id, :user => @faculty_frank.attributes.merge({:photo_first => @faculty_frank.photo_first}) }
           User.find(@faculty_frank.id).image_uri_first.should include "people/46/photo_first/profile/sample_photo.png"
!!         response.should redirect_to(edit_person_path(@faculty_frank))
         end
   
         it "cannot upload second photo" do
           @faculty_frank.photo_second = @photo
           post :upload_photo, {:id => @faculty_frank.id, :user => @faculty_frank.attributes.merge({:photo_second => @faculty_frank.photo_second}) }
           User.find(@faculty_frank.id).image_uri_second.should include "people/46/photo_second/profile/sample_photo.png"
!!         response.should redirect_to(edit_person_path(@faculty_frank))
         end
   
         it "can upload custom photo", :skip_on_build_machine => true do
           @faculty_frank.photo_custom = @photo
           post :upload_photo, {:id => @faculty_frank.id, :user => @faculty_frank.attributes.merge({:photo_custom => @faculty_frank.photo_custom}) }
           User.find(@faculty_frank.id).image_uri_custom.should include "people/46/photo_custom/profile/sample_photo.png"
!!         response.should redirect_to(edit_person_path(@faculty_frank))
         end
   
         it "can select first photo" do
           @faculty_frank.photo_first = @photo
           @faculty_frank.photo_selection = "first"
           post :upload_photo, {:id => @faculty_frank.id, :user => @faculty_frank.attributes.merge({:photo_first => @faculty_frank.photo_first}) }
           User.find(@faculty_frank.id).image_uri.should include "people/46/photo_first/profile/sample_photo.png"
!!         response.should redirect_to(edit_person_path(@faculty_frank))
         end
   
         it "can select second photo" do
           @faculty_frank.photo_second = @photo
           @faculty_frank.photo_selection = "second"
           post :upload_photo, {:id => @faculty_frank.id, :user => @faculty_frank.attributes.merge({:photo_second => @faculty_frank.photo_second}) }
           User.find(@faculty_frank.id).image_uri.should include "people/46/photo_second/profile/sample_photo.png"
!!         response.should redirect_to(edit_person_path(@faculty_frank))
         end
   
         it "can select custom photo" do
           @faculty_frank.photo_custom = @photo
           @faculty_frank.photo_selection = "custom"
           post :upload_photo, {:id => @faculty_frank.id, :user => @faculty_frank.attributes.merge({:photo_first => @faculty_frank.photo_custom}) }
           User.find(@faculty_frank.id).image_uri.should include "people/46/photo_custom/profile/sample_photo.png"
!!         response.should redirect_to(edit_person_path(@faculty_frank))
         end
   
         it "can select anonymous photo" do
           @faculty_frank.photo_selection = "anonymous"
           post :upload_photo, {:id => @faculty_frank.id, :user => @faculty_frank.attributes }
           User.find(@faculty_frank.id).image_uri.should include "mascot.jpg"
           response.should redirect_to(edit_person_path(@faculty_frank))
         end
       end
       describe "GET people#search" do
           before(:each) do
               @faculty_frank = FactoryGirl.create(:faculty_frank_user)
               @student_sally = FactoryGirl.create(:student_sally_user, :is_part_time=>'t', :graduation_year=>'2012', :is_active=>'t')
               controller.stub(:image_path)
           end
   
           # it "should find student_sam_user in the search results" do
           #     get :search, :filterBoxOne => @student_sam.first_name
           #     assigns(:people).should include @student_sam
           # end
   
           context "students" do
               it "and find students only" do
                   get :search, :user_type => "S"
                   assigns(:people).should include @student_sam
!!                 assigns(:people).should_not include @faculty_frank
               end
               it "should find active students only" do
                   @student_sally.is_active='f'
                   @student_sally.save
                   get :search, :user_type=>'S'
                   assigns(:people).should_not include @student_sally
!!                 assigns(:people).should include @student_sam
               end
               it "and find student Sam, not student Sally" do
                   get :search, :user_type => "S", :filterBoxOne => @student_sam.last_name
                   assigns(:people).should include @student_sam
!!                 assigns(:people).should_not include @student_sally
               end
   
               it "should find all full-time students" do
                   get :search, :user_type => "SL"
                   assigns(:people).should include @student_sam
!!                 assigns(:people).should_not include @student_sally
               end
   
               it "should find all SE students" do
                   get :search, :user_type=>'S', :masters_program => "SE"
                   assigns(:people).should include @student_sam
!!                 assigns(:people).should_not include @student_sally
               end
               it "should find all students from class of 2012" do
                   get :search, :user_type=>'S', :graduation_year => "2012"
                   assigns(:people).should include @student_sally
!!                 assigns(:people).should_not include @student_sam
!!                 assigns(:people).should_not include @faculty_frank
               end
               it "should find inactive students" do
                   @student_sally.is_active='f'
                   @student_sally.save
                   get :search, :user_type=>'S', :search_inactive => "t"
                   assigns(:people).should include @student_sally
!!                 assigns(:people).should include @student_sam
               end
   
               it 'should find all students belonging to a certain course' do
                   #pending
                   # create course
                   # create association
                   # get 'S' 'course'
                   # assigns should include student
                   @course = FactoryGirl.create(:mfse)
                   @sally_mfse = FactoryGirl.create(:sally_mfse, :course_id=>@course.id, :user_id => @student_sally.id)
                   get :search, :user_type=>'S', :course_id => @course.id
                   assigns(:people).should include @student_sally
!!                 assigns(:people).should_not include @student_sam
               end
   
               it "should find student whose biography contains the word google" do
                 @student_sally.biography='has worked at google company'
                 @student_sally.save
                 get :search, :filterBoxOne=>'google'
                 assigns(:people).should include @student_sally
!!               assigns(:people).should_not include @student_sam
               end
   
           end
   
   
   
           context "faculty & staff" do
             it "should find faculty only"
             it "should find inactive faculty"
             it "should find staff only"
             it "should find active faculty and staff"
             it "should find inactive faculty and staff"
           end
   
   
           #it "should find students who graduated in 2012 from the full-time SE program " do
           #  get :search, :filterBoxOne => @student_sam.first_name
           #  assigns(:people).should include @student_sam
           #end
       end
   
       describe "GET show" do
         it "should find person by name" do
           get :show, :id => @student_sam.twiki_name
           assigns(:person).should eql @student_sam
         end
   
         it "should find person by id" do
           get :show, :id => @student_sam.id.to_s
           assigns(:person).should eql @student_sam
         end
       end
   
       describe "POST create" do
         it "should not be allowed" do
           expect { new_person = FactoryGirl.build(:faculty_frank_user)
           post :create, :person => new_person }.to_not change { User.count }
   
         end
       end
   
       describe "check_webiso_account" do
         it "should return true for an existing webiso account" do
           get :ajax_check_if_webiso_account_exists, :q => @student_sam.webiso_account, :format => :json
           response.should be_success
   
!!         json_response = JSON.parse(response.body)
!!         json_response["exists"].should == true
         end
   
         it "should return false for a non-existing webiso account" do
           get :ajax_check_if_webiso_account_exists, :q => "not-in-system", :format => :json
           response.should be_success
   
!!         json_response = JSON.parse(response.body)
!!         json_response["exists"].should == false
         end
       end
   
       describe "check_email" do
         it "should return true for an existing email" do
           get :ajax_check_if_email_exists, :q => @student_sam.email, :format => :json
           response.should be_success
   
!!         json_response = JSON.parse(response.body)
!!         json_response["exists"].should == true
         end
   
         it "should return false for a non-existing email" do
           get :ajax_check_if_email_exists, :q => "not-in-system", :format => :json
           response.should be_success
   
!!         json_response = JSON.parse(response.body)
!!         json_response["exists"].should == false
         end
       end
   
       describe "GET edit" do
         it "should render edit page" do
           get :edit, :id => @student_sam.id
           should render_template("edit")
         end
       end
   
       context "from the twiki server, the user is not logged in" do
         before do
           controller.stub(:current_user).and_return(nil)
         end
         it "should flash an error" do
           get :show_by_twiki
           flash[:error].should eql "You don't have permissions to view this data."
         end
       end
   
       context "with a bad person id" do
         before do
           User.stub(:find).and_return(nil)
           @id = 2
         end
   
         describe "GET my teams" do
           before do
             get :my_teams, :id => @id
           end
   
           it "should flash error message" do
             flash[:error].should eql 'Person with an id of 2 is not in this system.'
           end
   
           it "should redirect to people_url" do
             assert_redirected_to people_url
           end
         end
   
         describe "GET my courses" do
           before do
             get :my_courses, :id => @id
           end
   
           it "should redirect to people_url" do
             assert_redirected_to people_url
           end
   
           it "should flash error message" do
             flash[:error].should eql 'Person with an id of 2 is not in this system.'
           end
         end
       end
     end
   end

================================================================================
 ./spec/controllers/permission_behavior.rb
================================================================================
    shared_examples_for "permission denied" do
       it "can't access page" do
         if @redirect_url.blank?
           response.should redirect_to(root_path)
         else
           response.should redirect_to(@redirect_url)
         end
!!       flash[:error].should == I18n.t(:no_permission)
       end
    end
     
     shared_examples_for "not editable" do
!!     it "can't edit object" do
!!       if @redirect_url.blank?
!!         response.should redirect_to(root_path)
         else
!!         response.should redirect_to(@redirect_url)
         end
!!       flash[:error].should == I18n.t(:not_editable)
       end
     end
   
     shared_examples_for "permission denied for person deliverable" do
       it "can't access page" do
!!       if @redirect_url.blank?
!!         response.should redirect_to(root_path)
         else
!!         response.should redirect_to(@redirect_url)
         end
!!       flash[:error].should == I18n.t(:not_your_deliverable)
       end
     end
   
   
     shared_examples_for "cancan permission denied" do
       it "can't access page" do
         if @redirect_url.blank?
           response.should redirect_to(root_path)
         else
!!         response.should redirect_to(@redirect_url)
         end
       end
     end

================================================================================
 ./spec/controllers/presentations_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe PresentationsController do
     context "any user can" do
       before do
         @student_sam = FactoryGirl.create(:student_sam)
         login(@student_sam)
         @presentation = FactoryGirl.create(:presentation)
       end
   
       describe "GET" do
         it "presentations that are going to be given today" do
           @presentation.presentation_date = Date.today
           @presentation.save
   
           get :today
           presentations = assigns :presentations
           presentations.length.should == 1
         end
       end
   
       describe "GET index" do
         it "should return the index page with the presentations variable listed in descending order" do
           FactoryGirl.create(:presentation_for_team_bean_counters, :presentation_date => Date.today)
           get :index
           presentations = assigns :presentations
           presentations.length.should == 2
!!         presentations.first.presentation_date.should == Date.today
         end
       end
   
       describe "GET new_feedback" do
         it "should redirect to presentation view if it does not exist" do
   
         end
         
         it "should pass its view an instance variable for the presentation from the given id" do
           get :new_feedback, :id => @presentation.id
           presentation = assigns :presentation
   
           presentation.id.should == @presentation.id
         end
   
         it "should pass its view a new feedback" do
           get :new_feedback, :id => @presentation.id
           feedback = assigns :feedback
   
           feedback.presentation_id.should == @presentation.id
         end
   
         it "should pass its view a list of questions" do
           get :new_feedback, :id => @presentation.id
           questions = assigns :questions
   
           questions.length.should == PresentationFeedback.count
!!         questions.each do |q|
!!           q.text.should == PresentationFeedback.find(q.id).text
           end
         end
       end
   
       describe "POST create_feedback" do
   
         before do
           @q1 = FactoryGirl.create(:presentation_feedback_questions, :text => "q1")
           @q2 = FactoryGirl.create(:presentation_feedback_questions, :text => "q2")
           @q3 = FactoryGirl.create(:presentation_feedback_questions, :text => "q3")
           @q4 = FactoryGirl.create(:presentation_feedback_questions, :text => "q4")
         end
   
         it "record the returned feedback" do
           feedback = {
             "presentation_id" => @presentation.id
           }
           evaluation = {
             @q1.id => {"rating" => 1, "comment" => "comment 1"},
             @q2.id => {"rating" => 2, "comment" => "comment 2"},
             @q3.id => {"rating" => 3, "comment" => "comment 3"},
             @q4.id => {"rating" => 4, "comment" => "comment 4"}
           }
   
           start_date = DateTime.now
           post :create_feedback, {:feedback => feedback, :evaluation => evaluation, :id => @presentation.id}
   
           feedback = PresentationFeedback.where("created_at >= ?", start_date)
           feedback.length.should == 1
!!         feedback = feedback[0]
!!         feedback.presentation_id.should == @presentation.id
!!         response.should redirect_to(today_presentations_url)
   
!!         answers = PresentationFeedbackAnswer.where("created_at >= ?", start_date)
!!         answers.length.should == 4
   
!!         answers.each do |a|
!!           a.feedback.should == feedback
           end
         end
   
         it "record the returned feedback with user filled in" do
           @presentation.user_id = @student_sam.id
           @presentation.save
   
           feedback = {
             "presentation_id" => @presentation.id
           }
           evaluation = {
             @q1.id => {"rating" => 1, "comment" => "comment 1"},
             @q2.id => {"rating" => 2, "comment" => "comment 2"},
             @q3.id => {"rating" => 3, "comment" => "comment 3"},
             @q4.id => {"rating" => 4, "comment" => "comment 4"}
           }
   
           start_date = DateTime.now
           post :create_feedback, {:feedback => feedback, :evaluation => evaluation, :id => @presentation.id }
           feedback = assigns :feedback
           feedback.presentation.user_id.should == @student_sam.id
         end
   
         it "should redirect to new feedback page if an evaluation has an invalid ID" do
           feedback = {
               "presentation_id" => @presentation.id
           }
           evaluation = {
               1000 => {"rating" => 1, "comment" => "comment 1"}
           }
   
           post :create_feedback, {:feedback => feedback, :evaluation => evaluation, :id => @presentation.id}
   
           response.should render_template('new_feedback')
         end
   
       end
   
       describe "GET edit_feedback" do
         before do
           @q1 = FactoryGirl.create(:presentation_feedback_questions, :text => "q1")
           @q2 = FactoryGirl.create(:presentation_feedback_questions, :text => "q2")
           @q3 = FactoryGirl.create(:presentation_feedback_questions, :text => "q3")
           @q4 = FactoryGirl.create(:presentation_feedback_questions, :text => "q4")
         end
   
         it "that they have given" do
           student_sally = FactoryGirl.create(:student_sally)
           login(student_sally)
           local_feedback = {
             "presentation_id" => @presentation.id
           }
           evaluation = {
             @q1.id => {"rating" => 1, "comment" => "comment 1"},
             @q2.id => {"rating" => 2, "comment" => "comment 2"},
             @q3.id => {"rating" => 3, "comment" => "comment 3"},
             @q4.id => {"rating" => 4, "comment" => "comment 4"}
           }
   
           start_date = DateTime.now
           post :create_feedback, {:feedback => local_feedback, :evaluation => evaluation, :id => @presentation.id}
           response.should redirect_to(today_presentations_url)
           
!!         get :edit_feedback, {:id => @presentation.id}
           # response.should redirect_to(edit_feedback_for_presentation_path)
!!         feedback = assigns :feedback
!!         ratings = assigns :ratings
!!         comments = assigns :comments
   
!!         feedback.evaluator_id.should == student_sally.id 
!!         ratings.should include(1,2,3,4)
!!         comments.should include("comment 1", "comment 2", "comment 3", "comment 4")
   
   
         end
       end
   
       describe "PUT edit_feedback" do
         before do
           @q1 = FactoryGirl.create(:presentation_feedback_questions, :text => "q1")
           @q2 = FactoryGirl.create(:presentation_feedback_questions, :text => "q2")
           @q3 = FactoryGirl.create(:presentation_feedback_questions, :text => "q3")
           @q4 = FactoryGirl.create(:presentation_feedback_questions, :text => "q4")
         end
   
         it "that they have given" do
           student_sally = FactoryGirl.create(:student_sally)
           login(student_sally)
           local_feedback = {
             "presentation_id" => @presentation.id
           }
           evaluation = {
             @q1.id => {"rating" => 1, "comment" => "comment 1"},
             @q2.id => {"rating" => 2, "comment" => "comment 2"},
             @q3.id => {"rating" => 3, "comment" => "comment 3"},
             @q4.id => {"rating" => 4, "comment" => "comment 4"}
           }
   
           start_date = DateTime.now
           post :create_feedback, {:feedback => local_feedback, :evaluation => evaluation, :id => @presentation.id}
           response.should redirect_to(today_presentations_url)
           
!!         get :edit_feedback, {:id => @presentation.id}
           # response.should redirect_to(edit_feedback_for_presentation_path)
!!         feedback = assigns :feedback
!!         ratings = assigns :ratings
!!         comments = assigns :comments
   
!!         feedback.evaluator_id.should == student_sally.id 
!!         ratings.should include(1,2,3,4)
!!         comments.should include("comment 1", "comment 2", "comment 3", "comment 4")
   
!!         edited_evaluation = {
             @q1.id => {"rating" => 4, "comment" => "comment 1 edited"},
             @q2.id => {"rating" => 3, "comment" => "comment 2 edited"},
             @q3.id => {"rating" => 2, "comment" => "comment 3 edited"},
             @q4.id => {"rating" => 1, "comment" => "comment 4 edited"}
           }
!!         post :edit_feedback, {:id => @presentation.id, :evaluation => edited_evaluation }
   
!!         new_feedback = PresentationFeedback.where("created_at >= ?", start_date)
!!         new_feedback.length.should == 1
!!         new_feedback = new_feedback[0]
!!         new_feedback.presentation_id.should == @presentation.id
!!         answers = PresentationFeedbackAnswer.where("created_at >= ?", start_date)
!!         answers.length.should == 4
   
!!         answers.each do |a|
!!           a.feedback.should == new_feedback
           end
         end
       end
   
     end
   
     context "a valid user can" do
       describe "GET show_feedback" do
         it 'unless they are not authorized' do
           @current_user = FactoryGirl.create(:student_sam)
           login(@current_user)
   
           @presentation = FactoryGirl.create(:presentation)
   
           get :show_feedback, :id => @presentation.id
           response.should redirect_to(root_path)
         end
   
         it 'and have a variable with the feedbacks filled in by students' do
           @q1 = FactoryGirl.create(:presentation_feedback_questions, :text => "q1")
           @q2 = FactoryGirl.create(:presentation_feedback_questions, :text => "q2")
           @q3 = FactoryGirl.create(:presentation_feedback_questions, :text => "q3")
           @q4 = FactoryGirl.create(:presentation_feedback_questions, :text => "q4")
   
           @student_sam = FactoryGirl.create(:student_sam)
           login(@student_sam)
           @presentation = FactoryGirl.create(:presentation, :user_id => @student_sam.id)
           feedback = {
             "presentation_id" => @presentation.id
           }
           evaluation = {
             @q1.id => {"rating" => 1, "comment" => "comment 1"},
             @q2.id => {"rating" => 2, "comment" => "comment 2"},
             @q3.id => {"rating" => 3, "comment" => "comment 3"},
             @q4.id => {"rating" => 4, "comment" => "comment 4"}
           }
           post :create_feedback, {:feedback => feedback, :evaluation => evaluation, :id => @presentation.id }
           feedback = assigns :feedback
   
   
           get :show_feedback, :id => @presentation.id
           feedbacks = assigns :feedbacks
   
           questions = assigns :questions
           questions.should == [@q1, @q2, @q3, @q4]
   
!!         student_feedbacks = assigns :student_feedbacks
!!         faculty_feedbacks = assigns :faculty_feedbacks
   
!!         student_feedbacks.first.answers[0].rating.should == evaluation[@q1.id]["rating"]
!!         student_feedbacks.first.answers[1].rating.should == evaluation[@q2.id]["rating"]
!!         student_feedbacks.first.answers[2].rating.should == evaluation[@q3.id]["rating"]
!!         student_feedbacks.first.answers[3].rating.should == evaluation[@q4.id]["rating"]
   
         end
   
         it 'and have a variable with the feedbacks filled in by faculty' do
           @q1 = FactoryGirl.create(:presentation_feedback_questions, :text => "q1")
           @q2 = FactoryGirl.create(:presentation_feedback_questions, :text => "q2")
           @q3 = FactoryGirl.create(:presentation_feedback_questions, :text => "q3")
           @q4 = FactoryGirl.create(:presentation_feedback_questions, :text => "q4")
   
           @student_sam = FactoryGirl.create(:student_sam)
           login(@student_sam)
           @presentation = FactoryGirl.create(:presentation, :user_id => @student_sam.id)
           @faculty_frank = FactoryGirl.create(:faculty_frank)
           login(@faculty_frank)
           feedback = {
             "presentation_id" => @presentation.id
           }
           evaluation = {
             @q1.id => {"rating" => 1, "comment" => "comment 1"},
             @q2.id => {"rating" => 2, "comment" => "comment 2"},
             @q3.id => {"rating" => 3, "comment" => "comment 3"},
             @q4.id => {"rating" => 4, "comment" => "comment 4"}
           }
           post :create_feedback, {:feedback => feedback, :evaluation => evaluation, :id => @presentation.id }
           feedback_from_method = assigns :feedback
   
           presentation = assigns :presentation
           presentation.id.should == @presentation.id
   
!!         feedback_from_method.answers[0].rating.should == 1
!!         presentation.feedbacks.empty?.should_not be_true
!!         presentation.feedback_email_sent.should be_true
   
   
!!         get :show_feedback, :id => @presentation.id
!!         feedbacks = assigns :feedbacks
   
!!         questions = assigns :questions
!!         questions.should == [@q1, @q2, @q3, @q4]
   
!!         student_feedbacks = assigns :student_feedbacks
!!         faculty_feedbacks = assigns :faculty_feedbacks
   
!!         faculty_feedbacks.first.answers[0].rating.should == evaluation[@q1.id]["rating"]
!!         faculty_feedbacks.first.answers[1].rating.should == evaluation[@q2.id]["rating"]
!!         faculty_feedbacks.first.answers[2].rating.should == evaluation[@q3.id]["rating"]
!!         faculty_feedbacks.first.answers[3].rating.should == evaluation[@q4.id]["rating"]
   
         end
   
       describe "GET their own presentations" do
         it 'should return a list of presentations that belong to the current_user' do
           @current_user = FactoryGirl.create(:student_sam)
           login(@current_user)
           @presentation = FactoryGirl.create(:presentation, :team_id => nil, :user_id => @current_user.id)
           get :my_presentations, :id => @current_user.twiki_name
           presentations = assigns :presentations
   
           # presentations.id.should == @presentation.id
           presentations.length.should == 1
         end
       end
   
       end
     end
   
     context "Faculty can" do
       before do
         @faculty_frank = FactoryGirl.create(:faculty_frank)
         @course = mock_model(Course, :faculty => [@faculty_frank], :course_id => 42)
         @presentation = stub_model(Presentation, :course_id => @course.id)
         Presentation.stub(:find_all_by_course_id).and_return([@presentation, @presentation])
         Course.stub(:find).and_return(@course)
   
         login(FactoryGirl.create(:admin_andy))
       end
   
       describe "GET index_for_course" do
           it 'should be success' do
             get :index_for_course, :course_id => @course.id
             response.should_not be_redirect
           end
   
           it 'assign presentations' do
             get :index_for_course, :course_id => @course.id
             assigns(:presentations).should == [@presentation,@presentation]
           end
       end
   
       describe "get new" do
           it 'should be success' do
             get :new, :course_id => @course.id
             response.should_not be_redirect
           end
        end
   
        describe "post new" do
           it 'should be success' do
           presentation = {
             :name => "test_pre",
             :team_id => 1,
             :presentation_date =>"2011-11-21 05:00:00",
             :task_number => 1,
             :owner => "jj"
           }
             post :create, {:course_id => @course.id, :presentation => presentation}
   
             Presentation.find_by_name("test_pre").task_number.should == "1"
           end
   
           it 'should not be success' do
           presentation = {
             :name => nil,
             :team_id => 1,
             :presentation_date =>nil,
             :task_number => 1,
             :owner => "jj"
           }
             post :create, {:course_id => @course.id, :presentation => presentation}
   
             Presentation.find_by_name("test_pre").should be_nil
           end
   
           it 'should not be successful because the user is not valid' do
             presentation = {
             :name => "test_pre",
             :team_id => 1,
             :presentation_date =>"2011-11-21 05:00:00",
             :task_number => 1,
             :owner => "jj",
             :user => "Bob George"
           }
             post :create, {:course_id => @course.id, :presentation => presentation}
   
             response.should render_template("new")
   
           end
   
           it 'should be successful because the user is valid' do
             presentation = {
             :name => "test_pre",
             :team_id => 1,
             :presentation_date =>"2011-11-21 05:00:00",
             :task_number => 1,
             :owner => "jj",
             :user => "Faculty Frank"
           }
             post :create, {:course_id => @course.id, :presentation => presentation}
   
             Presentation.find_by_name("test_pre").task_number.should == "1"
   
           end
   
        end
   
   
     end
   
   
     context "Student Can NOT" do
        before do
          login(FactoryGirl.create(:student_sally))
   
         @faculty_frank = FactoryGirl.create(:faculty_frank)
         @course = mock_model(Course, :faculty => [@faculty_frank], :course_id => 42)
         @presentation = stub_model(Presentation, :course_id => @course.id)
         Course.stub(:find).and_return(@course)
        end
   
        describe "GET index_for_course" do
          it "should be success" do
            get :index_for_course, :course_id => @course.id
            response.should redirect_to(root_path)
          end
        end
   
        describe "get new" do
           it 'should not be success' do
             get :new, :course_id => @course.id
            response.should redirect_to(root_path)
           end
        end
   
     end
   end

================================================================================
 ./spec/controllers/sponsored_project_allocations_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe SponsoredProjectAllocationsController do
   
     let(:allocation) { FactoryGirl.create(:sponsored_project_allocation) }
   
     context "as admin do" do
   
       before do
         @admin_andy = FactoryGirl.create(:admin_andy)
         login(@admin_andy)
       end
   
       describe 'GET index' do
   
         it 'assigns @allocations' do
           get :index
           assigns(:allocations).should_not be_nil
         end
       end
   
       describe 'GET new' do
   
         it 'assigns @allocation' do
           get :new
           assigns(:allocation).should_not be_nil
         end
   
         it 'assigns @projects' do
           get :new
           assigns(:projects).should_not be_nil
         end
   
         it 'assigns @users' do
           get :new
           assigns(:users).should_not be_nil
         end
   
       end
   
       describe "GET edit" do
         before(:each) do
           get :edit, :id => allocation.to_param
         end
   
         it 'assigns @allocation' do
           assigns(:allocation).should == allocation
         end
   
         it 'assigns @projects' do
           assigns(:projects).should_not be_nil
         end
   
         it 'assigns @people' do
           assigns(:users).should_not be_nil
         end
       end
   
       describe 'POST create' do
   
         describe "with valid params" do
           before(:each) do
             @allocation = FactoryGirl.build(:sponsored_project_allocation)
           end
   
           it "saves a newly created allocation" do
             lambda {
               post :create, :sponsored_project_allocation => @allocation.attributes
             }.should change(SponsoredProjectAllocation,:count).by(1)
           end
   
           it "redirects to the index of allocations" do
             post :create, :sponsored_project_allocation => @allocation.attributes
             response.should redirect_to(sponsored_project_allocations_path)
           end
         end
   
         describe "with invalid params" do
           it "assigns a newly created but unsaved allocation as @allocation" do
             lambda {
               post :create, :sponsored_project_allocation => {}
             }.should_not change(SponsoredProjectAllocation,:count)
             assigns(:allocation).should_not be_nil
!!           assigns(:allocation).should be_kind_of(SponsoredProjectAllocation)
           end
   
           it "re-renders the 'new' template" do
             post :create, :sponsored_project_allocation => {}
             response.should render_template("new")
           end
         end
       end
   
       describe "PUT update" do
   
         describe "with valid params" do
   
           before do
             put :update, :id => allocation.to_param, :sponsored_project_allocation => {:current_allocation => 50}
           end
   
           it "updates the requested allocation" do
             allocation.reload.current_allocation.should == 50
           end
   
           it "should assign @allocation" do
             assigns(:allocation).should_not be_nil
           end
   
           it "redirects to allocations" do
             response.should redirect_to(sponsored_project_allocations_path)
           end
         end
   
         describe "with invalid params" do
           before do
             put :update, :id => allocation.to_param, :sponsored_project_allocation => {:current_allocation => ''}
           end
   
           it "should assign @allocation" do
             assigns(:allocation).should_not be_nil
           end
   
           it "re-renders the 'edit' template" do
             response.should render_template("edit")
           end
         end
       end
   
        describe "GET archive" do
         it "archives the allocation" do
           get :archive, :id => allocation.to_param
           flash[:notice].should == "Allocation was successfully archived."
         end
       end
     end
   
     context "as faculty do " do
   
       before do
         @faculty_frank = allocation.user
         @faculty_frank.is_admin = false
         login(@faculty_frank)
       end
   
       [:index, :new, :edit, :archive].each do |http_verb|
         describe "GET #{http_verb}" do
           it "can't access page" do
             get http_verb, :id => allocation.to_param
             response.should redirect_to(root_path)
           end
         end
       end
   
       describe "POST create" do
         it "can't access page" do
           post :create, :sponsored_project_allocation => allocation.attributes
           response.should redirect_to(root_path)
         end
       end
   
       describe "PUT update" do
         it "can't access page" do
           put :update, :id => allocation.to_param, :sponsored_project_allocation => {:current_allocation => 50}
           response.should redirect_to(root_path)
         end
       end
     end
   end

================================================================================
 ./spec/controllers/sponsored_project_efforts_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe SponsoredProjectEffortsController do
   
   
     context "as admin do" do
       before do
         @admin_andy= FactoryGirl.create(:admin_andy)
         login(@admin_andy)
       end
   
       describe "GET index" do
         before(:each) do
           @effort_mock = mock_model(SponsoredProjectEffort)
           SponsoredProjectEffort.stub(:for_all_users_for_a_given_month).and_return([@effort_mock, @effort_mock])
           get :index
         end
   
         it 'assigns @efforts' do
           assigns(:efforts).should == [@effort_mock, @effort_mock]
         end
       end
     end
   
     context "as faculty do" do
   
       before do
         @faculty_frank = FactoryGirl.create(:faculty_frank)
         login(@faculty_frank)
       end
   
       describe "GET index" do
         it "can't access page" do
           get :index
           response.should redirect_to(root_path)
         end
   
       end
   
       describe "GET edit" do
   
         it 'assigns @efforts' do
           efforts = [stub_model(SponsoredProjectEffort)]
           SponsoredProjectEffort.should_receive(:month_under_inspection_for_a_given_user).with(@faculty_frank.id).and_return(efforts)
           get :edit, :id => @faculty_frank.twiki_name
           assigns(:efforts).should == efforts
!!         assigns(:month).should == efforts[0].month
!!         assigns(:year).should == efforts[0].year
         end
   
         it "can't access page for a different user" do
           @faculty_fagan = FactoryGirl.create(:faculty_fagan)
           get :edit, :id => @faculty_fagan.twiki_name
           response.should redirect_to(root_path)
         end
       end
   
       describe "PUT update" do
   
         before(:each) do
           @effort_1 = stub_model(SponsoredProjectEffort)
           @effort_2 = stub_model(SponsoredProjectEffort)
   
           @effort_1.stub(:valid).and_return(true)
           @effort_2.stub(:valid).and_return(true)
   
           @effort_1.stub(:unique_month_year_allocation_id?).and_return(true)
           @effort_2.stub(:unique_month_year_allocation_id?).and_return(true)
   
           SponsoredProjectEffort.should_receive(:find).with("0").and_return(@effort_1)
           SponsoredProjectEffort.should_receive(:find).with("1").and_return(@effort_2)
   
           subject.should_receive(:setup_edit).and_return(true)
   
           SponsoredProjectEffort.stub(:emails_business_manager)
         end
   
   
         describe "with valid params" do
   
           it "updates the actual allocations" do
             @effort_1.should_receive(:actual_allocation=).with("25")
             @effort_2.should_receive(:actual_allocation=).with("75")
             put :update, :id => "FacultyFrank", :effort_id_values => {"0" => "25", "1" => "75"}
           end
     
           it 'updates the confirmed value' do
             @effort_1.should_receive(:confirmed=).with(true)
             @effort_2.should_receive(:confirmed=).with(true)
             put :update, :id => "FacultyFrank", :effort_id_values => {"0" => "25", "1" => "75"}
           end
   
   #        it 'sets the flash' do
   #          put :update, :id => "AndrewCarnegie", :effort_id_values => {"0" => "25", "1" => "75"}
   #          flash.now[:notice].should_not be_nil
   #        end
   
           it "re-renders the 'edit' template" do
             put :update, :id => "FacultyFrank", :effort_id_values => {"0" => "25", "1" => "75"}
             response.should render_template("edit")
           end
   
           it "emails the business manager when actual != confirmed" do
             SponsoredProjectEffort.should_receive(:emails_business_manager)
             put :update, :id => "FacultyFrank", :effort_id_values => {"0" => "25", "1" => "75"}
           end
         end
   
         describe "with invalid params" do
   
           it 'sets the flash to error' do
             @effort_2.should_receive(:save).and_return(false)
             put :update, :id => "FacultyFrank", :effort_id_values => {"0" => "25", "1" => "75"}
             assigns(:failed).should == true
             #flash.now[:error].should == "Your allocations did not save."
           end
   
           it "re-renders the 'edit' template" do
             @effort_2.should_receive(:save).and_return(false)
             put :update, :id => "FacultyFrank", :effort_id_values => {"0" => "25", "1" => "75"}
             response.should render_template("edit")
           end
         end
       end
   
   
       describe "PUT update (unauthorized)" do
         it "can't access page for a different user" do
           @faculty_fagan = FactoryGirl.create(:faculty_fagan)
           put :update, :id => @faculty_fagan.twiki_name, :effort_id_values => {"0" => "25", "1" => "75"}
           response.should redirect_to(root_path)
         end
       end
     end
   
   end

================================================================================
 ./spec/controllers/sponsored_project_sponsors_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe SponsoredProjectSponsorsController do
   
   
     let(:sponsor) { FactoryGirl.create(:sponsored_project_sponsor) }
   
     context "as admin do " do
   
       before do
         @admin_andy = FactoryGirl.create(:admin_andy)
         login(@admin_andy)
       end
       
       describe "GET new sponsor" do
         it 'assigns a new sponsor as @sponsor' do
           get :new
           assigns(:sponsor).should_not be_nil
         end
       end
   
       describe "GET edit sponsor" do
         before do
           get :edit, :id => sponsor.to_param
         end
   
         it "assigns sponsor" do
           assigns(:sponsor).should == sponsor
         end
       end
   
       describe "POST create" do
   
         describe "with valid params" do
           before(:each) do
             @sponsor = FactoryGirl.build(:sponsored_project_sponsor)
           end
   
           it "saves a newly created sponsor" do
             lambda {
               post :create, :sponsored_project_sponsor => @sponsor.attributes
             }.should change(SponsoredProjectSponsor, :count).by(1)
           end
   
           it "redirects to the index of projects" do
             post :create, :sponsored_project_sponsor => @sponsor.attributes
             response.should redirect_to(sponsored_projects_path)
           end
         end
   
         describe "with invalid params" do
           it "assigns a newly created but unsaved sponsor as sponsor" do
             lambda {
               post :create, :sponsored_project_sponsor => {}
             }.should_not change(SponsoredProjectSponsor, :count)
             assigns(:sponsor).should_not be_nil
!!           assigns(:sponsor).should be_kind_of(SponsoredProjectSponsor)
           end
   
           it "re-renders the 'new' template" do
             post :create, :sponsored_project_sponsor => {}
             response.should render_template("new")
           end
         end
       end
   
       describe "PUT update" do
   
         describe "with valid params" do
   
           before do
             put :update, :id => sponsor.to_param, :sponsored_project_sponsor => {:name => 'NNNNN'}
           end
   
           it "updates the requested sponsor name" do
             sponsor.reload.name.should == "NNNNN"
           end
   
           it "should assign @sponsor" do
             assigns(:sponsor).should_not be_nil
           end
   
           it "redirects to projects" do
             response.should redirect_to(sponsored_projects_path)
           end
         end
   
         describe "with invalid params" do
           before do
             put :update, :id => sponsor.to_param, :sponsored_project_sponsor => {:name => ''}
           end
   
           it "should assign @sponsor" do
             assigns(:sponsor).should_not be_nil
           end
   
           it "re-renders the 'edit' template" do
             response.should render_template("edit")
           end
         end
   
       end
   
       describe "GET archive" do
         it "archives the sponsor" do
           get :archive, :id => sponsor.to_param
           flash[:notice].should == "Sponsor was successfully archived."
         end
       end
     end
   
     context "as faculty do " do
   
       before do
         @faculty_frank = FactoryGirl.create(:faculty_frank)
         login(@faculty_frank)
       end
   
       [:new, :edit, :archive].each do |http_verb|
         describe "GET #{http_verb}" do
           it "can't access page" do
             get http_verb, :id => sponsor.to_param
             response.should redirect_to(root_path)
           end
         end
       end
   
       describe "POST create" do
         it "can't access page" do
           post :create, :sponsored_project_sponsor => sponsor.attributes
           response.should redirect_to(root_path)
         end
       end
   
       describe "PUT update" do
         it "can't access page" do
           put :update, :id => sponsor.to_param, :sponsored_project_sponsor => {:name => 'NNNNN'}
           response.should redirect_to(root_path)
         end
       end
   
   
     end
   
   end

================================================================================
 ./spec/controllers/sponsored_projects_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe SponsoredProjectsController do
   
     let(:project) { FactoryGirl.create(:sponsored_project) }  # This is similar to setting an @project in a before block
                                                    # let(:project) makes a user method available
   
     context "as admin do " do
   
       before do
         @admin_andy = FactoryGirl.create(:admin_andy)
         login(@admin_andy)
       end
   
       describe "GET index" do
         it "assigns all projects as @projects" do
           get :index
           assigns(:projects).should_not be_nil
         end
   
         it "assigns all sponsors as @sponsors" do
           get :index
           assigns(:sponsors).should_not be_nil
         end
       end
   
       describe "GET new" do
         it "assigns a new sponsored project as project" do
           get :new
           assigns(:project).should_not be_nil
         end
       end
   
      describe "GET edit" do
         before do
           get :edit, :id => project.to_param
         end
   
         it "assigns project" do
           assigns(:project).should == project
         end
   
       end
   
       describe "POST create" do
   
         describe "with valid params" do
           before(:each) do
             @project = FactoryGirl.build(:sponsored_project)
           end
   
           it "saves a newly created project" do
             lambda {
               post :create, :sponsored_project => @project.attributes
             }.should change(SponsoredProject,:count).by(1)
           end
   
           it "redirects to the index of projects" do
             post :create, :sponsored_project => @project.attributes
             response.should redirect_to(sponsored_projects_path)
           end
   
           it "assigns all sponsors as @sponsors" do
             post :create, :sponsored_project => @project.attributes
             assigns(:sponsors).should_not be_nil
           end
         end
   
         describe "with invalid params" do
           it "assigns a newly created but unsaved project as project" do
             lambda {
               post :create, :sponsored_project => {}
             }.should_not change(SponsoredProject,:count)
             assigns(:project).should_not be_nil
!!           assigns(:project).should be_kind_of(SponsoredProject)
           end
   
           it "re-renders the 'new' template" do
             post :create, :sponsored_project => {}
             response.should render_template("new")
           end
   
           it "assigns all sponsors as @sponsors" do
             post :create, :sponsored_project => {}
             assigns(:sponsors).should_not be_nil
           end
         end
       end
   
   
       describe "PUT update" do
   
         describe "with valid params" do
   
           before do
             put :update, :id => project.to_param, :sponsored_project => {:name => 'NNNNN'}
           end
   
           it "updates the requested project name" do
             project.reload.name.should == "NNNNN"
           end
   
           it "should assign @project" do
             assigns(:project).should_not be_nil
           end
   
           it "redirects to projects" do
             response.should redirect_to(sponsored_projects_path)
           end
         end
   
         describe "with invalid params" do
           before do
             put :update, :id => project.to_param, :sponsored_project => {:name => ''}
           end
   
           it "should assign @project" do
             assigns(:project).should_not be_nil
           end
   
           it "assigns all sponsors as @sponsors" do
             assigns(:sponsors).should_not be_nil
           end
   
           it "re-renders the 'edit' template" do
             response.should render_template("edit")
           end
         end
   
       end
   
       describe "GET archive" do
         it "archives the project" do
           get :archive, :id => project.to_param
           flash[:notice].should == "Project was successfully archived."
         end
       end
     end
   
     context "as faculty do " do
   
       before do
         @faculty_frank = FactoryGirl.create(:faculty_frank)
         login(@faculty_frank)
       end
   
       [:index, :new, :edit, :archive].each do |http_verb|
         describe "GET #{http_verb}" do
           it "can't access page" do
             get http_verb, :id => project.to_param
             response.should redirect_to(root_path)
           end
         end
       end
   
       describe "POST create" do
         it "can't access page" do
           post :create, :sponsored_project => project.attributes
           response.should redirect_to(root_path)
         end
       end
   
       describe "PUT update" do
         it "can't access page" do
           put :update, :id => project.to_param, :sponsored_project => {:name => 'NNNNN'}
           response.should redirect_to(root_path)
         end
       end
   
   
     end
   
   end

================================================================================
 ./spec/controllers/suggestion_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe SuggestionsController do
     render_views
   
     describe "NEW suggestion" do
       it "remembers the HTTP referer" do
          get :new
          
          response.should be_success
       end
       
       it "prompts for an email address if the user is not logged in" do
         pending "Test disabled: this is more like a view test. Not sure it belongs here + it started failing on rails3" do
           get :new
           response.should have_selector("input", :id => "suggestion_email")
         end
       end
   
     end
   
     describe "POST suggestion" do
   
       describe "success" do
   
   # Michael Hartl's way
   #      before(:each) do
   #        @attr = { :comment => "This is a suggestion", :page => "http://whiteboard.sv.cmu.edu",
   #        :email => "" }
   #        @suggestion = FactoryGirl.create(:suggestion, @attr)
   #        Suggestion.stub!(:new).and_return(@suggestion)
   #        @suggestion.should_receive(:save).and_return(true)
   #      end
   
   
   #Rspec books way
   # Repsec start
         let (:suggestion) { mock_model(Suggestion).as_null_object }
   
         before do
           @attr = { :comment => "This is a suggestion", :page => "http://whiteboard.sv.cmu.edu",
                     :email => "" }        
           Suggestion.stub(:new).and_return(suggestion)
           Suggestion.stub(:save).and_return(suggestion)
         end
         
   
         it "creates a new suggestion" do
   #        Suggestion.should_receive(:new).with_options("page" => @attr[:page]).and_return(suggestion)
           post :create, :suggestion => @attr 
         end
   #rspec book end
   
         it "remembers the user id if the user is logged in"
   
         it "emails Todd that a suggestion has been created"
   
         it "sets a flash[:notice] message" do
           post :create
           flash[:notice].should == "Thank you for your suggestion"
         end
   
         it "redirects the user back to the page they came from"
   #      do
   #        post :create, @attr
   #        response.should redirect_to(@attr[:page])
   #      end
   #
       end
   
     end
   
   
   #  describe "Create a suggestion" do
   #    it "should work when the user is not logged in" do
   #      get 'new'
   #      response.should be_success
   #
   #    end
   #
   #    it "should work when the user is logged in "
   #
   #    it "should remember the url of the page the suggestion was made on"
   #
   #    it "should email Todd that a suggestion was created"
   #  end
   #
   #  describe "GET 'index'" do
   #    it "should be successful" do
   #      get 'index'
   #      response.should be_success
   #    end
   #  end
   
   end
   

================================================================================
 ./spec/controllers/system_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe SystemController do
   
   
     context "any user" do
       before do
         login(FactoryGirl.create(:student_sam))
       end
   
       describe "GET index" do
         before do
           get :index
         end
   
         it "should only setup normal rails information" do
   #        response.status.should be(200)
         end
   
       end
   
     end
   end

================================================================================
 ./spec/controllers/teams_controller_spec.rb
================================================================================
   require 'spec_helper'
   require 'controllers/permission_behavior'
   
   describe TeamsController do
   
     let(:course) { FactoryGirl.create(:course) }
     let(:team) { FactoryGirl.create(:team) }
   
     context "any user can" do
       before do
         login(FactoryGirl.create(:student_sam))
       end
   
       describe "GET show" do
         before do
           get :show, :id => team.to_param, :course_id => team.course.to_param
         end
   
         specify { assigns(:course).should == team.course }
         specify { assigns(:team).should == team }
       end
   
   
       describe "GET index of teams" do
         before do
           get :index_all
         end
   
         specify { assigns(:teams).should_not be_nil }
       end
   
       describe "GET index of teams for a particular course" do
         before do
           get :index, :course_id => course.to_param
         end
   
         specify { assigns(:teams).should_not be_nil }
         specify { assigns(:course).should == course }
       end
   
       describe "not GET new" do
         before do
           get :new, :course_id => course.to_param
         end
   
         it_should_behave_like "permission denied"
       end
   
       describe "not GET twiki_new" do
         before do
           post :twiki_new
         end
   
         it_should_behave_like "permission denied"
       end
   
       describe "not POST create" do
         before do
           @team = FactoryGirl.build(:team)
           post :create, :team => @team.attributes
         end
   
         it_should_behave_like "permission denied"
       end
   
       describe "not PUT update" do
         before do
           put :update, :id => team.to_param, :course_id => team.course.to_param, :team => {:name => 'NNNNN'}
           @redirect_url = course_team_path(team.course, team)
         end
   
         it_should_behave_like "permission denied"
       end
   
       describe "not DELETE destroy" do
         before do
           delete :destroy, :id => team.to_param
           @redirect_url = teams_path
         end
   
         it_should_behave_like "permission denied"
       end
   
     end
   
     context "any staff can" do
       before do
         login(FactoryGirl.create(:faculty_frank))
       end
   
       describe "GET new" do
         before do
           get :new, :course_id => team.course.to_param
         end
   
         specify { assigns(:course).should_not be_nil }
         specify { assigns(:team).should_not be_nil }
       end
   
       describe "GET edit" do
         before do
           get :edit, :id => team.to_param, :course_id => team.course.to_param
         end
   
         specify { assigns(:course).should == team.course }
         specify { assigns(:team).should == team }
       end
   
       describe "POST create" do
   
         describe "with valid params" do
           before(:each) do
             @team = FactoryGirl.build(:team)
           end
   
           it "saves a newly created project" do
             lambda {
               post :create, :team => @team.attributes, :course_id => @team.course.to_param
             }.should change(Team, :count).by(1)
           end
   
           it "redirects to the index of teams" do
             post :create, :team => @team.attributes, :course_id => @team.course.to_param
             response.should redirect_to(course_teams_path(@team.course))
           end
         end
   
         #Re-evaluate this when team CAN have an invalid parameter
         #describe "with invalid params" do
         #  it "assigns a newly created but unsaved item as item" do
         #    lambda {
         #      post :create, :team => {:name => nil, :email => "nothing"}, :course_id => team.course.to_param
         #    }.should_not change(Team, :count)
         #    assigns(:team).should_not be_nil
         #    assigns(:team).should be_kind_of(Team)
         #  end
         #
         #  it "re-renders the 'new' template" do
         #    post :create, :team => {:name => nil, :email =>"nothing"}, :course_id => team.course.to_param
         #    response.should render_template("new")
         #  end
         #end
       end
   
       describe "PUT update" do
   
         describe "with valid params" do
   
           before do
             put :update, :id => team.to_param, :team => {:name => 'NNNNN'}, :course_id => team.course.to_param
           end
   
           it "updates the requested team name" do
             team.reload.name.should == "NNNNN"
           end
   
           it "should assign @team" do
             assigns(:team).should_not be_nil
           end
   
           it "should assign @course" do
             assigns(:course).should_not be_nil
           end
   
           it "redirects to the course's' teams" do
             response.should redirect_to(course_teams_path(team.course))
           end
         end
   
         describe "with invalid params" do
           before do
             put :update, :id => team.to_param, :team => {:name => ''}, :course_id => team.course.to_param
           end
   
           it "should assign @team" do
             assigns(:team).should_not be_nil
           end
   
           it "should assign @course" do
             assigns(:course).should_not be_nil
           end
   
           it "re-renders the 'edit' template" do
             response.should render_template("edit")
           end
         end
   
       end
   
       describe "not DELETE destroy" do
         before do
           delete :destroy, :id => team.to_param
           @redirect_url = teams_path
         end
   
         it_should_behave_like "permission denied"
       end
     end
   
   
     context "any admin can" do
       before do
!!       login(FactoryGirl.create(:admin_andy))
       end
   
       describe "DELETE destroy" do
   
         it "destroys the course"
   #       course.should_receive(:destroy)
   
   #        lambda {
   #          a = Course.count
   #          c = course
   #          delete :destroy, :id => course.to_param
   #          b = Course.count
   #          t = 1
   #        }.should change(Course, :count).by(1)
   
   
       end
   
     end
   end

================================================================================
 ./spec/controllers/welcome_controller_spec.rb
================================================================================
   require 'spec_helper'
   
   describe WelcomeController do
   
     describe "GET 'index'" do
       it "should be successful" do
         get 'index'
         response.should be_success
       end
     end
   
     describe "GET 'new_features'" do
       it "should be successful" do
         get 'new_features'
         response.should be_success
       end
     end
   
     describe "GET 'configuration'" do
       it "should be successful" do
         get 'configuration'
         response.should be_success
       end
     end
   
   end
   

================================================================================
 ./spec/factories/assignments.rb
================================================================================
   # Read about factories at https://github.com/thoughtbot/factory_girl
   
   FactoryGirl.define do
   
     factory :assignment_individual, :parent=>:assignment do
       is_team_deliverable false
     end
   
     factory :assignment_team, :parent=>:assignment do
       is_team_deliverable true
     end
   
     factory :assignment_unsubmissible, :parent=>:assignment do
       is_submittable false
       due_date ""
     end
   
     factory :assignment_fse, :parent=>:assignment do
       name "fse assignment 1"
       association :course, :factory => :fse
     end
   
     factory :assignment_seq, :parent=>:assignment  do
       course_id 1
       sequence(:name) {|i| "Assignment #{i}"}
       sequence(:maximum_score) {|i| i*3}
       sequence(:assignment_order) {|i| i}
     end
   
     factory :assignment_1, :parent=>:assignment do
       is_team_deliverable true
       association :course, :factory => :fse
       name "Assignment 1"
       task_number 1
     end
   
     factory :assignment_2, :parent=>:assignment do
       is_team_deliverable true
       association :course, :factory => :fse
       name "Assignment 2"
       task_number 2
     end
   
     factory :assignment_3, :parent=>:assignment do
       is_team_deliverable false
       association :course, :factory => :fse
       name "Assignment 3"
       task_number 3
     end
   end

================================================================================
 ./spec/factories/courses.rb
================================================================================
   FactoryGirl.define do
   
     factory :fse, :parent => :course do
       name 'Foundations of Software Engineering'
       short_name 'FSE'
     end
   
     factory :ise, :parent => :course do
       name 'Introduction to Software Engineering'
       short_name 'ISE'
     end
   
     factory :course_fse_with_students, :parent => :fse do  |c|
       registered_students { |registered_students| [registered_students.association(:team_member)] }
       c.after(:build) {|c| c.registered_students.each  { |s|  FactoryGirl.build(:registration, :course_id=>c.id, :user_id => s.id) } }
     end
   
     factory :course_ise_with_students, :parent => :ise do  |c|
       registered_students { |registered_students| [registered_students.association(:team_member)] }
       c.after(:build) {|c| c.registered_students.each  { |s|  FactoryGirl.build(:registration, :course_id=>c.id, :user_id => s.id) } }
     end
   
     factory :mfse, :parent => :course do
       name 'Metrics for Software Engineers'
       short_name 'MfSE'
       semester AcademicCalendar.next_semester
       year AcademicCalendar.next_semester_year
       number '96-700'
     end
   
     factory :mfse_fall_2011, :parent => :course do
       name 'Metrics for Software Engineers'
       short_name 'MfSE'
       semester "Fall"
       year 2011
       number '96-703'
     end
   
     factory :fse_fall_2011, :parent => :course do
       name 'Foundations of Software Engineering'
       short_name 'FSE'
       semester "Fall"
       year 2011
       number '96-700'
     end
   
   
     factory :mfse_current_semester, :parent => :mfse do
       semester AcademicCalendar.current_semester
       year Date.today.cwyear
     end
   
     factory :fse_current_semester, :parent => :fse do
       semester AcademicCalendar.current_semester
       year Date.today.cwyear
     end
   
   end

================================================================================
 ./spec/factories/deliverable_attachments.rb
================================================================================
   FactoryGirl.define do
   
     factory :attachment_1, :parent => :deliverable_attachment do
       submitter_id 1
       deliverable_id 1
       submission_date DateTime.now
       association :deliverable, :factory => :team_deliverable
       association :submitter, :factory => :student_john_user
     end
   
   end

================================================================================
 ./spec/factories/deliverables.rb
================================================================================
   FactoryGirl.define do
   
     factory :team_deliverable, :parent => :deliverable do
       association :assignment, :factory => :assignment_team
       association :team, :factory => :team_triumphant
       private_note "My private notes"
     end
   
     factory :individual_deliverable, :parent => :deliverable do
       team_id nil
     end
   
     factory :turing_individual_deliverable, :parent => :deliverable do
       team_id nil
       association :creator, :factory => :student_john_user
       association :course, :factory => :fse
     end
   
     factory :team_deliverable_simple, :class => Deliverable do
       private_note "My private notes"
     end
   
     factory :team_turing_deliverable_1, :parent => :deliverable do
       association :assignment, :factory => :assignment
       association :team, :factory => :team_turing
       association :course, :factory => :fse
       private_note "My first deliverable"
     end
   
     factory :team_turing_deliverable_2, :parent => :deliverable do
       association :assignment, :factory => :assignment
       association :team, :factory => :team_turing
       association :course, :factory => :fse
       private_note "My second deliverable"
     end
   
     factory :team_test_deliverable_1, :parent => :deliverable do
       association :assignment, :factory => :assignment
       association :team, :factory => :team_test
       association :course, :factory => :fse
       association :creator, :factory => :student_Test_user
       private_note "Test team  first deliverable"
     end
   
     factory :test_individual_deliverable, :parent => :deliverable do
       team_id nil
       association :creator, :factory => :student_sally_user
       association :course, :factory => :fse
     end
   
     factory :team_ruby_racer_deliverable_1, :parent => :deliverable do
       association :assignment, :factory => :assignment
       association :team, :factory => :team_ruby_racer
       association :course, :factory => :fse
       private_note "Ruby Racer's first deliverable"
     end
   
   
   end

================================================================================
 ./spec/factories/effort_log_line_items.rb
================================================================================
   FactoryGirl.define do
   
     factory :elli_line1, :parent => :effort_log_line_item do
       day1 0
       day2 20
       day3 2
       day4 2
       day5 0
       day6 0
       day7 0
       sum 24
     end
   
   
     factory :elli_line2, :parent => :effort_log_line_item do
       day1 1
       day2 1
       day3 1
       day4 1
       day5 1
       day6 1
       day7 0
       sum 6
     end
   
     factory :elli_line3, :parent => :effort_log_line_item do
       day1 2
       day2 2
       day3 2
       day4 2
       day5 2
       day6 1
       day7 1
       sum 12
     end
   
   end

================================================================================
 ./spec/factories/effort_logs.rb
================================================================================
   FactoryGirl.define do
     factory :effort1, :parent => :effort_log do
       week_number { (Date.today-7).cweek }
       year { (Date.today-7).cwyear }
       sum 24
     end
   
     factory :effort2, :parent => :effort_log do
       week_number { (Date.today-7).cweek }
       year { (Date.today-7).cwyear }
       sum 6
     end
   
     factory :effort3, :parent => :effort_log do
       week_number { (Date.today-7).cweek }
       year { (Date.today-7).cwyear }
       sum 12
     end
   
   end

================================================================================
 ./spec/factories/factories.rb
================================================================================
   # For each model in the system, include one factory that creates the bare minimum necessary to save the object.
   # In other words, it should pass all validations, but have nothing extra
   FactoryGirl.define do
   
     factory :assignment do
       association :course, :factory => :fse
       maximum_score 20.0
       name "MyString"
       is_team_deliverable false
       due_date "2012-10-03 12:48:24"
       task_number 1
       is_submittable true
     end
   
     factory :course, class: Course do
       name 'Course'
       semester AcademicCalendar.current_semester
       year Date.today.year
       mini 'Both'
       number '96-700'
       updated_by_user_id 10
       association :grading_rule, :factory => :grading_rule_points
     end
   
     factory :delayed_system_job do
     end
   
     factory :deliverable do
       association :assignment, :factory => :assignment
       association :course, :factory => :course
       association :creator, :factory => :student_sally
     end
   
     factory :deliverable_attachment do
       association :deliverable, :factory => :deliverable
     end
   
     factory :effort_log_line_item, class: EffortLogLineItem do
       association :course, :factory => :fse
       task_type_id 1
       effort_log_id 60
     end
   
     today = Date.today
     monday_of_this_week = Date.commercial(today.year, today.cweek, 1)
     factory :effort_log, class: EffortLog do
       year monday_of_this_week.cwyear
       week_number monday_of_this_week.cweek
       association :user, :factory => :student_sam_user
     end
   
     factory :faculty_assignment, class: FacultyAssignment do
       course_id 1
       user_id 999
     end
   
     factory :feedback_from_sam, class: PresentationFeedback do
       association :evaluator, :factory => :student_sam
       association :presentation, :factory => :presentation
     end
   
     factory :page, class: Page do
       title "My page "
       url "my_page"
       updated_by_user_id 10
       tab_one_contents "Lorem Ipsum"
     end
   
     factory :page_comment do
       association :page, :factory => :page
   #  association :person, :factory => :student_sam
       comment 'This page has a broken link'
     end
   
     factory :page_comment_type do
       name 'Comment'
       background_color "#FFF499"
     end
   
     factory :peer_evaluation_learning_objective, class: PeerEvaluationLearningObjective do
       learning_objective "this is my learning objective"
     end
   
     factory :peer_evaluation_review, class: PeerEvaluationReview do
       association :team, :factory => :team_triumphant
       association :author, :factory => :student_sam, :email => "student.sam2@sv.cmu.edu", :webiso_account => "ss2@andrew.cmu.edu"
       association :recipient, :factory => :student_sally
       question "What was this team member's most significant positive contribution to the team?"
       answer "Sally was always on time in meetings."
       sequence_number 0
     end
   
     factory :person, class: Person do
       is_staff 0
       is_student 0
       is_admin 0
       is_active 1
       image_uri "/images/mascot.jpg"
       email Time.now.to_f.to_s + "@andrew.cmu.edu"
   #  remember_created_at Time.now.to_f.to_s
     end
   
     factory :people_search_default, class: PeopleSearchDefault do
     end
   
     factory :presentation do
       name "Test Presentation"
       description "Desc"
       task_number "1"
       presentation_date Date.new(2011, 1, 1)
       association :course, :factory => :course
       association :team, :factory => :team
     end
   
     factory :presentation_feedback_questions, class: PresentationQuestion do
       deleted false
     end
   
     factory :presentation_feedback_answer, class: PresentationFeedbackAnswer do
       rating 2
       association :question, :factory => :presentation_feedback_questions
       association :feedback, :factory => :feedback_from_sam
     end
   
     factory :registration do
       course_id 1
       user
     end
   
     factory :scotty_dog_saying, class: ScottyDogSaying do
       association :user, :factory => :student_sam
       saying "Tartan is my favorite color"
     end
   
     factory :sponsored_project_effort, class: SponsoredProjectEffort do
       association :sponsored_project_allocation, :factory => :sponsored_project_allocation
       current_allocation 10
       year { 1.month.ago.year }
       month { 1.month.ago.month }
       confirmed false
     end
   
     factory :sponsored_project, class: SponsoredProject do
       sequence(:name) { |n| "Project #{n}" }
       association :sponsor, :factory => :sponsored_project_sponsor
     end
   
     factory :sponsored_project_sponsor, class: SponsoredProjectSponsor do
       sequence(:name) { |n| "Sponsor #{n}" }
     end
   
     factory :sponsored_project_allocation, class: SponsoredProjectAllocation do
       current_allocation 10
       association :user, :factory => :faculty_frank_user
       association :sponsored_project, :factory => :sponsored_project
       is_archived false
     end
   
     factory :suggestion do
       page "http://whiteboard.sv.cmu.edu"
       comment "This is the best website ever"
     end
   
     factory :task_type do
       is_staff 0
       name "Task name"
       is_student 1
       description "Task description"
     end
   
     factory :team, class: Team do
       name "Team"
       email "team@sv.cmu.edu"
       tigris_space "http://team.tigris.org/servlets/ProjectDocumentList"
       twiki_space "http://info.sv.cmu.edu/twiki/bin/view/Graffiti/WebHome"
       members { |members| [members.association(:team_member)] }
       association :course, :factory => :course
     end
   
     factory :user, class: User do
       is_staff 0
       is_student 0
       is_admin 0
       is_active 1
       image_uri "/images/mascot.jpg"
       email Time.now.to_f.to_s + "@andrew.cmu.edu"
   #  remember_created_at Time.now.to_f.to_s
     end
   
   end

================================================================================
 ./spec/factories/grades.rb
================================================================================
   # Read about factories at https://github.com/thoughtbot/factory_girl
   
   FactoryGirl.define do
     factory :grade do
       course_id 1
       student_id 1
       assignment_id 1
       score "1.5"
     end
   
     factory :grade_visible, :parent=>:grade do
       is_student_visible true
     end
   
     factory :grade_invisible, :parent=>:grade do
       is_student_visible false
     end
   
     factory :grade_invisible_turing, :parent=>:grade do
       is_student_visible false
       score nil
     end
   
     factory :grade_points, :parent=>:grade do
       course_id 1
       student_id 999
       assignment
       is_student_visible false
     end
   
     factory :grade_letters, :parent=>:grade do
       course_id 1
       score "A"
       student_id 999
       assignment
     end
   
     factory :last_graded_visible, :parent=>:grade do
       course_id 1
       student_id 999
       assignment_id 1
       is_student_visible true
       last_graded_by 46
     end
   end

================================================================================
 ./spec/factories/grading_rules.rb
================================================================================
   # Read about factories at https://github.com/thoughtbot/factory_girl
   
   FactoryGirl.define do
     factory :grading_rule do
       A_grade_min 94
       A_minus_grade_min 90
       B_plus_grade_min  87
       B_grade_min 83
       B_minus_grade_min 80
       C_plus_grade_min 78
       C_grade_min 74
       C_minus_grade_min 70
       course_id 1
       is_nomenclature_deliverable false
     end
   
     factory :grading_rule_points, :parent=>:grading_rule do
       grade_type "points"
     end
   
     factory :grading_rule_weights, :parent=>:grading_rule do
       grade_type "weights"
     end
   end

================================================================================
 ./spec/factories/job_functions.rb
================================================================================
   # Read about factories at https://github.com/thoughtbot/factory_girl
   
   FactoryGirl.define do
     factory :job_function do
       user_id 1
       title "MyString"
       pt_ft_group "MyString"
       student_staff_group "MyString"
       program_group "MyString"
       track_group "MyString"
     end
   end

================================================================================
 ./spec/factories/jobs.rb
================================================================================
   FactoryGirl.define do
     factory :job do |job|
       title       "Project Pandemonium"
     end
   end

================================================================================
 ./spec/factories/page_attachments.rb
================================================================================
   FactoryGirl.define do
   
     factory :page_attachment, :class => PageAttachment do
       page_attachment_file_name 'booo.jpg'
       page_attachment_content_type 'image/jpg'
       page_attachment_file_size 3231
   #  association :user, :factory => :faculty_frank
       readable_name 'Booo'
     end
   
     factory :blank_page_attachment, :class => PageAttachment do
       page_attachment_file_name ''
       page_attachment_content_type ''
       page_attachment_file_size 0
       readable_name ''
     end
   
   end

================================================================================
 ./spec/factories/pages.rb
================================================================================
   FactoryGirl.define do
   
     factory :ppm, :parent => :page do
       title "Syllabus"
       url "ppm"
       updated_by_user_id 10
       tab_one_contents "As a student in this course, you have the opportunity to practice principled software development in the context of an authentic project using an agile method. You track your progress against a plan and manage risks along the way. You prioritize features, do pair programming and follow test-driven development. You measure code coverage and code quality. Through this course, you experience the ins and outs of software engineering."
     end
   
   end

================================================================================
 ./spec/factories/people.rb
================================================================================
   FactoryGirl.define do
   
     factory :admin_andy, :parent => :person do
       email "admin.andy@sv.cmu.edu"
       webiso_account "andy@andrew.cmu.edu"
       is_staff true
       is_admin true
       first_name "Admin"
       last_name "Andy"
       human_name "Admin Andy"
       twiki_name "AdminAndy"
     end
   
     factory :student_sam, :parent => :person do
   #    id 143
       email "student.sam@sv.cmu.edu"
       webiso_account "sam@andrew.cmu.edu"
       is_student true
       is_alumnus false
       first_name "Student"
       last_name "Sam"
       human_name "Student Sam"
       twiki_name "StudentSam"
   #    initialize_with { Person.find_or_initialize_by_id(id)}
     end
   
     factory :student_sally, :parent => :person do
       email "student.sally@sv.cmu.edu"
       webiso_account "sally@andrew.cmu.edu"
       is_student true
       is_alumnus false
       first_name "Student"
       last_name "Sally"
       human_name "Student Sally"
       twiki_name "StudentSally"
     end
   
     factory :faculty_frank, :parent => :person do
       email "faculty.frank@sv.cmu.edu"
       webiso_account "frank@andrew.cmu.edu"
       is_staff true
       first_name "Faculty"
       last_name "Frank"
       human_name "Faculty Frank"
       twiki_name "FacultyFrank"
     end
   
     factory :faculty_fagan, :parent => :person do
       email "faculty.fagan@sv.cmu.edu"
       webiso_account "fagan@andrew.cmu.edu"
       is_staff true
       first_name "Faculty"
       last_name "Fagan"
       human_name "Faculty Fagan"
       twiki_name "FacultyFagan"
     end
   
     factory :team_member, :parent => :person do
       email "team.member@sv.cmu.edu"
       webiso_account "teammember@andrew.cmu.edu"
       is_student true
       is_alumnus false
       first_name "Team"
       last_name "Member"
       human_name "Team Member"
       twiki_name "TeamMember"
     end
   
   end

================================================================================
 ./spec/factories/presentation.rb
================================================================================
   FactoryGirl.define do
     factory :presentation_for_team_bean_counters, class: Presentation do
       name "Test Presentation for Bean Counters"
       description "Desc"
       task_number "1"
       presentation_date Date.new(2012, 1, 1)
       association :course, :factory => :course
       association :team, :factory => :team_bean_counters
     end
   end

================================================================================
 ./spec/factories/presentation_feedback_answers.rb
================================================================================
   FactoryGirl.define do
   
     factory :presentation_feedback_answer_with_question_text, class: PresentationFeedbackAnswer do
       rating 3
       association :question, :factory => :presentation_feedback_questions, :text => "q1"
       association :feedback, :factory => :feedback_from_sam
     end
   
     factory :presentation_feedback_answer_with_question_text_and_comment, class: PresentationFeedbackAnswer do
       rating 3
       comment "Comment 1"
       association :question, :factory => :presentation_feedback_questions, :text => "q1"
       association :feedback, :factory => :feedback_from_sam
     end
   
   end

================================================================================
 ./spec/factories/registration.rb
================================================================================
   FactoryGirl.define do
   
     factory :sally_mfse, :parent => :registration do
   
     end
   
   
   end

================================================================================
 ./spec/factories/sponsored_project_allocations.rb
================================================================================

================================================================================
 ./spec/factories/sponsored_project_efforts.rb
================================================================================

================================================================================
 ./spec/factories/sponsored_project_sponsors.rb
================================================================================

================================================================================
 ./spec/factories/sponsored_projects.rb
================================================================================

================================================================================
 ./spec/factories/task_types.rb
================================================================================

================================================================================
 ./spec/factories/team_assignment.rb
================================================================================
   FactoryGirl.define do
   
     factory :team_turing_assignment, class: TeamAssignment do
       association :team, :factory => :team_turing
       association :user, :factory => :student_sam_user
     end
   
     factory :team_test_assignment, class: TeamAssignment do
       association :team, :factory => :team_test
       association :user, :factory => :student_john_user
     end
   
     factory :team_ruby_racer_assignment, class: TeamAssignment do
       association :team, :factory => :team_ruby_racer
       association :user, :factory => :student_sally_user
     end
   
   end

================================================================================
 ./spec/factories/teams.rb
================================================================================
   FactoryGirl.define do
   
     factory :team_triumphant, :parent => :team do
       name "Team Triumphant"
       email "triumphant@sv.cmu.edu"
       tigris_space "http://triumphantigris.org/servlets/ProjectDocumentList"
       twiki_space "http://info.sv.cmu.edu/twiki/bin/view/Graffiti/WebHome"
       updating_email false
       association :course, :factory => :course
   #    after(:create) { |team| FactoryGirl.create(:student_sam_user, :teams => [team]) }
   #    after(:create) { |team| FactoryGirl.create(:student_sally_user, :teams => [team]) }
       after(:create) { |team| FactoryGirl.create(:student_john_user , :teams => [team])}
       after(:create) { |team| FactoryGirl.create(:student_john_user, :teams => [team]) }
     end
   
     factory :team_bean_counters, class: Team do
       name "Bean Counters"
       email "bean_counters@sv.cmu.edu"
       tigris_space "http://team.tigris.org/servlets/ProjectDocumentList"
       twiki_space "http://info.sv.cmu.edu/twiki/bin/view/Graffiti/WebHome"
       members { |members| [members.association(:student_sally)] }
       association :course, :factory => :course
     end
   
     factory :team_turing, class: Team do
       name "Turing"
       email "turing@sv.cmu.edu"
       primary_faculty_id 46
       updating_email false
       tigris_space "http://team.turing.org/servlets/ProjectDocumentList"
       twiki_space "http://info.sv.cmu.edu/twiki/bin/view/Graffiti/WebHome"
   
       association :course, :factory => :fse
   
     end
   
     factory :team_test, class: Team do
       name "Test"
       email "test@sv.cmu.edu"
       primary_faculty_id 47
       updating_email false
       tigris_space "http://team.test.org/servlets/ProjectDocumentList"
       twiki_space "http://info.sv.cmu.edu/twiki/bin/view/Graffiti/WebHome"
   
       association :course, :factory => :fse
     end
   
     factory :team_ruby_racer, class: Team do
       name "Ruby Racer"
       email "ruby_racer@sv.cmu.edu"
       primary_faculty_id 46
       updating_email false
       tigris_space "http://team.turing.org/servlets/ProjectDocumentList"
       twiki_space "http://info.sv.cmu.edu/twiki/bin/view/Graffiti/WebHome"
   
       association :course, :factory => :fse
   
     end
   end

================================================================================
 ./spec/factories/users.rb
================================================================================
   FactoryGirl.define do
   
     factory :admin_andy_user, :parent => :user do
       id 42
       email "admin.andy@sv.cmu.edu"
       webiso_account "andy@andrew.cmu.edu"
       is_staff true
       is_admin true
       first_name "Admin"
       last_name "Andy"
       human_name "Admin Andy"
       twiki_name "AdminAndy"
       initialize_with { User.find_or_initialize_by_id(id) }
     end
   
     factory :student_sam_user, :parent => :user do
       id 43
       email "student.sam@sv.cmu.edu"
       webiso_account "sam@andrew.cmu.edu"
       is_student true
       is_alumnus false
       first_name "Student"
       last_name "Sam"
       human_name "Student Sam"
       twiki_name "StudentSam"
       initialize_with { User.find_or_initialize_by_id(id) }
   #    initialize_with { User.where(:id => id).first_or_initialize } #Rails 4 way
     end
   
     factory :student_sally_user, :parent => :user do
       id 44
       email "student.sally@sv.cmu.edu"
       webiso_account "sally@andrew.cmu.edu"
       is_student true
       is_alumnus false
       first_name "Student"
       last_name "Sally"
       human_name "Student Sally"
       twiki_name "StudentSally"
       initialize_with { User.find_or_initialize_by_id(id) }
     end
   
     factory :student_john_user, :parent => :user do
       sequence(:email) {|i| "student_john#{i}@sv.cmu.edu"}
       sequence(:webiso_account) {|i| "student_john#{i}@andrew.cmu.edu"}
       sequence(:human_name) {|i| "student_John#{i}"}
       sequence(:first_name) {|i| "student_John#{i}"}
       sequence(:last_name) {|i| "student_John#{i}"}
       sequence(:twiki_name) {|i| "student_John#{i}"}
       is_student true
       is_alumnus false
     end
   
     factory :faculty_frank_user, :parent => :user do
       id 46
       email "faculty.frank@sv.cmu.edu"
       webiso_account "frank@andrew.cmu.edu"
       is_staff true
       first_name "Faculty"
       last_name "Frank"
       human_name "Faculty Frank"
       twiki_name "FacultyFrank"
       initialize_with { User.find_or_initialize_by_id(id) }
     end
   
     factory :faculty_fagan_user, :parent => :user do
       id 47
       email "faculty.fagan@sv.cmu.edu"
       webiso_account "fagan@andrew.cmu.edu"
       is_staff true
       first_name "Faculty"
       last_name "Fagan"
       human_name "Faculty Fagan"
       twiki_name "FacultyFagan"
       initialize_with { User.find_or_initialize_by_id(id) }
     end
   
     factory :contracts_manager_user, :parent => :user do
       id 48
       email "ngoc.ho@sv.cmu.edu"
       webiso_account "ngocho@andrew.cmu.edu"
       is_staff true
       first_name "Ngoc"
       last_name "Ho"
       human_name "Ngoc Ho"
       twiki_name "NgocHo"
       initialize_with { User.find_or_initialize_by_id(id) }
     end
   
     factory :student_setech_user, :parent => :user do
       id 49
       email "student.setech@sv.cmu.edu"
       webiso_account "setech@andrew.cmu.edu"
       is_student true
       is_alumnus false
       masters_program "SE"
       masters_track "Tech"
       first_name "Student"
       last_name "Setech"
       human_name "Student Setech"
       twiki_name "StudentSetech"
       initialize_with { User.find_or_initialize_by_id(id) }
     end
   
     factory :student_phd_user, :parent => :user do
       id 50
       email "student.phd@sv.cmu.edu"
       webiso_account "student_phd@andrew.cmu.edu"
       is_student true
       is_alumnus false
       masters_program "PhD"
       first_name "Student"
       last_name "PhD"
       human_name "Student PhD"
       twiki_name "StudentPhd"
       initialize_with { User.find_or_initialize_by_id(id) }
     end
   
     factory :person_visible_to_setech, :parent => :people_search_default do
       student_staff_group "All"
       program_group "SE"
       track_group "Tech"
     end
   
     factory :student_Test_user, :parent => :user do
       sequence(:email) {|i| "student_Test#{i}@sv.cmu.edu"}
       sequence(:webiso_account) {|i| "student_Test#{i}@andrew.cmu.edu"}
       sequence(:human_name) {|i| "student_Test#{i}"}
       sequence(:first_name) {|i| "student_Test#{i}"}
       sequence(:last_name) {|i| "student_Test#{i}"}
       sequence(:twiki_name) {|i| "student_Test#{i}"}
       is_student true
       is_alumnus false
     end
   
   end

================================================================================
 ./spec/helpers.rb
================================================================================
   module Helpers
     def current_user(stubs = {})
!!     @current_user ||= mock_model("User", stubs)
     end
   end

================================================================================
 ./spec/helpers/jobs_helper_spec.rb
================================================================================
   require 'spec_helper'
   
   describe JobsHelper do
   
     let(:job) { FactoryGirl.build(:job_with_supervisor_and_employee) }
   
     describe "Job person's names" do
       xit "should have a supervisor"
       # it "should have a method to get the names of supervisors if they exist" do
       #     expect(helper.job_person_names(job.job_supervisors)).to be_empty
       # end
     end
   
     describe "Closed jobs" do
       xit "should automatically convert jobs to not accepting if they get closed"
       xit "should not show closed jobs by default"
       xit "should also show closed jobs if show_all parameter is passed in"
     end
   
   end

================================================================================
 ./spec/helpers/people_helper_spec.rb
================================================================================
   # require 'spec_helper'
   require_relative "../../app/helpers/people_helper"
   
   class Person; end
   
   
   describe PeopleHelper do
       describe "social handles" do
   
           before(:each) do
               @person = double(Person)
               @person.extend(PeopleHelper)
           end
   
           it "takes in all combinations and format the url correctly for Facebook" do
               [   "http://www.facebook.com/iamsam",
                   "www.facebook.com/iamsam",
                   "http://facebook.com/iamsam",
                   "http://www.facebook.com/iamsam",
                   "facebook.com/iamsam",
                   "http://www.facebook.com/iamsam",
                   "facebook.com/iamsam"
               ].each do |url_input|
                 @person.stub(:facebook){ url_input }
                 @person.facebook_path(@person).should == "http://www.facebook.com/iamsam"
               end
   
               [   "https://www.facebook.com/iamsam",
                   "https://facebook.com/iamsam"
               ].each do |url_input|
                 @person.stub(:facebook){ url_input }
                 @person.facebook_path(@person).should == "https://www.facebook.com/iamsam"
               end
           end
   
           it "takes in Twitter urls and formats the url correctly" do
               @person.stub(:twitter){ "iamsam" }
               @person.twitter_path(@person).should == "http://www.twitter.com/iamsam"
           end
   
           it "takes in github urls and formats the url correctly" do
               @person.stub(:github){ "iamsam" }
               @person.github_path(@person).should == "http://www.github.com/iamsam"
           end
   
           it "takes in all combinations and format the url correctly for LinkedIn" do
               [   "http://www.linkedin.com/in/iamsam",
                   "www.linkedin.com/in/iamsam",
                   "http://linkedin.com/in/iamsam",
                   "http://www.linkedin.com/in/iamsam",
                   "linkedin.com/in/iamsam",
                   "http://www.linkedin.com/in/iamsam",
                   "linkedin.com/in/iamsam"
               ].each do |url_input|
                 @person.stub(:linked_in){ url_input }
                 @person.linked_in_path(@person).should == "http://www.linkedin.com/in/iamsam"
               end
   
               [   "https://www.linkedin.com/in/iamsam",
                   "https://linkedin.com/in/iamsam"
               ].each do |url_input|
                 @person.stub(:linked_in){ url_input }
                 @person.linked_in_path(@person).should == "https://www.linkedin.com/in/iamsam"
               end
           end
   
           it "takes in Google+ urls and formats the url correctly" do
   
               [   "http://plus.google.com/1234567890",
                   "www.plus.google.com/1234567890",
                   "http://www.plus.google.com/1234567890",
                   "plus.google.com/1234567890",
                   "http://www.plus.google.com/1234567890",
                   "plus.google.com/1234567890",
   
                   "http://plus.google.com/1234567890/posts",
                   "www.plus.google.com/1234567890/posts",
                   "http://www.plus.google.com/1234567890/posts",
                   "plus.google.com/1234567890/posts",
                   "http://www.plus.google.com/1234567890/posts",
                   "plus.google.com/1234567890/posts"
               ].each do |url_input|
                   @person.stub(:google_plus){ url_input }
                   @person.google_plus_path(@person).should == "http://plus.google.com/1234567890"
               end
               [   "https://plus.google.com/1234567890/posts",
                   "https://plus.google.com/1234567890",
                   "https://www.plus.google.com/1234567890",
                   "https://www.plus.google.com/1234567890/posts"
               ].each do |url_input|
                   @person.stub(:google_plus){ url_input }
                   @person.google_plus_path(@person).should == "https://plus.google.com/1234567890"
               end
           end
   
       end
   end

================================================================================
 ./spec/lib/HUB_class_roster_handler_spec.rb
================================================================================
   require 'spec_helper'
   require 'HUB_class_roster_handler' #This line is required for Travis
   
   describe HUBClassRosterHandler do
     context "When processing a roster file that lists Sam and Sally as participants in a course," do
       context "and they are not already in the course," do
         before :each do
           @roster_file = File.read("#{Rails.root}/spec/data/student_addnew_with_missing.txt")
           # @older_course = FactoryGirl.create(:fse_fall_2011, :year => 1900)
           @course = FactoryGirl.create(:fse_fall_2011)
           @student_sam = FactoryGirl.create(:student_sam)
           @student_sally = FactoryGirl.create(:student_sally)
         end
   
         it "should add them to the course" do
           expect { HUBClassRosterHandler.handle(@roster_file) }.to change { @course.registered_students.reload.count }.from(0).to(2)
         end
   
         it "should add them to the most recent course" do
           expect { HUBClassRosterHandler.handle(@roster_file) }.to change { @course.registered_students.reload.count }.from(0).to(2)
         end
   
         #it "should add them to the most recent course" do
         #  @older_course = FactoryGirl.create(:mfse, :year => @course.year - 1)
         #  expect { HUBClassRosterHandler.handle(@roster_file) }.to_not change { @older_course }
         #end
   
   
         it "should notify help@sv.cmu.edu about missing students" do
           subject.should_receive(:email_help_about_missing_student).exactly(1).times
           subject.handle(@roster_file)
         end
   
         it "should notify profs only once" do
           subject.should_receive(:email_professors_about_added_and_dropped_students).exactly(1).times
           subject.handle(@roster_file)
         end
   
         it "should send the emails" do
           expect { HUBClassRosterHandler.handle(@roster_file) }.to change { ActionMailer::Base.deliveries.count }.by(2)
         end
   
       end
   
       context "and they are already in the course," do
         before :each do
           @roster_file = File.read("#{Rails.root}/spec/data/student_addnew_with_no_missing.txt")
           @course = FactoryGirl.create(:fse_fall_2011)
           @course.registered_students << @student_sam = FactoryGirl.create(:student_sam_user)
           @course.registered_students << @student_sally = FactoryGirl.create(:student_sally_user)
           @course.save
         end
   
         it "should not make any changes" do
           expect { HUBClassRosterHandler.handle(@roster_file) }.to_not change { @course.registered_students.reload.count }
         end
   
         it "should not notify the profs" do
           subject.should_receive(:email_professors_about_added_and_dropped_students).exactly(0).times
           subject.handle(@roster_file)
         end
   
         it "should not send any emails" do
           expect { HUBClassRosterHandler.handle(@roster_file) }.to change { ActionMailer::Base.deliveries.count }.by(0)
         end
   
         context "with a student who is not in the system," do
           before :each do
             @roster_file = File.read("#{Rails.root}/spec/data/student_addnew_with_missing.txt")
           end
   
           it "should notify help@sv.cmu.edu about missing students" do
             subject.should_receive(:email_help_about_missing_student).exactly(1).times
             subject.handle(@roster_file)
           end
   
           it "should notify the profs" do
             subject.should_receive(:email_professors_about_added_and_dropped_students).exactly(1).times
             subject.handle(@roster_file)
           end
   
           it "should send the emails" do
             expect { HUBClassRosterHandler.handle(@roster_file) }.to change { ActionMailer::Base.deliveries.count }.by(2)
           end
         end
       end
     end
   
     context "When processing a roster that has no students for a course" do
       before :each do
         @roster_file = File.read("#{Rails.root}/spec/data/student_dropall.txt")
         @course = FactoryGirl.create(:fse_fall_2011)
         @course.registered_students << @student_sam = FactoryGirl.create(:student_sam_user)
         @course.registered_students << @student_sally = FactoryGirl.create(:student_sally_user)
         @course.faculty << @faculty_frank = FactoryGirl.create(:faculty_frank)
         @course.faculty << @faculty_fagan = FactoryGirl.create(:faculty_fagan)
         @course.save
       end
   
       it "should drop the students" do
         expect { HUBClassRosterHandler.handle(@roster_file) }.to change { Course.find(@course.id).registered_students.count }.from(2).to(0)
       end
   
   
       it "should notify help@sv.cmu.edu about missing students" do
         subject.should_receive(:email_help_about_missing_student).exactly(22).times
         subject.handle(@roster_file)
       end
   
       it "should notify the profs" do
         subject.should_receive(:email_professors_about_added_and_dropped_students).exactly(1).times
         subject.handle(@roster_file)
       end
   
       it "should send the emails" do
         expect { HUBClassRosterHandler.handle(@roster_file) }.to change { ActionMailer::Base.deliveries.count }.by(23)
       end
   
     end
   
     context "When emailing professors about students that were added, dropped or not in system" do
       before :each do
         @course = FactoryGirl.create(:fse_fall_2011)
         @info = { :not_in_system => ['new_student'], :added => [], :dropped => [] }
       end
   
       it "should include gerry.elizondo@sv.cmu.edu as one of the recipients" do
         email = HUBClassRosterHandler.email_professors_about_added_and_dropped_students(@course, @info)
         email.to.should include("gerry.elizondo@sv.cmu.edu")
       end
     end
   
   
     describe "roster_change_message" do
       before :each do
         @course = FactoryGirl.create(:fse_fall_2011)
         @course.save
   
         @person1 = FactoryGirl.create(:student_sam)
         @person2 = FactoryGirl.create(:student_sally)
   
         @experimental_feature_text = "** This is an experimental feature. **"
         @official_registration_text = "The official registration list for your course can be <a href='https://acis.as.cmu.edu/grades/'>found here</a>"
         @updating_email_text = "The system will be updating your course mailing list (#{@course.email}) For more information, see your <a href='http://whiteboard.sv.cmu.edu/courses/#{@course.id}'>course tools</a>"
   
       end
   
       it "course is nil" do
         message = HUBClassRosterHandler.roster_change_message(nil, nil, nil, nil)
   
         expected_body = "This email is supposed to contain information about course roster changes, but an error occurred while"
         expected_body += "generating its contents.  Please contact <a href='mailto:todd.sedano@sv.cmu.edu?subject=Roster%20Email%20Error'>Todd Sedano</a>"
         expected_body += "to resolve any issues."
   
         message.should == expected_body
       end
   
       it "nil added, dropped, and not_in_system" do
         message = HUBClassRosterHandler.roster_change_message(@course, nil, nil, nil)
   
         message.should include @experimental_feature_text
         message.should include @official_registration_text
         message.should include @updating_email_text
       end
   
       it "empty added, dropped, and not_in_system" do
         message = HUBClassRosterHandler.roster_change_message(@course, [], [], [])
   
         message.should include @experimental_feature_text
         message.should include @official_registration_text
         message.should include @updating_email_text
       end
   
       it "with added students" do
         @person2.first_name = "<script>cool"
         @person2.last_name = "<script>hacker"
         message = HUBClassRosterHandler.roster_change_message(@course, [@person1, @person2], [], [])
         
         expected_body = "2 students were added to the course:<br/>"
         expected_body += "&nbsp;&nbsp;&nbsp;#{@person1.first_name} #{@person1.last_name}<br/>"
         expected_body += "&nbsp;&nbsp;&nbsp;&lt;script&gt;cool &lt;script&gt;hacker<br/>"
   
         message.should include @experimental_feature_text
         message.should include @updating_email_text
         message.should include expected_body
       end
   
       it "with one added student" do
         message = HUBClassRosterHandler.roster_change_message(@course, [@person1], [], [])
   
         message.should include("1 student was added to the course")
       end
   
       it "with dropped students" do
         @person2.first_name = "<script>cool"
         @person2.last_name = "<script>hacker"
         message = HUBClassRosterHandler.roster_change_message(@course, [], [@person1, @person2], [])
         
         expected_body = "2 students were dropped from the course:<br/>"
         expected_body += "&nbsp;&nbsp;&nbsp;#{@person1.first_name} #{@person1.last_name}<br/>"
         expected_body += "&nbsp;&nbsp;&nbsp;&lt;script&gt;cool &lt;script&gt;hacker<br/>"
   
         message.should include @experimental_feature_text
         message.should include @updating_email_text
         message.should include expected_body
       end
   
       it "with one dropped student" do
         message = HUBClassRosterHandler.roster_change_message(@course, [], [@person1], [])
   
         message.should include("1 student was dropped from the course")
       end
   
       it "with students not_in_system" do
         message = HUBClassRosterHandler.roster_change_message(@course, [], [], ["student1", "<script>hacker"])
         
         expected_body = "2 registered students are not in any of our SV systems:<br/>"
         expected_body += "&nbsp;&nbsp;&nbsp;student1@andrew.cmu.edu<br/>"
         expected_body += "&nbsp;&nbsp;&nbsp;&lt;script&gt;hacker@andrew.cmu.edu<br/>"
         expected_body += "We can easily create accounts for these 2 students. Please forward this email to help@sv.cmu.edu indicating which students you want added. (The rails system will create google and twiki accounts.)<br/><br/>"
   
         message.should include @experimental_feature_text
         message.should include @updating_email_text
         message.should include expected_body
       end
   
       it "with one student not_in_system" do
         message = HUBClassRosterHandler.roster_change_message(@course, [], [], ["student1"])
   
         message.should include("1 registered student is not in any of our SV systems")
       end
   
       it "with students added, dropped and not_in_system" do
         message = HUBClassRosterHandler.roster_change_message(@course, [@person1], [@person2], ["student1", "student2"])
         
         expected_body = "2 registered students are not in any of our SV systems:<br/>"
         expected_body += "&nbsp;&nbsp;&nbsp;student1@andrew.cmu.edu<br/>"
         expected_body += "&nbsp;&nbsp;&nbsp;student2@andrew.cmu.edu<br/>"
         expected_body += "We can easily create accounts for these 2 students. Please forward this email to help@sv.cmu.edu indicating which students you want added. (The rails system will create google and twiki accounts.)<br/><br/>"
         expected_body += "1 student was added to the course:<br/>"
         expected_body += "&nbsp;&nbsp;&nbsp;#{@person1.first_name} #{@person1.last_name}<br/>"
         expected_body += "1 student was dropped from the course:<br/>"
         expected_body += "&nbsp;&nbsp;&nbsp;#{@person2.first_name} #{@person2.last_name}<br/>"
   
         message.should include @experimental_feature_text
         message.should include @updating_email_text
         message.should include expected_body
       end
     end
   end

================================================================================
 ./spec/lib/active_directory_spec.rb
================================================================================
   require "spec_helper"
   
   describe "ActiveDirectory" do
   
     before do
       @ldap_server = Ladle::Server.new(:quiet => true, :port=>3897).start
!!     @faculty_frank = FactoryGirl.create(:faculty_frank, email: "faculty.frank@sandbox.sv.cmu.edu")
!!     @active_directory_services = ActiveDirectory.new
     end
   
     after do
       @ldap_server.stop if @ldap_server
     end
   
     it 'ldap_distinguished_name method returns valid distinguished name for staff' do
!!     @active_directory_services.ldap_distinguished_name(@faculty_frank).should eq("cn=Faculty Frank,ou=Staff,ou=Sync,dc=cmusv,dc=sv,dc=cmu,dc=local")
     end
   
     it 'ldap_distinguished_name method returns valid distinguished name for student' do
!!     @student_sam = FactoryGirl.create(:student_sam, masters_program: 'SE')
!!     @active_directory_services.ldap_distinguished_name(@student_sam).should eq("cn=Student Sam,ou=SE,ou=Students,ou=Sync,dc=cmusv,dc=sv,dc=cmu,dc=local")
     end
   
     it 'ldap_attributes method returns necessary ldap attributes' do
!!     @active_directory_services.ldap_attributes(@faculty_frank).should include( :cn=>"Faculty Frank",
                                                                                 :mail=>"faculty.frank@sandbox.sv.cmu.edu",
                                                                                 :objectclass=>["top", "person", "organizationalPerson", "user"],
                                                                                 :userPrincipalName=>"faculty.frank@sandbox.sv.cmu.edu")
     end
   
     it 'password_encode method encodes password to hexadecimal base 64' do
!!     @active_directory_services.password_encode("pass").should == "\"\x00p\x00a\x00s\x00s\x00\"\x00"
     end
   
   end

================================================================================
 ./spec/lib/google_mailing_list_job_spec.rb
================================================================================
   require 'spec_helper'
   
   describe GoogleMailingListJob do
   
   #
   # This is a carry over test from Team before the code was refactored into a lib
   #
   it "should throw an error when a google distribution list was not created" do
     ProvisioningApi.any_instance.stub(:create_group)
     ProvisioningApi.any_instance.stub(:add_member_to_group)
     ProvisioningApi.any_instance.stub(:delete_group)
     ProvisioningApi.any_instance.stub(:retrieve_all_members)
     ProvisioningApi.any_instance.stub(:retrieve_all_groups)
   
     team = FactoryGirl.create(:team_triumphant)
     lambda { team.update_google_mailing_list("new", "old", 123) }.should raise_error()
   end
   
   
   end

================================================================================
 ./spec/lib/reminder_handler_spec.rb
================================================================================
   require 'spec_helper'
   require 'reminder_handler' #This line is required for Travis
   
   describe ReminderHandler do
     context "while sending reminders for" do
   
       context "updating pages," do
         before :each do
           @current_time = Time.now
           @user = FactoryGirl.build_stubbed(:faculty_frank_user)
           # While storing to Active Record, use current_time.utc as Active record
           # assumes pacific time (config/application.rb) but stores as utc
           # internally. Causing the test case to fail.
           # Time zone overriden in (config/environments/test.rb)
           @page1 = FactoryGirl.build_stubbed(:ppm, updated_by_user_id: @user.id,
                                             updated_at: @current_time.utc - 1.year)
           @page2 = FactoryGirl.build_stubbed(:ppm, url: "page2",
                                             updated_by_user_id: @user.id,
                                             updated_at: @current_time.utc - 13.months)
           Page.stub(:all).and_return([@page1, @page2])
           @page1.stub(:updated_by).and_return(@user)
           @page2.stub(:updated_by).and_return(@user)
         end
   
         context "should only include pages that were last updated at the specified time (same day and month) in previous years" do
           subject { ReminderHandler.pages_to_update_by_user_id(@current_time) }
           it { should_not be_nil }
           it { should have_exactly(1).item }
           it { should have_key(@user) }
           it { should include(@user => [@page1]) }
         end
   
         context "should include urls and labels of all specified pages" do
           subject { ReminderHandler.page_urls_with_labels([@page1]) }
           it { should_not be_nil }
           it { should have_exactly(1).item }
           it { should have_key(Rails.application.routes.url_helpers::edit_page_url(@page1.id,
                                                         :host => "whiteboard.sv.cmu.edu")) }
           it { should include(Rails.application.routes.url_helpers::edit_page_url(@page1.id,
                                                         :host => "whiteboard.sv.cmu.edu") => @page1.title) }
         end
   
         it "should send out an email to the user who last updated the page" do
           expect { ReminderHandler.send_page_update_reminders(@current_time)
                  }.to change { ActionMailer::Base.deliveries.count }.by(1)
         end
       end
   
     end
   end

================================================================================
 ./spec/mailers/course_mailer_spec.rb
================================================================================
   require "spec_helper"
   
   describe CourseMailer do
     before(:each) do
       ActionMailer::Base.delivery_method = :test
       ActionMailer::Base.perform_deliveries = true
       ActionMailer::Base.deliveries = []
     end
     it "should send IT email" do
       course = FactoryGirl.create(:course, :configure_course_twiki => true)
       mail = CourseMailer.configure_course_admin_email(course).deliver
       ActionMailer::Base.deliveries.size.should == 1
       mail.subject.should match(Regexp.new(course.name))
       mail.body.encoded.should match(Regexp.new(course.name))
     end
   
     it "should send faculty email" do
       course = FactoryGirl.create(:course, :configure_course_twiki => true)
       mail = CourseMailer.configure_course_faculty_email(course).deliver
       ActionMailer::Base.deliveries.size.should == 1
       mail.subject.should match(Regexp.new(course.name))
       mail.body.encoded.should match(Regexp.new(course.name))
     end
   end

================================================================================
 ./spec/mailers/effort_log_mailer_spec.rb
================================================================================
   require "spec_helper"
   
   describe EffortLogMailer do
     pending "add some examples to (or delete) #{__FILE__}"
   end

================================================================================
 ./spec/mailers/generic_mailer_spec.rb
================================================================================
   require "spec_helper"
   
   describe GenericMailer do
     pending "add some examples to (or delete) #{__FILE__}"
   end

================================================================================
 ./spec/mailers/page_comment_mailer_spec.rb
================================================================================
   require "spec_helper"
   
   describe PageCommentMailer do
     pending "add some examples to (or delete) #{__FILE__}"
   end

================================================================================
 ./spec/mailers/password_mailer_spec.rb
================================================================================
   require "spec_helper"
   
   describe PasswordMailer do
     describe "password_reset" do
       #
       #@user = FactoryGirl.create(:student_sally_user)
       #let(:mail) { PasswordMailer.password_reset(@user) }
       #
       #it "renders the headers" do
       #  mail.subject.should eq("Password reset")
       #  mail.to.should eq(["to@example.org"])
       #  mail.from.should eq(["from@example.com"])
       #end
       #
       #it "renders the body" do
       #  mail.body.encoded.should match("Hi")
       #end
     end
   
   end

================================================================================
 ./spec/mailers/person_mailer_spec.rb
================================================================================
   require "spec_helper"
   
   describe PersonMailer do
     pending "add some examples to (or delete) #{__FILE__}"
   end

================================================================================
 ./spec/mailers/reminder_mailer_spec.rb
================================================================================
   require "spec_helper"
   
   describe ReminderMailer do
     context "while reminding users" do
       before(:each) do
         @user = FactoryGirl.create(:faculty_frank_user)
         @page = FactoryGirl.create(:ppm, updated_by_user_id: @user.id)
         @options = {:to => @user.email,
                     :subject => "Reminder",
                     :message => "Reminder message",
                     :urls => {"http://whiteboard.sv.cmu.edu" => @page.title}}
       end
   
       it "should send email" do
         expect { ReminderMailer.email(@options).deliver
                }.to change { ActionMailer::Base.deliveries.count }.by(1)
       end
     end
   end

================================================================================
 ./spec/mailers/sponsored_project_effort_mailer_spec.rb
================================================================================
   require "spec_helper"
   
   describe SponsoredProjectEffortMailer do
     pending "add some examples to (or delete) #{__FILE__}"
   end

================================================================================
 ./spec/models/archived_behavior.rb
================================================================================
   # @current =  FactoryGirl.create(:sponsored_project_sponsor, :is_archived => false)
   # @archive =  FactoryGirl.create(:sponsored_project_sponsor, :is_archived => true)
   
     shared_examples_for "archived objects" do
       it "should respond to current" do
         @current.class.should respond_to(:current)
       end
   
       it "current includes only current" do
         current_items = @current.class.current
         current_items.length.should == 1
         current_items[0].should == @current
       end
   
       it "should respond to archived" do
         @current.class.should respond_to(:archived)
       end
   
       it "archived includes only archived" do
         archived_items = @current.class.archived
         archived_items.length.should == 1
         archived_items[0].should == @archived
       end
     end

================================================================================
 ./spec/models/assignment_spec.rb
================================================================================
   require 'spec_helper'
   
   describe Assignment do
   
     context "validate assignments" do
       [:maximum_score, :course_id].each do  |attr|
           it "without #{attr} not valid" do
             subject.should_not be_valid
             subject.errors[attr].should_not be_empty
           end
       end
       it {should belong_to(:course)}
       it {should have_many(:grades)}
     end
   
     context "maximum score" do
       it "should be a number" do
         subject.maximum_score = "just for test"
         subject.maximum_score.should_not  be_a(Fixnum)
         subject.should_not be_valid
       end
   
       it 'should not be negative' do
         subject.maximum_score = -1.0
         subject.should_not be_valid
       end
     end
     context "assignment list" do
       before do
         @courses = []
         @current_assignments = []
         @past_assignments = []
         @assignments = []
         @students = []
         2.times.each do |student|
           @students << FactoryGirl.create(:student_john_user)
         end
   
         4.times.each do |course|
           if course < 2
             course = FactoryGirl.create(:course, :registered_students=>@students, :year => Date.today.year)
             @current_assignments << FactoryGirl.create(:assignment, :course_id=>course.id)
             @current_assignments << FactoryGirl.create(:assignment_team, :course_id=>course.id)
             @current_assignments << FactoryGirl.create(:assignment_unsubmissible, :course_id=>course.id)
           else
             course = FactoryGirl.create(:course, :registered_students=>@students, :year => Date.today.year-1)
             @past_assignments << FactoryGirl.create(:assignment, :course_id=>course.id)
             @past_assignments << FactoryGirl.create(:assignment_team, :course_id=>course.id)
             @past_assignments << FactoryGirl.create(:assignment_unsubmissible, :course_id=>course.id)
           end
           @courses << course
         end
         @assignments = @current_assignments + @past_assignments
       end
   
       it "List Student's all assignments" do
         all = Assignment.list_assignments_for_student(@students[0].id).sort_by {|a| a.id}
         all.should eq(@assignments)
       end
       it "List Student's current assignments" do
         curr = Assignment.list_assignments_for_student(@students[0].id, :current).sort_by {|a| a.id}
         curr.should eq(@current_assignments)
       end
       it "List Student's past assignments" do
         past = Assignment.list_assignments_for_student(@students[0].id, :past).sort_by {|a| a.id}
         past.should eq(@past_assignments)
       end
   
       it "can get student's deliverable for individual assignment " do
         deliverable = FactoryGirl.create(:individual_deliverable, :assignment_id => @assignments[0].id, :creator_id => @students[0].id)
         @assignments[0].get_student_deliverable(@students[0].id).should  eq(deliverable)
       end
   
       it "can get student's deliverable for team assignment " do
         team = FactoryGirl.create(:team, :course_id=>@courses[0].id)
         team.members = @students
         deliverable = FactoryGirl.create(:team_deliverable, :assignment_id => @assignments[1].id, :team_id=>team.id, :creator_id => @students[0].id)
         @assignments[1].get_student_deliverable(@students[0].id).should eq(deliverable)
         @assignments[1].get_student_deliverable(@students[1].id).should eq(deliverable)
       end
   
       it "can get student's grade for an assignment " do
         grade = FactoryGirl.create(:grade, :assignment_id => @assignments[0].id, :student_id => @students[0].id, :course_id=>@courses[0].id)
         @assignments[0].get_student_grade(@students[0].id).should eq(grade)
       end
   
     end
   
     context "Assignment Order" do
       before do
         @course = FactoryGirl.create(:course)
       end
   
       it "should increment automatically by 1 for specific course" do
   
         course2 = FactoryGirl.create(:mfse)
         course_assignment1 = FactoryGirl.create(:assignment, :task_number => 1, :course => @course)
         course_assignment2 = FactoryGirl.create(:assignment, :task_number => 1, :course => @course)
         course2_assignment1 = FactoryGirl.create(:assignment, :task_number => 1, :course => course2)
         course_assignment1.assignment_order.should eq(1)
         course_assignment2.assignment_order.should eq(2)
         course2_assignment1.assignment_order.should eq(1)
   
       end
   
       it "should increment automatically by 1 if there are other assignment added" do
         @task1_assignment1 = FactoryGirl.create(:assignment, :task_number => 1, :course => @course)
         @task1_assignment2 = FactoryGirl.create(:assignment, :task_number => 2, :course => @course)
         @task1_assignment2.assignment_order.should eq(2)
       end
   
       it "should be assignned  even if the task number is blank" do
         @assignment1 = FactoryGirl.create(:assignment, :task_number => nil, :course => @course)
         @assignment2 = FactoryGirl.create(:assignment, :task_number => nil, :course => @course)
         @assignment1.assignment_order.should eq(1)
         @assignment2.assignment_order.should eq(2)
       end
   
       it "should re-order the assignment order number when reposition is called" do
         @assignment1 = FactoryGirl.create(:assignment, :task_number => nil, :course => @course)
         @assignment2 = FactoryGirl.create(:assignment, :task_number => nil, :course => @course)
         @assignment3 = FactoryGirl.create(:assignment, :task_number => nil, :course => @course)
         desired_order = [@assignment3.id, @assignment2.id, @assignment1.id]
         Assignment.reposition(desired_order)
         new_order = Assignment.all.collect(&:id)
         new_order.should eq(desired_order)
       end
     
     end
     context "Delete Assignment" do
       before :each do
         @course = FactoryGirl.create(:course)
       end
       it "should be able to delete assignment if no student submit for it" do
         assignment = FactoryGirl.create(:assignment, :task_number => nil, :course => @course)
         before_delete = Assignment.count
         assignment.destroy
         Assignment.count.should eq(before_delete-1)
       end
       it "should not be able to delete assignment if student submit for it"  do
         deliverable=FactoryGirl.create(:deliverable)
         assignment = FactoryGirl.create(:assignment, :task_number => nil, :course => @course, :deliverables => [deliverable])
         before_delete = Assignment.count
         assignment.destroy
         Assignment.count.should eq(before_delete)
       end
   
     end
   
     context "Due date of Assignment" do
       before :each do
         @course = FactoryGirl.create(:course)
         @assignment = FactoryGirl.create(:assignment, :task_number => nil, :course => @course)
       end
   
       it "should have a due date when update" do
         @assignment.set_due_date("2013-12-3", "05", "02")
         @assignment.due_date.strftime("%Y-%m-%d %H:%M").should == "2013-12-03 05:02"
       end
   
       it "should be blank if the date is blank" do
         @assignment.set_due_date("", "05", "02")
         @assignment.due_date.blank?.should == true
       end
   
       it "should be 10 PM if the hour and minute values are blank" do
         @assignment.set_due_date("2013-12-3", "", "")
         @assignment.due_date.strftime("%Y-%m-%d %H:%M").should == "2013-12-03 22:00"
       end
   
       it "should be 10 PM if an hour value is not entered" do
         @assignment.set_due_date("2013-12-3", "", "10")
         @assignment.due_date.strftime("%Y-%m-%d %H:%M").should == "2013-12-03 22:00"
       end
   
       it "should be reset to 0 minutes if only an hour value is entered" do
         @assignment.set_due_date("2013-12-3", "13", "")
         @assignment.due_date.strftime("%Y-%m-%d %H:%M").should == "2013-12-03 13:00"
       end
   
     end
   end

================================================================================
 ./spec/models/course_model_spec.rb
================================================================================
   require 'spec_helper'
   
   describe Course do
   
     it 'can be created' do
       lambda {
         FactoryGirl.create(:course)
       }.should change(Course, :count).by(1)
     end
   
     context "is not valid" do
   
       [:semester, :year, :mini, :name].each do |attr|
         it "without #{attr}" do
           subject.should_not be_valid
           subject.errors[attr].should_not be_empty
         end
       end
     end
   
     context "custom finders" do
   
       specify { Course.should respond_to(:last_offering) }
   
       it 'finds the last course offered with the same course number' do
         @first = FactoryGirl.create(:course, :semester => "Fall", :year => 2010)
         @third = FactoryGirl.create(:course, :semester => "Summer", :year => 2011)
         @second = FactoryGirl.create(:course, :semester => "Spring", :year => 2011)
         Course.last_offering(@first.number).should == @third
       end
     end
   
   
     #it "display name should return the name" do
     #    @course = FactoryGirl.create(:mfse)
     #  result = @course.display_course_name
     #  result.should ==  "MfSESpring2012"
     #end
   
     #context "Display name" do
     #  it "should display a no short name right" do
     #    course = FactoryGirl.create(:course)
     #    course.display_name.should == "Course"
     #  end
     #  it "should display with a short name correctly" do
     #    course = FactoryGirl.create(:fse)
     #    course.display_name.should == "Foundations of Software Engineering (FSE)"
     #  end
     # it "should show the short name if there is one" do
     #   course = FactoryGirl.create(:fse)
     #   course.short_or_full_name.should == "FSE"
     # end
     #  it "shouldn't show short name if there isn't" do
     #    course = FactoryGirl.create(:course)
     #    course.short_or_full_name.should == "Course"
     #    course = FactoryGirl.create(:fse,:short_name => "")
     #    course.short_or_full_name.should == "Foundations of Software Engineering"
     #  end
     #end
     #
     #
     # context "display semester" do
     #   it "should display semester right" do
     #     course = FactoryGirl.create(:mfse)
     #     course.display_semester.should == "Spring2012"
     #   end
     # end
     #  context "remind about effort" do
     #    it "should remind for mini= both or something" do
     #      course = FactoryGirl.create(:fse, :remind_about_effort => true)
     #      Course.remind_about_effort_course_list[0].should == course
     #    end
     #    it "should remind for mini is not both" do
     #      course2 = FactoryGirl.create(:mfse_current_semester,:remind_about_effort => true, :mini => "A")
     #      Course.remind_about_effort_course_list[0].should == course2
     #    end
     #end
   
     #it "first_offering_for_course_name should return the first course given one" do
     #    @course = FactoryGirl.create(:mfse)
     #    @first = Course.first_offering_for_course_name(@course.name)
     #    @first.should == @course
     #end
   
     # it "for semester should find courses by semester" do
     #   year = Date.today.year
     #   mfse = FactoryGirl.create(:mfse, :semester => "Fall", :year => year )
     #   fse = FactoryGirl.create(:fse, :semester => "Fall", :year => year)
     #   spring_course = FactoryGirl.create(:mfse_current_semester, :semester => "Spring", :year => year)
     #   Course.for_semester("Fall", year)[0].should == fse
     #   Course.for_semester("Fall", year)[1].should == mfse
     #   Course.for_semester("Spring", year)[0].should == spring_course
     #end
   
   
     #it "should know which courses are offered this semester" do
     #  list = Course.current_semester_courses
     #  course = FactoryGirl.create(:fse)
     #  list2 = Course.current_semester_courses
     #  list.length.should be_equal list2.length - 1
     #
     #end
     #
     #it "should know which courses are offered next semester" do
     #  list = Course.next_semester_courses
     #  course = FactoryGirl.create(:mfse)
     #  list2 = Course.next_semester_courses
     #  list.length.should be_equal list2.length - 1
     #end
   
     it "should know the start of the course (in cweek)" do
       course = FactoryGirl.build(:course, :semester => "Fall", :year => "2010", :mini => 'Both')
       course.course_start.should == AcademicCalendar.semester_start("Fall", 2010)
   
       course = FactoryGirl.build(:course, :semester => "Fall", :year => "2010", :mini => 'A')
       course.course_start.should == AcademicCalendar.semester_start("Fall", 2010)
   
       course = FactoryGirl.build(:course, :semester => "Fall", :year => "2010", :mini => 'B')
       course.course_start.should == AcademicCalendar.semester_start("Fall", 2010) + 8
   
       course = FactoryGirl.build(:course, :semester => "Spring", :year => "2010", :mini => 'Both')
       course.course_start.should == AcademicCalendar.semester_start("Spring", 2010)
   
       course = FactoryGirl.build(:course, :semester => "Spring", :year => "2010", :mini => 'A')
       course.course_start.should == AcademicCalendar.semester_start("Spring", 2010)
   
       course = FactoryGirl.build(:course, :semester => "Spring", :year => "2010", :mini => 'B')
       course.course_start.should == AcademicCalendar.semester_start("Spring", 2010) + 9
   
       course = FactoryGirl.build(:course, :semester => "Summer", :year => "2010", :mini => 'Both')
       course.course_start.should == AcademicCalendar.semester_start("Summer", 2010)
   
       course = FactoryGirl.build(:course, :semester => "Summer", :year => "2010", :mini => 'A')
       course.course_start.should == AcademicCalendar.semester_start("Summer", 2010)
   
       course = FactoryGirl.build(:course, :semester => "Summer", :year => "2010", :mini => 'B')
       course.course_start.should == AcademicCalendar.semester_start("Summer", 2010) + 6
   
     end
   
     it "should remind effort reports for a particular class with a valid Mini field" do
       valid_course = FactoryGirl.create(:course, :semester => AcademicCalendar.current_semester, :year => Date.today.cwyear, :mini => 'Both', :remind_about_effort => true)
       invalid_course = FactoryGirl.create(:course, :semester => AcademicCalendar.current_semester, :year => Date.today.cwyear, :mini => 'both', :remind_about_effort => true)
       course_list = Course.remind_about_effort_course_list
   
       course_list.find_index(valid_course).should >= 0
       course_list.find_index(invalid_course).should == nil
     end
   
     it "should be able to auto_generated_twiki_url" do
       course = FactoryGirl.build(:course, :semester => "Fall", :year => "2010", :name => "Foundations of Software Engineering")
       course.auto_generated_twiki_url.should == "http://info.sv.cmu.edu/do/view/Fall2010/FoundationsofSoftwareEngineering/WebHome"
   
       course = FactoryGirl.build(:course, :semester => "Fall", :year => "2010", :short_name => "FSE")
       course.auto_generated_twiki_url.should == "http://info.sv.cmu.edu/do/view/Fall2010/FSE/WebHome"
     end
   
     it "should auto_generated_peer_evaluation_date_start" do
       course = FactoryGirl.build(:course, :semester => "Fall", :year => "2010")
       course.auto_generated_peer_evaluation_date_start.to_s.should == "2010-10-04"
     end
   
     it "should auto_generated_peer_evaluation_date_end" do
       course = FactoryGirl.build(:course, :semester => "Fall", :year => "2010")
       course.auto_generated_peer_evaluation_date_end.to_s.should == "2010-10-11"
     end
   
     it "is versioned" do
       course = FactoryGirl.build(:course)
       course.should respond_to(:version)
       course.save
       version_number = course.version
       course.name = "I changed my mind"
       course.save
       course.version.should == version_number + 1
     end
   
     context "copied as new course" do
       it "responds to " do
         subject.should respond_to(:copy_as_new_course)
       end
   
       it "many attributes are copied except 'is_configured' and a few others!" do
         course = FactoryGirl.create(:course, :peer_evaluation_first_email => Date.today)
         new_course = course.copy_as_new_course
         new_course.save
         course.attributes.each do |key, value|
           case key
             when "is_configured"
               new_course.is_configured.should == false
             when "id"
               new_course.id.should_not == course.id
             when "curriculum_url"
               if value.nil? || value.include?("twiki")
                 new_course.curriculum_url.should be_nil
               else
!!               new_course.curriculum_url.should == value
               end
             when "updated_by_user_id"
               new_course.attributes[key].should be_nil
             when "configured_by_user_id"
               new_course.attributes[key].should be_nil
             when "created_at"
               new_course.attributes[key].should_not == value
             when "updated_at"
               new_course.attributes[key].should_not == value
             else
               new_course.attributes[key].should == value
           end
         end
       end
   
       it "also copies over the people association" do
   # Todo: fix this when user and person are the same class
   #      course = FactoryGirl.create(:course, :people => [@faculty_frank])
         course = FactoryGirl.create(:course)
         new_course = course.copy_as_new_course
         new_course.save
         new_course.faculty.should == course.faculty
       end
   
     end
   
     #context "Last offering" do
     #  it "shouldn't return a class that hasn't happened yet" do
     #    course = FactoryGirl.create(:mfse)
     #    Course.last_offering(course.number).should_not == course
     #
     #
     #  end
     #  it "should return classes last offered" do
     #    course2 = FactoryGirl.create(:fse,:semester => "Summer")
     #    Course.last_offering(course2.number).should == course2
     #    course = FactoryGirl.create(:fse)
     #
     #    Course.last_offering(course.number).should == course
     #  end
     #end
   
   
     context 'updates google mailing list' do
       before do
         @course = FactoryGirl.create(:mfse)
         @course.updating_email = false
         @count = Delayed::Job.count
       end
   
       context 'when the email name changes' do
         before do
           @course.short_name += "_NEW"
           @course.save
         end
         it 'adds an asynchronous request' do
           Delayed::Job.count.should > @count
         end
         it 'marks the state transition' do
           @course.updating_email.should == true
         end
       end
   
       context 'when the faculty change' do
         before do
           @faculty_frank = FactoryGirl.create(:faculty_frank)
           @course.faculty_assignments_override = [@faculty_frank.human_name]
           @course.save
         end
         it 'adds an asynchronous request' do
           Delayed::Job.count.should > @count
         end
         it 'marks the state transition' do
           @course.updating_email.should == true
         end
       end
   
       context 'when the registered students change' do
         #This needs to be tested in the HUB importer which manages this
       end
   
       context 'when the student teams change' do
         #Should be tested by teams spec
       end
   
       context 'but not when the curriculum url changes' do
         before do
           @course.curriculum_url = "_new_url"
           @course.save
         end
         it 'does not add an asynchronous request' do
           Delayed::Job.count.should == @count
         end
         it 'a state transition does not happen' do
           @course.updating_email.should == false
         end
       end
     end
   
     context 'nomenclature assignment or deliverable' do
       it "should display the preferred name of assignment" do
         @course_fse = FactoryGirl.create(:fse)
         @course_grading_rule = FactoryGirl.create(:grading_rule_points, :course_id=> @course_fse.id)
         @course_fse.grading_rule = @course_grading_rule
   
         @course_fse.nomenclature_assignment_or_deliverable.should eql("assignment")
       end
   
     end
   
   #these tests are the same with team
     context 'generated email address' do
       it 'should use the short name if available' do
         course = FactoryGirl.build(:mfse_fall_2011)
         course.update_email_address
         course.email.should == "fall-2011-mfse@" + GOOGLE_DOMAIN
       end
   
       it 'should convert unusual characters to ones that google can handle' do
         course = FactoryGirl.build(:mfse_fall_2011)
         course.short_name = "I & E"
         course.update_email_address
         course.email.should == "fall-2011-i-and-e@" + GOOGLE_DOMAIN
   
       end
     end
   
   
     context 'scenario: copy courses from one semester to the next year' do
   
       context 'given a semesters worth of courses' do
         before(:each) do
           @current_semester_courses = [FactoryGirl.create(:fse_current_semester),
                                        FactoryGirl.create(:mfse_current_semester)]
         end
   
         context "and there are no courses in the destination semester" do
           context 'when copying the courses in one semester to the next year' do
             before(:each) do
               Course.copy_courses_from_a_semester_to_next_year(AcademicCalendar.current_semester, Date.today.year)
             end
   
             it 'then the courses are duplicated' do
               future_courses = Course.for_semester(AcademicCalendar.current_semester, Date.today.year + 1)
               future_courses.length.should == @current_semester_courses.length
             end
           end
         end
   
         it 'should update the peer_evaluation dates, if they are present'
             #when "peer_evaluation_first_email", "peer_evaluation_second_email"
             #  if value.nil?
             #    new_course.attributes[key].should be_nil
             #  else
             #    new_course.attributes[key].should == value + 1.year
             #  end
   
         context 'and there already exists course' do
           before(:each) do
             next_year = Date.today.year + 1
             @next_year_semester_courses = [FactoryGirl.create(:fse_current_semester, :year => next_year),
                                            FactoryGirl.create(:mfse_current_semester, :year => next_year)]
           end
   
           it 'then it should not copy over the courses and throws an error' do
             lambda  {
               Course.copy_courses_from_a_semester_to_next_year(AcademicCalendar.current_semester, Date.today.year)
             }.should raise_error
   
             future_courses = Course.for_semester(AcademicCalendar.current_semester, Date.today.year + 1)
             future_courses.length.should == @next_year_semester_courses.length
             future_courses.length.should_not == @next_year_semester_courses.length + @current_semester_courses.length
           end
         end
   
       end
     end
   
     it "email_faculty_to_configure_course sends an email" do
       CourseMailer.should_receive(:configure_course_faculty_email).and_return(double(CourseMailer, :deliver => true))
       course = FactoryGirl.build(:course)
       course.email_faculty_to_configure_course_unless_already_configured
     end
   
     it "email_faculty_to_configure_course does not sends an email if course is already configured" do
       CourseMailer.should_not_receive(:configure_course_faculty_email)
       course = FactoryGirl.build(:course, :is_configured => true)
       course.email_faculty_to_configure_course_unless_already_configured
     end
   
     it "registered_students_or_on_teams should list all students in a course" do
       Course.any_instance.stub(:registered_students).and_return([
           stub_model(User, :human_name => "student 1"),
           stub_model(User, :human_name => "student 2")
       ])
       Course.any_instance.stub(:teams).and_return([
           stub_model(Team, :members => [stub_model(User, :human_name => "student 3")] )
       ])
       subject.registered_students_or_on_teams.count.should == 3
     end
   
     # Tests for has_and_belongs_to_many relationship
     it { should have_many(:faculty) }
     it { should have_many(:registered_students) }
   
   end

================================================================================
 ./spec/models/course_number_spec.rb
================================================================================
   require 'spec_helper'
   
   describe CourseNumber do
     it "needs tests"
   end

================================================================================
 ./spec/models/deliverable_model_spec.rb
================================================================================
   require 'spec_helper'
   
   describe Deliverable do
   
     it 'can be created' do
       lambda {
         FactoryGirl.create(:deliverable)
       }.should change(Deliverable, :count).by(1)
     end
   
     context "is valid" do
       before(:each) do
!!       @deliverable = FactoryGirl.build(:deliverable)
       end
     end
   
     context "is not valid" do
   
       [:course, :assignment, :creator].each do |attr|
         it "without #{attr}" do
           subject.should_not be_valid
           subject.errors[attr].should_not be_empty
         end
       end
   
       context "when a duplicate deliverable for the same course, assignment and owner" do
         [:team_deliverable, :individual_deliverable].each do |symbol|
           it "for a team/individual deliverable" do
             original = FactoryGirl.build(symbol)
             original.stub(:update_team)
             original.save
             duplicate = Deliverable.new()
             duplicate.stub(:update_team)
             duplicate.creator_id = original.creator_id
             duplicate.assignment = original.assignment
             duplicate.team_id = original.team_id
             duplicate.should_not be_valid
           end
         end
       end
     end
   
     it "should return team name for a team deliverable" do
       deliverable = FactoryGirl.build(:team_deliverable)
       deliverable.stub(:update_team)
       deliverable.save
       deliverable.owner_name.should be_equal(deliverable.team.name)
     end
   
       it "should return person name for a individual deliverable" do
       deliverable = FactoryGirl.create(:individual_deliverable)
       deliverable.owner_name.should be_equal(deliverable.creator.human_name)
     end
   
     it "should return team email for a team deliverable" do
       deliverable = FactoryGirl.build(:team_deliverable)
       deliverable.stub(:update_team)
       deliverable.save
       deliverable.owner_email.should be_equal(deliverable.team.email)
     end
   
     it "should return person email for a individual deliverable" do
       deliverable = FactoryGirl.create(:individual_deliverable)
       deliverable.owner_email.should be_equal(deliverable.creator.email)
     end
   
     context "has_feedback?" do
     it "returns false when there is no feedback" do
       subject.has_feedback?.should be_false
   
   #!(self.feedback_comment.nil? or self.feedback_comment == "") or !self.feedback_file_name.nil?
     end
   
     it "returns true when there is a comment" do
       subject.feedback_comment = "Great job team!"
       subject.has_feedback?.should be_true
     end
   
     it "returns true when there is a file" do
       subject.feedback_file_name = "/somewhere_on_s3/somewhere_over_the_rainbow/amazing_feedback.txt"
       subject.has_feedback?.should be_true
     end
   
   
     end
   
     context "for a team" do
       before(:each) do
         @deliverable = FactoryGirl.build(:team_deliverable)
         @team_member = @deliverable.team.members[0]
       end
   
       it "is not editable by any random student" do
         @deliverable.editable?(FactoryGirl.create(:student_sally, :email=>"student.sally2@sv.cmu.edu", :webiso_account =>"ss2@andrew.cmu.edu")).should be_false
       end
   
       it "is editable by staff or admin" do
         @deliverable.editable?(FactoryGirl.create(:faculty_frank)).should be_true
        end
   
       it "is editable by a team member" do
         @deliverable.editable?(@team_member).should be_true
       end
     end
   
     context "for an individual deliverable" do
       before(:each) do
         @deliverable = FactoryGirl.build(:individual_deliverable)
         @individual = @deliverable.creator
       end
   
       it "is not editable by any random student" do
         @deliverable.editable?(FactoryGirl.create(:student_sally, :email=>"student.sally2@sv.cmu.edu", :webiso_account =>"ss2@andrew.cmu.edu")).should be_false
       end
   
       it "is editable by staff or admin" do
         @deliverable.editable?(FactoryGirl.create(:faculty_frank)).should be_true
        end
   
       it "is editable by its owner" do
         @deliverable.editable?(@individual).should be_true
       end
     end
   
     context "for an individual deliverable's grading status" do
       before(:each) do
         @deliverable = FactoryGirl.build(:individual_deliverable)
       end
   
       it "is visible if the grade is published" do
         grade = FactoryGirl.build(:grade_visible)
         Grade.stub(:get_grade).with(@deliverable.course.id, @deliverable.assignment.id, @deliverable.creator.id).and_return(grade)
         @deliverable.is_visible_to_student?.should be_true
       end
   
       it "is invisible if the grade is not published" do
         grade = FactoryGirl.build(:grade_invisible)
         Grade.stub(:get_grade).with(@deliverable.course.id, @deliverable.assignment.id, @deliverable.creator.id).and_return(grade)
         @deliverable.is_visible_to_student?.should be_false
       end
   
       it "is invisible if it is not graded" do
         Grade.stub(:get_grade).with(@deliverable.course.id, @deliverable.assignment.id, @deliverable.creator.id).and_return(nil)
         @deliverable.is_visible_to_student?.should be_false
       end
   
       #it "is graded if grade is given and published" do
       #  grade = FactoryGirl.build(:grade_visible)
       #  Grade.stub(:get_grade).with(@deliverable.course.id, @deliverable.assignment.id, @deliverable.creator.id).and_return(grade)
       #  @deliverable.get_grade_status.should eq(:graded)
       #end
   
       #it "is ungraded if grade is not given" do
       #  Grade.stub(:get_grade).with(@deliverable.course.id, @deliverable.assignment.id, @deliverable.creator.id).and_return(nil)
       #  @deliverable.get_grade_status.should eq(:ungraded)
       #end
       #
       #it "is drafted if grade is given but not published" do
       #  grade = FactoryGirl.build(:grade_invisible)
       #  Grade.stub(:get_grade).with(@deliverable.course.id, @deliverable.assignment.id, @deliverable.creator.id).and_return(grade)
       #  @deliverable.get_grade_status.should eq(:drafted)
       #end
     end
   
     #context "for a team deliverable's grading status" do
     #  before(:each) do
     #    @deliverable = FactoryGirl.build(:team_deliverable)
     #  end
     #
       #it "is graded if all of members' grades are given and published" do
       #  @deliverable.team.members.each do | member |
       #    grade = FactoryGirl.build(:grade_visible, :student_id => member.id)
       #    Grade.stub(:get_grade).with(@deliverable.course.id, @deliverable.assignment.id, member.id).and_return(grade)
       #  end
       #  @deliverable.get_grade_status.should eq(:graded)
       #end
       #
       #it "is drafted if any of the member's grade is given but not published" do
       #  grade = FactoryGirl.build(:grade_invisible)
       #  @deliverable.team.members.each do | member |
       #    grade = FactoryGirl.build(:grade_invisible, :student_id => member.id)
       #    Grade.stub(:get_grade).with(@deliverable.course.id, @deliverable.assignment.id, member.id).and_return(grade)
       #  end
       #  @deliverable.get_grade_status.should eq(:drafted)
       #end
       #
       #it "is ungraded if any of the member's grade is not given" do
       #  @deliverable.team.members.each do | member |
       #    Grade.stub(:get_grade).with(@deliverable.course.id, @deliverable.assignment.id, member.id).and_return(nil)
       #  end
       #  @deliverable.get_grade_status.should eq(:ungraded)
       #end
     #end
   
     context "for a professor" do
       before (:each) do
         @faculty_frank = FactoryGirl.build(:faculty_frank_user)
         @course_fse = FactoryGirl.create(:fse, faculty: [@faculty_frank])
         @course_ise = FactoryGirl.create(:ise, faculty: [@faculty_frank])
         @student_sam = FactoryGirl.create(:student_sam)
         @student_sally = FactoryGirl.create(:student_sally)
         @team_member = FactoryGirl.create(:team_member)
       end
   
       it "Displays the professor's teams deliverables if the professor has at least one team" do
         @team_turing =  FactoryGirl.create(:team_turing, :course=>@course_fse)
         @team_test =  FactoryGirl.create(:team_test, :course=>@course_fse)
         @team_assignment = FactoryGirl.create(:team_turing_assignment, :team => @team_turing, :user => @student_sam)
   
         @assignment_team_turing_1 = FactoryGirl.create(:assignment_1,:course => @course_fse)
         @assignment_team_turing_2 = FactoryGirl.create(:assignment_1,:course => @course_fse)
         @assignment_team_test_1 = FactoryGirl.create(:assignment_1,:course => @course_fse)
   
   
         @team_turing_deliverable_1 = FactoryGirl.create(:team_turing_deliverable_1,:course => @course_fse,
                               :team => @team_turing,:assignment => @assignment_team_turing_1, :creator => @student_sam)
         @team_turing_deliverable_2 = FactoryGirl.create(:team_turing_deliverable_1,:course => @course_fse,
                               :team => @team_turing,:assignment => @assignment_team_turing_2, :creator => @student_sam)
         @team_test_deliverable_1 = FactoryGirl.create(:team_test_deliverable_1,:course => @course_fse,
                                :team => @team_test,:assignment => @assignment_team_test_1)
   
         @attachment_deliverable_1_turing =  FactoryGirl.create(:attachment_1, :deliverable => @team_turing_deliverable_1,
                                                                :submitter => @student_sam)
         @attachment_deliverable_2_turing =  FactoryGirl.create(:attachment_1, :deliverable => @team_turing_deliverable_2,
                                                                :submitter => @student_sam)
         @attachment_deliverable_1_test =  FactoryGirl.create(:attachment_1, :deliverable => @team_test_deliverable_1,
                                                              :submitter => @student_sam)
   
         @options = {:is_my_team => 1}
   
         @expected_deliverables = Deliverable.get_deliverables(@course_fse.id, @faculty_frank.id, @options)
         @expected_deliverables.should have(2).items
   
         @expected_deliverables[1].should == @team_turing_deliverable_2
         @expected_deliverables[0].should == @team_turing_deliverable_1
   
       end
   
       it "Displays the professor's students individual deliverables if the professor has at least one team" do
         @team_turing =  FactoryGirl.create(:team_turing, :course=>@course_fse)
         @team_test =  FactoryGirl.create(:team_test, :course=>@course_fse)
   
         #Assigning the student to the team
         @team_turing_assignment = FactoryGirl.create(:team_turing_assignment, :team => @team_turing,
                                                      :user => @student_sam)
         @team_test_assignment = FactoryGirl.create(:team_test_assignment, :team => @team_test, :user => @student_sally)
   
         @assignment_team_turing_1 = FactoryGirl.create(:assignment_3,:course => @course_fse)
         @assignment_team_turing_2 = FactoryGirl.create(:assignment_3,:course => @course_fse)
   
         @turing_individual_deliverable_1 = FactoryGirl.create(:turing_individual_deliverable,:course => @course_fse,
                                 :assignment => @assignment_team_turing_1, :creator => @student_sam)
         @turing_individual_deliverable_2 = FactoryGirl.create(:test_individual_deliverable,:course => @course_fse,
                                 :assignment => @assignment_team_turing_2, :creator => @student_sally)
   
         @attachment_deliverable_1_turing =  FactoryGirl.create(:attachment_1, :deliverable =>
                                 @turing_individual_deliverable_1, :submitter => @student_sam)
         @attachment_deliverable_2_turing =  FactoryGirl.create(:attachment_1, :deliverable =>
                                 @turing_individual_deliverable_2, :submitter => @student_sally)
   
         @options = {:is_my_team => 1}
   
         @expected_deliverables = Deliverable.get_deliverables(@course_fse.id, @faculty_frank.id, @options)
         @expected_deliverables.should have(1).items
   
         @expected_deliverables[0].should == @turing_individual_deliverable_1
       end
   
       it "If a course has teams, display team deliverables as well as individual deliverables for students in the
           faculty's team" do
   
         @team_turing =  FactoryGirl.create(:team_turing, :course => @course_fse)
         @team_test =  FactoryGirl.create(:team_test, :course => @course_fse)
   
         @team_assignment = FactoryGirl.create(:team_turing_assignment, :team => @team_turing, :user => @student_sam)
         @team_assignment = FactoryGirl.create(:team_test_assignment, :team => @team_test, :user => @student_sally)
   
         @assignment1 = FactoryGirl.create(:assignment_3,:course => @course_fse)
         @assignment2 = FactoryGirl.create(:assignment_3,:course => @course_fse)
   
         # Team deliverable
         @deliverable1 = FactoryGirl.create(:team_turing_deliverable_1,:course => @course_fse, :team => @team_turing,:assignment => @assignment1, :creator => @student_sam)
         # Individual deliverable 1
         @deliverable2 = FactoryGirl.create(:turing_individual_deliverable,:course => @course_fse, :assignment => @assignment1, :creator => @student_sam)
         # Individual deliverable 2
         @deliverable3 = FactoryGirl.create(:test_individual_deliverable,:course => @course_fse, :assignment => @assignment2, :creator => @student_sally)
   
         @dav1 =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable1, :submitter => @student_sam)
         @dav2 =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable2, :submitter => @student_sam)
         @dav3 =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable3, :submitter => @student_sally)
   
         @options = {:is_my_team => 1}
         @deliverables = Deliverable.get_deliverables(@course_fse.id, @faculty_frank.id, @options)
         @deliverables.should have(2).items
   
         @deliverables[0].should == @deliverable1
         @deliverables[1].should == @deliverable2
   
       end
   
       it "Displays all deliverables if the course does not have teams" do
   
         @deliverable1 = FactoryGirl.create(:turing_individual_deliverable, :course=>@course_fse)
         #@deliverable2 = FactoryGirl.create(:individual_deliverable, :course=>@course_ise)
         @dav3 =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable1, :submitter => @student_sam)
   
         @options = {:is_my_team => 1}
         @deliverables = Deliverable.get_deliverables(@course_fse.id, @faculty_frank.id, @options)
         @deliverables.should have(1).items
         @deliverables[0].should == @deliverable1
   
       end
   
       it "If a course has teams and user enter search terms, display team deliverables as well as individual deliverables
           for students in the faculty's team" do
   
         @team_turing =  FactoryGirl.create(:team_turing, :course => @course_fse)
         @team_test =  FactoryGirl.create(:team_test, :course => @course_fse)
         @team_ruby_racer =  FactoryGirl.create(:team_ruby_racer, :course => @course_fse)
   
         @team_assignment = FactoryGirl.create(:team_turing_assignment, :team => @team_turing, :user => @student_sam)
         @team_assignment = FactoryGirl.create(:team_test_assignment, :team => @team_test, :user => @student_sally)
         @team_assignment = FactoryGirl.create(:team_ruby_racer_assignment, :team => @team_ruby_racer, :user => @team_member)
   
         @assignment1 = FactoryGirl.create(:assignment_3,:course => @course_fse)
         @assignment2 = FactoryGirl.create(:assignment_3,:course => @course_fse)
   
         # Team deliverable
         @deliverable1 = FactoryGirl.create(:team_turing_deliverable_1,:course => @course_fse, :team => @team_turing,:assignment => @assignment1, :creator => @student_sam)
         # Individual deliverable 1
         @deliverable2 = FactoryGirl.create(:turing_individual_deliverable,:course => @course_fse, :assignment => @assignment1, :creator => @student_sam)
         # Individual deliverable 2
         @deliverable3 = FactoryGirl.create(:test_individual_deliverable,:course => @course_fse, :assignment => @assignment2, :creator => @student_sally)
         # Team deliverable of team Ruby Racer
         @deliverable4 = FactoryGirl.create(:team_ruby_racer_deliverable_1,:course => @course_fse, :team => @team_ruby_racer,:assignment => @assignment1, :creator => @team_member)
         # Individual deliverable 3
         @deliverable5 = FactoryGirl.create(:test_individual_deliverable,:course => @course_fse, :assignment => @assignment2, :creator => @team_member)
   
         @dav1 =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable1, :submitter => @student_sam)
         @dav2 =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable2, :submitter => @student_sam)
         @dav3 =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable3, :submitter => @student_sally)
         @dav4 =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable4, :submitter => @team_member)
         @dav5 =  FactoryGirl.create(:attachment_1, :deliverable => @deliverable5, :submitter => @team_member)
   
         @options = {:is_my_team => 1, :search_string => "Member"}
         @deliverables = Deliverable.get_deliverables(@course_fse.id, @faculty_frank.id, @options)
         @deliverables.should have(2).items
   
         @deliverables[0].should == @deliverable4
         @deliverables[1].should == @deliverable5
   
       end
   
     end
   
     context " for a individual deliverable last graded by"   do
       before (:each) do
         @faculty_frank = FactoryGirl.create(:faculty_frank_user)
         @course_fse = FactoryGirl.create(:fse, faculty: [@faculty_frank])
         @student_sam = FactoryGirl.create(:student_sam)
         @assignment = FactoryGirl.create(:assignment_3,:course => @course_fse)
         @deliverable = FactoryGirl.create(:turing_individual_deliverable, :course => @course_fse, :assignment => @assignment, :creator => @student_sam)
   
         @grade = FactoryGirl.create(:last_graded_visible,:course_id => @course_fse.id,:assignment_id => @assignment.id,:student_id => @student_sam.id)
       end
   
   
       it " should get last graded by"  do
         # Get last graded by
         Grade.stub(:get_graded_by).with(@deliverable.course.id, @deliverable.assignment.id, @deliverable.creator.id).and_return(@grade)
         @deliverable.get_graded_by.should eq(@faculty_frank)
       end
   
   
     end
     context " for a team deliverable last graded by"   do
       before (:each) do
         @faculty_frank = FactoryGirl.create(:faculty_frank_user)
         @course_fse = FactoryGirl.create(:fse, faculty: [@faculty_frank])
   
         @assignment = FactoryGirl.create(:assignment_3,:course => @course_fse)
         #@deliverable = FactoryGirl.create(:turing_individual_deliverable, :course=>@course_fse, :assignment => @assignment, :creator => @student_sam)
         @deliverable = FactoryGirl.build(:team_deliverable,:course_id => @course_fse.id)
       end
   
   
       it " should get last graded by"  do
         # Get last graded by
         @grade = FactoryGirl.create(:grade_invisible, :course_id => @deliverable.course.id, :assignment_id => @deliverable.assignment.id, :last_graded_by => @faculty_frank.id, :student_id =>@deliverable.team.members[0].id)
         Grade.stub(:get_graded_by).with(@deliverable.course.id, @deliverable.assignment.id, @deliverable.team.members[0].id).and_return(@grade)
         @deliverable.get_graded_by.should eq(@faculty_frank)
       end
   
   
     end
   
   end
   
   

================================================================================
 ./spec/models/effort_log_line_item_spec.rb
================================================================================
   require 'spec_helper'
   
   describe EffortLogLineItem do
   
     it 'can be created' do
       lambda {
         FactoryGirl.create(:effort_log_line_item)
         }.should change(EffortLogLineItem, :count).by(1)
       end
   
   
       context "is not valid" do    
         [:day1, :day2, :day3, :day4, :day5, :day6, :day7].each do |attr|
           it "when #{attr} is non-numerical" do
             effort_log_line_item = FactoryGirl.build(:effort_log_line_item, attr => "test")
             effort_log_line_item.should_not be_valid
           end
         end
   
         [:day1, :day2, :day3, :day4, :day5, :day6, :day7].each do |attr|
           it "when #{attr} is a negative number" do
             effort_log_line_item = FactoryGirl.build(:effort_log_line_item, attr => -1)
             effort_log_line_item.should_not be_valid
           end
         end
       end
   
       context "associations --" do
         [:effort_log, :task_type, :course].each do |attr|
           it "belongs to a/an #{attr}" do
             subject.should respond_to(attr)
           end
         end
       end
   
       context "are ordered" do
         it "should be returned in the same order as inserted" do
           effort_log = FactoryGirl.create(:effort1)
           for i in 0..5
             FactoryGirl.create(:elli_line1, :task_type_id => i, :effort_log => effort_log)
           end
           
           i = 0
           effort_log.effort_log_line_items.each do |line|
!!           line.task_type_id.should == i
!!           i = i + 1
           end
         end
       end
   
     end

================================================================================
 ./spec/models/effort_log_model_spec.rb
================================================================================
   require 'spec_helper'
   
   describe EffortLog do
   
     context 'log_effort_week?' do
       it 'should respond to log_effort_week?' do
         EffortLog.should respond_to :log_effort_week?
       end
   
       it 'it is spring break' do
         EffortLog.log_effort_week?(2010, 9).should == false
         EffortLog.log_effort_week?(2010, 10).should == false
       end
   
       it 'it is not spring break' do
         (1..8).each do |week_number|
           EffortLog.log_effort_week?(2010, week_number).should == AcademicCalendar.week_during_semester?(2010, week_number)
         end
         (11..52).each do |week_number|
           EffortLog.log_effort_week?(2010, week_number).should == AcademicCalendar.week_during_semester?(2010, week_number)
         end
       end
     end
   
     context "is not valid" do
       [:user, :week_number, :year].each do |attr|
         it "without #{attr}" do
           subject.should_not be_valid
           subject.errors[attr].should_not be_empty
         end
       end    
     end
   
     #context "has_permission_to_edit" do
     #  before(:each) do
     #    @effort = FactoryGirl.create(:effort_log)
     #  end
     #
     #  #it "for effort log owner" do
     #  #  @effort.editable_by(@effort.user).should be_true
     #  #end
     #
     #  it "for admin who is not effort owner" do
     #    admin_andy = FactoryGirl.create(:admin_andy)
     #    @effort.user.should_not be_equal(admin_andy)
     #    @effort.editable_by(admin_andy).should be_true
     #  end
     #
     #  it "not for non admin and non effort log owner" do
     #    faculty_frank = FactoryGirl.create(:faculty_frank)
     #    @effort.user.should_not be_equal(faculty_frank)
     #    @effort.editable_by(faculty_frank).should be_false
     #  end
     #end
   
     context "has_permission_to_edit_period" do
       before(:each) do
         @effort = FactoryGirl.create(:effort_log)
       end
   
       context "within time period" do
         it "for admin who is not effort owner" do
           admin_andy = FactoryGirl.create(:admin_andy)
           @effort.user.should_not be_equal(admin_andy)
           @effort.editable_by(admin_andy).should be_true
         end
   
         it "for effort log owner" do
   
           @effort.editable_by(@effort.user).should be_true
         end
   
         it "not for non admin and non effort log owner" do
           faculty_frank = FactoryGirl.create(:faculty_frank)
           @effort.user.should_not be_equal(faculty_frank)
           @effort.editable_by(faculty_frank).should be_false
         end
       end
   
       context "outside of time period" do
         before(:each) do
           tenDaysAgo = Date.today-10
           @effort.year = tenDaysAgo.year
           @effort.week_number = tenDaysAgo.cweek
         end
   
         it "for admin who is not effort owner" do
           admin_andy = FactoryGirl.create(:admin_andy)
           @effort.user.should_not be_equal(admin_andy)
           @effort.editable_by(admin_andy).should be_true
         end
   
         it "for effort log owner" do
           @effort.editable_by(@effort.user).should be_false
         end
   
         it "not for non admin and non effort log owner" do
           faculty_frank = FactoryGirl.create(:faculty_frank)
           @effort.user.should_not be_equal(faculty_frank)
           @effort.editable_by(faculty_frank).should be_false
         end
       end
     end
   
     context "validate_effort_against_registered_courses where user" do
       before(:each) do
!!       @effort_log_line_item = FactoryGirl.create(:elli_line1)
!!       @effort = FactoryGirl.create(:effort_log, :effort_log_line_items => [@effort_log_line_item])
       end
   
       it "is signed up for the course" #do
   #      user = @effort.user
   #      courses = [@effort_log_line_item.course]
   #      user.should_receive(:get_registered_courses).and_return(courses)
   #
   #      error_message = @effort.validate_effort_against_registered_courses
   #      puts error_message
   #      error_message.should == "" #no error
   #    end
   
       it "is not signed up for the course" #do
   #      user = @effort.user
   #      courses = []
   #      user.should_receive(:get_registered_courses).and_return(courses)
   #
   #      error_message = @effort.validate_effort_against_registered_courses
   #      error_message.should == @effort_log_line_item.course.name
   #    end
       
     end
   
   	describe '.users_with_effort_against_unregistered_courses' do
       before do
         @effort = FactoryGirl.create(:effort_log, :effort_log_line_items => [FactoryGirl.create(:elli_line1)])
       end
   
       context 'with courses in error' do
         before do
           EffortLog.any_instance.stub(:validate_effort_against_registered_courses).and_return("No course selected")
         end
         it 'returns the errors for each user' do
           EffortLog.users_with_effort_against_unregistered_courses.should == {@effort.user => "No course selected"}
         end
       end
   
       context 'with no courses in error' do
         before do
           EffortLog.any_instance.stub(:validate_effort_against_registered_courses).and_return("")
         end
         it 'returns nothing' do
           EffortLog.users_with_effort_against_unregistered_courses.should == {}
         end
       end
     end
   
     describe '#determine_total_effort' do
       before do
         @effort = FactoryGirl.create(:effort_log, :effort_log_line_items => [FactoryGirl.create(:elli_line1, :day6 => 10)])
         @effort.determine_total_effort
       end
       it 'sets the total effort sum' do
         @effort.sum.should == 34
       end
     end
   
     
   end

================================================================================
 ./spec/models/google_apps_api_spec.rb
================================================================================
   require 'spec_helper'
   
   describe Person do
   
     #This test methods in the google_apps.rb file. These are global methods used sparingly through the code
     #Google has a limitation that requires authentication to be done using west accounts
     #In most of the code, we refer to email address as the sv account, however, in a few spaces
     #we need to use the west account when we are about to use the google api
     #
     #since these are global methods we test them here. It is tempting to put switch_sv_to_west on the person
     #object, but we really don't want the code base to know about this distinction.
     #
     #Another approach might be to do a mixin on google_api and override the api's method and do the replacement
     #as the method is being called. 
     it 'should convert sv email address to west' do
        switch_sv_to_west("andrew.carnegie@sv.cmu.edu").should == "andrew.carnegie@west.cmu.edu"
        switch_sv_to_west("andrew.carnegie@west.cmu.edu").should == "andrew.carnegie@west.cmu.edu"
        switch_sv_to_west("andrew.carnegie@sandbox.sv.cmu.edu").should == "andrew.carnegie@sandbox.sv.cmu.edu"
        switch_sv_to_west("andrew.carnegie@andrew.cmu.edu").should == "andrew.carnegie@andrew.cmu.edu"
        switch_sv_to_west("randomness").should == "randomness"
        switch_sv_to_west("").should == ""
        switch_sv_to_west(nil).should == nil
     end
   
     it 'should convert west email address to sv' do
        switch_west_to_sv("andrew.carnegie@sv.cmu.edu").should == "andrew.carnegie@sv.cmu.edu"
        switch_west_to_sv("andrew.carnegie@west.cmu.edu").should == "andrew.carnegie@sv.cmu.edu"
        switch_west_to_sv("andrew.carnegie@andrew.cmu.edu").should == "andrew.carnegie@andrew.cmu.edu"
        switch_west_to_sv("andrew.carnegie@sandbox.sv.cmu.edu").should == "andrew.carnegie@sandbox.sv.cmu.edu"
        switch_west_to_sv("randomness").should == "randomness"
        switch_west_to_sv("").should == ""
        switch_west_to_sv(nil).should == nil    
       
     end
   
   end

================================================================================
 ./spec/models/grade_spec.rb
================================================================================
   require 'spec_helper'
   
   describe Grade do
     before(:each) do
       @student_sam = FactoryGirl.create(:student_sam_user)
       @course_fse = FactoryGirl.create(:course_fse_with_students, registered_students: [@student_sam])
       @course_grading_rule = FactoryGirl.create(:grading_rule_points, :course_id => @course_fse.id)
       @course_fse.grading_rule = @course_grading_rule
       @course_grading_rule.save
   
       Course.any_instance.stub(:registered_students_or_on_teams).and_return([@student_sam])
   
       @assignment_1 = FactoryGirl.create(:assignment_fse)
       @course_fse.assignments << @assignment_1
   
       @assignment_2 = FactoryGirl.create(:assignment)
       @course_fse.assignments << @assignment_2
   
       @grade = Grade.create(:course_id => @course_fse.id, 
                                      :student_id => @student_sam.id, 
                                      :assignment_id => @assignment_1.id,
                                      :score => "0")
       User.stub(:find).with(@student_sam.id).and_return(@student_sam)
       @course_fse.grading_rule.stub(:validate_score).and_return(true)
     end
   
     after(:each) do
       @student_sam.delete
       @course_fse.delete
       @assignment_1.delete
       @assignment_2.delete
       @grade.delete
     end
   
     subject { @grade }
   
     context "Grade" do
       it { should belong_to(:course)}
       it { should belong_to(:student)}
       it { should belong_to(:assignment)}
     end
     
     context "course_id" do
       its (:course_id) { should == @course_fse.id }
       
       it "should not be nil" do
         subject.course_id = nil
         subject.should_not be_valid
       end
   
       it "should not be blank" do
         subject.course_id = ""
         subject.should_not be_valid
       end
     end
     
     context "student_id" do
       its (:student_id) {should == @student_sam.id}
   
       it "should not be nil" do
         subject.student_id = nil
         subject.should_not be_valid
       end
   
       it "should not be blank" do
         subject.student_id = ""
         subject.should_not be_valid
       end
     end
   
     context "assignment_id" do
       its (:assignment_id) {should == @assignment_1.id}
       
       it "should not be nil" do
         subject.assignment_id = nil
         subject.should_not be_valid
       end
   
       it "should not be blank" do
         subject.assignment_id = ""
         subject.should_not be_valid
       end
     end
   
     context "assignment grades" do
       it 'should not be redundant' do
         redundant_grade = Grade.new(
           :course_id => @course_fse.id,
           :student_id => @student_sam.id,
           :assignment_id => @assignment_1.id,
           :score => "0")
         redundant_grade.should_not be_valid
       end
   
       it 'should be able to fetch one student\'s grades' do
         all_grades = Grade.get_grades_for_student_per_course(@course_fse, @student_sam)
         subject.should eql(all_grades[@assignment_1.id])
       end
   
       it 'should be able to fetch one student\'s grade earned from one assignment' do
         @grade.save
         score_value = {:course_id=>@course_fse.id, :student_id=>@student_sam.id, :assignment_id=>@assignment_1.id}
         one_grade = Grade.get_grade(@course_fse.id, @assignment_1.id, @student_sam.id)
         @grade.eql?(one_grade)
       end
   
       it "should be able to give new grade to a registered student" do
         score = "10"
         Grade.give_grade(@course_fse.id, @assignment_2.id, @student_sam.id, score).should be_true
         Grade.find_by_assignment_id_and_student_id(@assignment_2.id,@student_sam.id).score.should eq(score)
       end
   
       it "should be able to give a updated grade to a registered student" do
         score = "10"
         Grade.give_grade(@course_fse.id, @assignment_1.id, @student_sam.id, score).should be_true
         Grade.find_by_assignment_id_and_student_id(@assignment_1.id, @student_sam.id).score.should eq(score)
       end
   
       it "should not give grade to an unregistered student" do
         score = "10"
         student_sally = FactoryGirl.create(:student_sally_user)
         User.stub(:find).with(student_sally.id).and_return(student_sally)
         Grade.give_grade(@course_fse.id, @assignment_1.id, student_sally.id, score).should be_false
       end
   
       it "should be able to update multiple grades" do
         grades = []
         [@assignment_1, @assignment_2].each do |assignment|
           grades << {:course_id=>@course_fse.id, :assignment_id => assignment.id, :student_id=>@student_sam.id, :score => "10" }
         end
         Grade.give_grades(grades)
         grades.each do |grade_entry|
           Grade.find_by_assignment_id_and_student_id(grade_entry[:assignment_id], grade_entry[:student_id]).score.should eq(grade_entry[:score])
         end
       end
     end
   
     context "final grade" do
       it "should be able to find final grades if they are given and are student visible" do
         final_grade = "A"
         Grade.give_grade(@course_fse.id, -1, @student_sam.id, final_grade, true)
         Grade.get_final_grade(@course_fse.id, @student_sam.id).should eql(final_grade)
       end
   
       it "should be not able to find final grades if they are given and are student invisible" do
         final_grade = "A"
         Grade.give_grade(@course_fse.id, -1, @student_sam.id, final_grade, false)
         Grade.get_final_grade(@course_fse.id, @student_sam.id).should eql("")
       end
   
       it "should be able to give final grades" do
         score = "A"
         Grade.give_grade(@course_fse.id, -1, @student_sam.id, score).should be_true
       end
   
       it "when given and are student visible, should not update other course grades" do
         Course.any_instance.stub(:update_distribution_list).and_return(true)
         @course_ise = FactoryGirl.create(:course_ise_with_students, registered_students: [@student_sam])
         @ise_grading_rule = FactoryGirl.build_stubbed(:grading_rule_points, :course_id => @course_ise.id)
         @course_ise.grading_rule.stub(:validate_score).and_return(true)
   
         fse_final_grade = "B+"
         ise_final_grade = "A-"
         Grade.give_grade(@course_fse.id, -1, @student_sam.id, fse_final_grade, true).should be_true
         Grade.give_grade(@course_ise.id, -1, @student_sam.id, ise_final_grade, true).should be_true
         Grade.get_final_grade(@course_fse.id, @student_sam.id).should eql(fse_final_grade)
         Grade.get_final_grade(@course_ise.id, @student_sam.id).should eql(ise_final_grade)
   
       end
   
     end
   
     # Beg Add Turing Ira
   
     context " It should save last graded by while giving grades" do
   
       it "should be able to give a updated grade to a registered student" do
         faculty_frank = FactoryGirl.build(:faculty_frank_user)
         faculty = faculty_frank.id
         score = "10"
   
         Grade.give_grade(@course_fse.id, @assignment_1.id, @student_sam.id, score,nil,faculty).should be_true
         Grade.find_by_assignment_id_and_student_id(@assignment_1.id, @student_sam.id).last_graded_by.should eq(faculty)
       end
   
       it "should not update faculty in last graded by when last graded by is not empty" do
         faculty_frank = FactoryGirl.build(:faculty_frank_user)
         faculty_fagan = FactoryGirl.build(:faculty_fagan_user)
         faculty = faculty_frank.id
         score = "10"
         score1 = "7"
   
         Grade.give_grade(@course_fse.id, @assignment_1.id, @student_sam.id, score,nil,faculty).should be_true
         Grade.give_grade(@course_fse.id, @assignment_1.id, @student_sam.id, score1,nil,faculty_fagan.id).should be_true
   
         Grade.find_by_assignment_id_and_student_id(@assignment_1.id, @student_sam.id).last_graded_by.should eq(faculty)
       end
   
       it "should be able to update multiple grades with last graded by in grade book" do
         faculty_frank = FactoryGirl.build(:faculty_frank_user)
         faculty = faculty_frank.id
         grades = []
   
         [@assignment_1, @assignment_2].each do |assignment|
           grades << {:course_id=>@course_fse.id, :assignment_id => assignment.id, :student_id=>@student_sam.id, :score => "10" }
         end
   
         Grade.give_grades(grades,faculty)
         grades.each do |grade_entry|
           Grade.find_by_assignment_id_and_student_id(grade_entry[:assignment_id], grade_entry[:student_id]).last_graded_by.should eq(faculty)
         end
       end
   
     end
   
   # End Add Turing Ira
   end

================================================================================
 ./spec/models/grading_rule_spec.rb
================================================================================
   require 'spec_helper'
   
   describe GradingRule do
     before do
       @course_fse = FactoryGirl.create(:fse)
     end
   
     context "using points" do
       before do
         @course_grading_rule = FactoryGirl.create(:grading_rule_points, :course_id=> @course_fse.id)
         @course_fse.grading_rule = @course_grading_rule
         @assignment = FactoryGirl.create(:assignment_fse)
         @course_fse.assignments << @assignment
       end
   
       it "should be able to validate scores format" do
         @course_grading_rule.validate_score("2.0").should be_true
       end
   
       it "should validate letter grades" do
         @course_grading_rule.validate_letter_grade("A")
       end
   
       it "should maintain the hash " do
         letter_grades = ["A", "R", "W", "I", "A-", "B+", "B", "B-", "C+", "C", "C-"]
         @course_grading_rule.letter_grades.should eql(letter_grades)
       end
   
       it "should be able to tell the users about the grade type" do
         GradingRule.get_grade_type(@course_fse.id).should eql("points")
       end
     end
   
     context "using weights" do
       before do
         @course_grading_rule = FactoryGirl.create(:grading_rule_weights, :course_id=> @course_fse.id)
         @course_fse.grading_rule = @course_grading_rule
       end
   
       it "should be able to validate scores format" do
         @course_grading_rule.validate_score("20").should be_true
         @course_grading_rule.validate_score("20%").should be_true
       end
       
       it "should be able to format scores" do
         GradingRule.format_score(@course_fse.id, "20%").should eq("20")
       end
     end
   
   end
   

================================================================================
 ./spec/models/page_attachment_model_spec.rb
================================================================================
   require 'spec_helper'
   
   describe PageAttachment do
     it { should belong_to :page }
     it { should have_attached_file :page_attachment }
     it { should belong_to :user }
   
     #context "is not valid" do
     #  [:readable_name, :user_id].each do |attr|
     #    it "without #{attr}" do
     #      subject.should_not be_valid
     #      subject.errors[attr].should_not be_empty
     #    end
     #  end
     #
     #  it "without is_active" do
     #    subject.is_active = nil
     #    subject.should_not be_valid
     #    subject.errors[:is_active].should_not be_empty
     #  end
     #end
   
     it "should be ordered" do
       
     end
   
   it "once an attachment has been created, you can't change the name of the file. All subsequent replacements of that file will have the same name"
   
   it "an attachment is versioned recording who made the change and any comments"
   
     # it "is versioned" do
     #  attachment =  FactoryGirl.create(:page_attachment)
     #  attachment.should respond_to(:version)
     #  attachment.save
     #  version_number = attachment.version
     #  attachment.readable_name = "A Nice New Name"
     #  attachment.save
     #  attachment.version.should == version_number + 1
     #end
   
   
   #view stuff
   it "there is an easy way to copy the link location of the file"
   it "there is an accordian view of the attachments"
   
   end

================================================================================
 ./spec/models/page_comment_spec.rb
================================================================================
   require 'spec_helper'
   
   describe PageComment do
   
     it "is editable"
     
     it ""
   
   end

================================================================================
 ./spec/models/page_model_spec.rb
================================================================================
   require 'spec_helper'
   
   describe Page do
   
     before(:each) do
       @page = Page.new(:title => "Syllabus",
                        :url => "url my_page",
                        :updated_by_user_id => 10,
                        :tab_one_contents => "As a student in this course, you have the opportunity to practice principled software development in the context of an authentic project using an agile method. You track your progress against a plan and manage risks along the way. You prioritize features, do pair programming and follow test-driven development. You measure code coverage and code quality. Through this course, you experience the ins and outs of software engineering.")
       @page.updated_by_user_id = 10
       Page.any_instance.stub(:update_search_index)
       Page.any_instance.stub(:delete_from_search)
     end
   
     it "is valid with valid attributes" do
       @page.should be_valid
     end
   
     it "is not valid without a title" do
       @page.title = nil
       @page.should_not be_valid
     end
   
     it "is not valid without an updated_by_user_id"  do
       @page.updated_by_user_id = nil
       @page.should_not be_valid
     end
   
     it "should allow faculty to upload attachments"
   
   
     context "can be a named url" do
       it "that is unique" do
         @page.url = "ppm"
         @page.save
   
         @msp = Page.new(:title => "Syllabus",
                         :updated_by_user_id => 10,
                         :url => "ppm")
         @msp.should_not be_valid
         @msp.errors[:url].should_not be_blank
         @msp.errors[:url].should == ["has already been taken"]
       end
   
       it "that is not a number because it would cause conflicts with the id field on lookup" do
         @page.url = "123"
         @page.should_not be_valid
         @page.errors[:url].should_not be_blank
   #      @page.errors[:url].should == "has already been taken"
         @page.url = "test123"
         @page.should be_valid
         @page.errors[:url].should be_blank
   
         @page.url = "123test123test12321"
         @page.should be_valid
         @page.errors[:url].should be_blank
       end
   
       it "that defaults from the title field" do
         @page.url = ""
         @page.should be_valid
         @page.url.should == @page.title
       end
   
       it "should able to update indentation level" do
         @page = Page.new(:title => "Syllabus",
                           :url => "url my_page",
                           :indentation_level => 10,
                           :updated_by_user_id => 10,
                           :tab_one_contents => "As a student in this course, you have the opportunity to practice principled software development in the context of an authentic project using an agile method. You track your progress against a plan and manage risks along the way.")
         @page.updated_by_user_id = 10
         @page.indentation_level = 2
         @page.should be_valid
       end
   
     end
   
   
     it "is editable by staff or admin" do
       @page.should be_editable(FactoryGirl.create(:faculty_frank))
      end
   
     it "is not editable unless they are staff or admin" do
       @page.should_not be_editable(FactoryGirl.create(:student_sam))
     end
   
     it "should allow the creator to specify editable by faculty or any authenticated user" do
       @page.should respond_to(:is_editable_by_all)
       @page.is_editable_by_all = true
       @page.should be_editable(FactoryGirl.create(:student_sam))
     end
   
     describe "is viewable" do
       it "by anyone if the permission is set to 'world'" do
         @page.should respond_to(:viewable_by)
         @page.viewable_by = "world"
         @page.should be_viewable(nil)
       end
       it "only to registered users if the permission is set to 'users'" do
         @page.should respond_to(:viewable_by)
         @page.viewable_by = "users"
         @page.should be_viewable(FactoryGirl.create(:student_sam))
       end
       it "only to staff if the permission is set to 'staff'" do
         @page.should respond_to(:viewable_by)
         @page.viewable_by = "staff"
         @page.should be_viewable(FactoryGirl.create(:faculty_frank))
       end
     end
   
     it "is versioned" do
       @page.should respond_to(:version)
       @page.save
       version_number = @page.version
       @page.title = "A Brave New Title"
       @page.save
       @page.version.should == version_number + 1
     end
   
       it "should allow faculty to comment about the changes"
   #  do
   #      login(FactoryGirl.create(:faculty_frank))
   #      @page.version_comments = "A very simple change"
   #      @page.save
   ##This seems too simple
   #  end
   
     context "can determine its task number from the title" do
       it "without a number" do
         @page.task_number.should == nil
       end
   
       it "with a number that is one digit" do
         @page.title = "Task 7: Something Wonderful"
         @page.task_number.should == "7"
       end
   
       it "with a number that is two digits" do
         @page.title = "Task 15: Something Even Better Than Before"
         @page.task_number.should == "15"
       end
   
     end
   
     it { should have_many :page_attachments }
   
   end

================================================================================
 ./spec/models/peer_evaluation_learning_objective_spec.rb
================================================================================
   require 'spec_helper'
   
   describe PeerEvaluationLearningObjective do
   
     it 'can be created' do
       lambda {
         FactoryGirl.create(:peer_evaluation_learning_objective)
       }.should change(PeerEvaluationLearningObjective, :count).by(1)
     end
   
   end

================================================================================
 ./spec/models/peer_evaluation_review_spec.rb
================================================================================
   require 'spec_helper'
   
   describe PeerEvaluationReview do
   
     it 'is_completed_for? returns true for people who have done it' do
       review = FactoryGirl.create(:peer_evaluation_review)
       PeerEvaluationReview.is_completed_for?(review.author_id, review.team.id).should be_true
     end
   
     it 'is_completed_for? returns false for people who have not done it' do
       PeerEvaluationReview.is_completed_for?(nil, nil).should be_false
     end
   
   
   end
   

================================================================================
 ./spec/models/people_search_default_spec.rb
================================================================================
   require 'spec_helper'
   
   describe PeopleSearchDefault do
   
     context "specific users can" do
   
       before do
   
         #define a set of user objects to use in tests of this context.
         @setech_student = FactoryGirl.create(:student_setech_user, :is_active => true)
         @phd_student =  FactoryGirl.create(:student_phd_user, :is_active => true)
         @director_of_student_affairs = FactoryGirl.create(:faculty_frank_user, :is_active => true)
         @phd_advisor = FactoryGirl.create(:faculty_fagan_user, :is_active => true)
         @staff = FactoryGirl.create(:contracts_manager_user, :is_active => true)
         @admin = FactoryGirl.create(:admin_andy_user, :is_active => true)
   
         #set up relationships defining default contacts for users.
         @visible_to_all_users = FactoryGirl.create(:people_search_default, :student_staff_group => "All", :user => @admin)
         @visible_to_all_students = FactoryGirl.create(:people_search_default, :student_staff_group => "Student", :program_group => "All", :user => @director_of_student_affairs)
         @visible_to_staff = FactoryGirl.create(:people_search_default, :student_staff_group => "Staff", :user => @staff)
         @visible_to_phd = FactoryGirl.create(:people_search_default, :student_staff_group => "Student", :program_group => "PhD", :user => @phd_advisor)
         @visible_to_setech = FactoryGirl.create(:people_search_default, :student_staff_group => "Student", :program_group => "SE", :track_group => "Tech", :user => @staff)
   
       end
   
       describe "when a PhD student is presented a list of default contacts" do
   
         it "then the defaults should include Admin Andy, Director of Student Affairs, and PhD Advisor" do
           search_results = PeopleSearchDefault.default_search_results(@phd_student)
           search_results = search_results.collect{ |result| result.user_id }
           search_results.should include @admin.id
           search_results.should include @director_of_student_affairs.id
           search_results.should include @phd_advisor.id
         end
   
         it "then the defaults should not include anyone else" do
           search_results = PeopleSearchDefault.default_search_results(@phd_student)
           search_results = search_results.collect{ |result| result.user_id }
           search_results.should_not include @staff.id
         end
       end
   
       describe "when a SE Tech student is presented a list of default contacts" do
   
         it "then the defaults should include Admin Andy, Director of Student Affairs, and other appropriate staff members" do
           search_results = PeopleSearchDefault.default_search_results(@setech_student)
           search_results = search_results.collect{ |result| result.user_id }
           search_results.should include @admin.id
           search_results.should include @director_of_student_affairs.id
           search_results.should include @staff.id
         end
   
         it "then the defaults should not include anyone else" do
           search_results = PeopleSearchDefault.default_search_results(@setech_student)
           search_results = search_results.collect{ |result| result.user_id }
           search_results.should_not include @phd_advisor.id
         end
   
       end
   
       describe "when a staff member is presented a list of default contacts" do
   
         it "then the defaults should include Admin Andy and other appropriate staff members" do
           search_results = PeopleSearchDefault.default_search_results(@staff)
           search_results = search_results.collect{ |result| result.user_id }
           search_results.should include @admin.id
   
           search_results = PeopleSearchDefault.default_search_results(@director_of_student_affairs)
           search_results = search_results.collect{ |result| result.user_id }
           search_results.should include @staff.id
   
         end
   
         it "then the defaults should not include anyone else" do
           search_results = PeopleSearchDefault.default_search_results(@staff)
           search_results = search_results.collect{ |result| result.user_id }
           search_results.should_not include @phd_advisor.id
         end
       end
   
       describe "when a user is presented a list of default contacts" do
         it "they should not see their own contact info" do
           search_results = PeopleSearchDefault.default_search_results(@staff)
           search_results = search_results.collect{ |result| result.user_id }
           search_results.should_not include @staff.id
         end
   
       end
   
     end
   end

================================================================================
 ./spec/models/presentation_spec.rb
================================================================================
   require 'spec_helper'
   
   describe Presentation do
     it 'can be created' do
       lambda {
         FactoryGirl.create(:presentation)
       }.should change(Presentation, :count).by(1)
     end
   
     it 'can not be created if the team or individual are both emtpy' do
       lambda {
         FactoryGirl.create(:presentation, :team_id => nil, :user_id => nil)
       }.should raise_exception 
     end
   
     it 'should return true if the team owns the presentation' do
     	pres = FactoryGirl.build(:presentation)
     	pres.is_team_presentation?.should be_true
     end
   
     it 'should return false if the team does not own the presentation' do
     	pres = FactoryGirl.build(:presentation, :team_id => 134234)
     	pres.is_team_presentation?.should be_false
     end
   
     it 'should return the team name when the team owns the presentation' do
     	pres = FactoryGirl.build(:presentation)
     	pres.presenter.should == "Team"
     end
   
     it 'should return the human name when not the presentation is not owned by a team' do
     	sam = FactoryGirl.create(:student_sam)
     	pres = FactoryGirl.create(:presentation, :team_id => nil, :user_id => sam.id)
     	pres.presenter.should == "Student Sam"
     end
   
     it 'should return true when the current user is the presenter' do
     	sam = FactoryGirl.create(:student_sam_user)
     	pres = FactoryGirl.create(:presentation, :team_id => nil, :user_id => sam.id)
     	pres.presenter?(sam).should be_true
     end
   
     it 'should return false when the current user is not the presenter and not on the team' do
     	sam = FactoryGirl.build(:student_sam_user)
     	sally = FactoryGirl.build(:student_sally_user)
     	pres = FactoryGirl.build(:presentation, :team_id => nil, :user_id => sam.id)
     	pres.presenter?(sally).should be_false
     end
   
     it 'should return true when the current user is a member of a team who is the presenter' do
     	pres = FactoryGirl.build(:presentation)
     	pres.presenter?(pres.team.members.first).should be_true
     end
   
     it 'should return false when the current user is not a member of a team who is the presenter' do
     	sam = FactoryGirl.build(:student_sam_user)
     	pres = FactoryGirl.build(:presentation)
     	pres.presenter?(sam).should be_false
     end
   
     it 'should return true when the current user has given feedback' do
     	pres_fed_ans = FactoryGirl.build(:presentation_feedback_answer)
     	pres_fed_ans.feedback.presentation.has_given_feedback?(pres_fed_ans.feedback.evaluator).should be_true
     end
   
     it 'should return false when the current user has not given feedback' do
     	sally = FactoryGirl.build(:student_sally_user)
     	pres_fed_ans = FactoryGirl.build(:presentation_feedback_answer)
     	pres_fed_ans.feedback.presentation.has_given_feedback?(sally).should be_false
     end
   
     it 'should return a list of presentations that a presenter owns' do
     	sam = FactoryGirl.create(:student_sam_user)
     	pres = FactoryGirl.create(:presentation, :team_id => nil, :user_id => sam.id)
     	Presentation.find_by_presenter(sam).length.should == 1
     end
   
     it 'should return a list of presentations for a user that is on a team that owns the presentations' do
     	pres = FactoryGirl.create(:presentation)
     	Presentation.find_by_presenter(pres.team.members.first).length.should == 1
     end
   
     it 'should return an empty object for a user that is not on a team that owns the presentations and is not the owner' do
     	sally = FactoryGirl.build(:student_sally_user)
     	pres = FactoryGirl.build(:presentation)
     	Presentation.find_by_presenter(sally).should be_empty
     end  
   
     it 'should return a list of presentations for the given user and team if they are owned by the user or team' do
     	sam = FactoryGirl.create(:student_sam_user)
     	pres = FactoryGirl.create(:presentation, :user_id => sam.id)
     	Presentation.find_by_user_and_teams(sam, [pres.team]).length.should == 1
     end
   
     it 'should return a list of presentations for the given team if the team owns a presentation and user does not' do
     	sam = FactoryGirl.create(:student_sam_user)
     	sally = FactoryGirl.create(:student_sally_user)
     	pres = FactoryGirl.create(:presentation, :user_id => sam.id)
     	Presentation.find_by_user_and_teams(sally, [pres.team]).length.should == 1
     end
   
     it 'should return an empty object  for the given user and team if they are the owners of the presentaiton' do
     	sam = FactoryGirl.build(:student_sam_user)
     	sally = FactoryGirl.build(:student_sally_user)
     	pres = FactoryGirl.build(:presentation, :user_id => sam.id)
     	Presentation.find_by_user_and_teams(sally, []).should be_empty 
     end
   
     it 'should return true for a user who can see feedback on a presentation, for which he is the presenter' do
     	sam = FactoryGirl.create(:student_sam_user)
     	pres = FactoryGirl.create(:presentation, :user_id => sam.id)
     	pres.can_view_feedback?(sam).should be_true
     end
   
     it 'should return true for a user who is an admin and can see feedback on a presentation' do
     	sam = FactoryGirl.build(:student_sam_user)
     	andy = FactoryGirl.build(:admin_andy_user)
     	pres = FactoryGirl.build(:presentation, :user_id => sam.id)
     	pres.can_view_feedback?(andy).should be_true
     end
   
     it 'should return true for a user who is a faculty member and can see feedback on a presentation' do
     	sam = FactoryGirl.build(:student_sam_user)
     	frank = FactoryGirl.build(:faculty_frank_user)
     	pres = FactoryGirl.build(:presentation, :user_id => sam.id)
     	pres.can_view_feedback?(frank).should be_true
     end
   
     it 'should return false for a user who should not see feedback on a presentation' do
     	sam = FactoryGirl.build(:student_sam_user)
     	sally = FactoryGirl.build(:student_sally_user)
     	pres = FactoryGirl.build(:presentation, :user_id => sam.id)
     	pres.can_view_feedback?(sally).should be_false
     end
   
     it 'should return the user email that is registered in the team' do
     	sam = FactoryGirl.build(:student_sam_user)
     	pres = FactoryGirl.build(:presentation, :user_id => sam.id)
       pres.user_email.should == pres.team.email
     end
   
     it 'should return the user email when there is no teams' do
     	sam = FactoryGirl.create(:student_sam_user)
     	pres = FactoryGirl.create(:presentation, :team_id => nil, :user_id => sam.id)
     	pres.user_email.should == "student.sam@sv.cmu.edu"
     end
   
     it 'should deliver an email to the subject' do
     	sam = FactoryGirl.create(:student_sam_user)
     	pres = FactoryGirl.create(:presentation, :team_id => nil, :user_id => sam.id)
     	
     	expect {
     	message_text = pres.send_presentation_feedback_email("http://example.com")
     	message_text.header.to_s.should include "From: scotty.dog@sv.cmu.edu"
     	message_text.header.to_s.should include "To: student.sam@sv.cmu.edu"
     	message_text.header.to_s.should include "Feedback for presentation Test Presentation"
     	message_text.html_part.to_s.should include "See feedback for your presentation Test Presentation for Course"
   
     	message_text.html_part.to_s.should match /<a href=\"http:\/\/example.com\">View feedback<\/a>/
   
     	}.to change { ActionMailer::Base.deliveries.count }.by(1)
     end
   
   end
   
   describe PresentationFeedback do
   	it 'can be created' do
   		lambda {
   			FactoryGirl.create(:feedback_from_sam)
   		}.should change(PresentationFeedback, :count).by(1)
   	end
   end
   
   describe PresentationQuestion do
   	it 'can be created' do
   		lambda {
   			FactoryGirl.create(:presentation_feedback_questions)
   		}.should change(PresentationQuestion, :count).by(1)
   	end
   
   	it 'should return the existing questions that are not marked as deleted' do
   		pres_fed_q1 = FactoryGirl.build(:presentation_feedback_questions, :text => "This is question 1")
   		pres_fed_q2 = FactoryGirl.build(:presentation_feedback_questions, :text => "This is question 2")
   		pres_fed_q2.deleted = true
   		pres_fed_q2.save
   		PresentationQuestion.existing_questions.should_not include pres_fed_q2
   	end
   
   	# it { should_not allow_mass_assignment_of(:deleted) }
   end
   
   describe PresentationFeedbackAnswer do
   	it 'can be created' do
   		lambda {
   			FactoryGirl.create(:presentation_feedback_answer)
   		}.should change(PresentationFeedbackAnswer, :count).by(1)
   	end
   
   	it 'can not be created without a rating' do
   		lambda {
   			FactoryGirl.create(:presentation_feedback_answer, :rating => nil)
   		}.should raise_exception
   	end	
   end

================================================================================
 ./spec/models/scotty_dog_saying_spec.rb
================================================================================
   require 'spec_helper'
   
   describe ScottyDogSaying do
   
   
     it 'can be created' do
       lambda {
         FactoryGirl.create(:scotty_dog_saying)
       }.should change(ScottyDogSaying, :count).by(1)
     end
   
    context "is not valid" do
   
       [:saying, :user_id].each do |attr|
         it "without #{attr}" do
           subject.should_not be_valid
           subject.errors[attr].should_not be_empty
         end
       end
     end
   
     context "is editable" do
       before(:each) do
         @admin_andy = FactoryGirl.create(:admin_andy)
         @faculty_frank = FactoryGirl.create(:faculty_frank)
         @student_sam = FactoryGirl.create(:student_sam)
         @saying = FactoryGirl.create(:scotty_dog_saying, :user => @student_sam)
       end
   
   
       it "by an admin" do
         @saying.should be_editable(@admin_andy)
       end
   
       it "by the author" do
         @saying.should be_editable(@student_sam)
       end
   
       it "but not by anyone else" do
         @saying.should_not be_editable(@faculty_frank)
       end
   
     end
   
   end

================================================================================
 ./spec/models/sponsored_project_allocation_spec.rb
================================================================================
   require 'spec_helper'
   require "models/archived_behavior"
   
   describe SponsoredProjectAllocation do
   
     it 'can be created' do
       lambda {
         FactoryGirl.create(:sponsored_project_allocation)
       }.should change(SponsoredProjectAllocation, :count).by(1)
     end
   
     context "is not valid" do
   
       [:user_id, :sponsored_project_id, :current_allocation].each do |attr|
         it "without #{attr}" do
           subject.should_not be_valid
           subject.errors[attr].should_not be_empty
         end
       end
   
       it "without is_archived" do
         subject.is_archived = nil
         subject.should_not be_valid
         subject.errors[:is_archived].should_not be_empty
       end
   
       it "when current_allocation is non-numerical" do
         sponsored_project_user = FactoryGirl.build(:sponsored_project_allocation, :current_allocation => "test")
         sponsored_project_user.should_not be_valid
       end
   
       it "when current_allocation is a negative number" do
         sponsored_project_user = FactoryGirl.build(:sponsored_project_allocation, :current_allocation => -1)
         sponsored_project_user.should_not be_valid
       end
   
       it "when a duplicate allocation exists for the same user to project" do
         original = FactoryGirl.create(:sponsored_project_allocation)
         duplicate = FactoryGirl.build(:sponsored_project_allocation, :user => original.user, :sponsored_project => original.sponsored_project)
         duplicate.should_not be_valid
       end
     end
   
     context "associations --" do
       it 'belongs to a sponsored project' do
         subject.should respond_to(:sponsored_project)
       end
   
       it 'belongs to a sponsored project name' do
         sponsored_project_user = FactoryGirl.create(:sponsored_project_allocation)
         sponsored_project_user.sponsored_project.name.should_not be_empty
       end
   
       it 'belongs to a user' do
         subject.should respond_to(:user)
       end
   
       it 'belongs to a user human_name' do
         sponsored_project_user = FactoryGirl.create(:sponsored_project_allocation)
         sponsored_project_user.user.human_name.should_not be_empty
       end
   
   
     end
   
   
     describe "objects" do
       before(:each) do
         @archived = FactoryGirl.create(:sponsored_project_allocation, :is_archived => true)
         @current = FactoryGirl.create(:sponsored_project_allocation, :is_archived => false, :user => @archived.user)
       end
   
       it_should_behave_like "archived objects"
     end
   
     context "creates monthly copy to sponsored project effort" do
   
       before(:each) do
         @faculty_fagan = FactoryGirl.create(:faculty_fagan)
         @faculty_frank = FactoryGirl.create(:faculty_frank)
         @project_rover = FactoryGirl.create(:sponsored_project, :name => "Rover SW")
         @project_disaster = FactoryGirl.create(:sponsored_project, :name => "Disaster Response")
         @allocation_fagan_rover = FactoryGirl.create(:sponsored_project_allocation, :user => @faculty_fagan, :current_allocation => 50, :sponsored_project => @project_rover)
         @allocation_fagan_disaster = FactoryGirl.create(:sponsored_project_allocation, :user => @faculty_fagan, :current_allocation => 50, :sponsored_project => @project_disaster)
       end
   
       it 'responds to monthly_copy_to_sponsored_project_effort' do
         SponsoredProjectAllocation.should respond_to(:monthly_copy_to_sponsored_project_effort)
       end
   
       it 'of unique allocations even if it is executed twice in the same month' do
         lambda {
           SponsoredProjectAllocation.monthly_copy_to_sponsored_project_effort
           SponsoredProjectAllocation.monthly_copy_to_sponsored_project_effort
           }.should change(SponsoredProjectEffort, :count).by(2) 
       end
   
       it 'does not copy archived allocations' do
         @project_fading_shiny_newness = FactoryGirl.create(:sponsored_project, :name => "Last Year's Hot Thing'")
         @allocation_fagan_archived = FactoryGirl.create(:sponsored_project_allocation, :user => @faculty_fagan, :current_allocation => 50, :is_archived => true, :sponsored_project => @project_fading_shiny_newness)
         lambda {
           SponsoredProjectAllocation.monthly_copy_to_sponsored_project_effort
           }.should change(SponsoredProjectEffort, :count).by(2)
       end
     end
   
     context "emails staff to confirm their effort for current month" do
   
       before do
         @faculty_frank = FactoryGirl.create(:faculty_frank_user)
         @faculty_fagan = FactoryGirl.create(:faculty_fagan_user)
   
         @allocation_frank = FactoryGirl.create(:sponsored_project_allocation, :user => @faculty_frank)
         @allocation_fagan = FactoryGirl.create(:sponsored_project_allocation, :user => @faculty_fagan)
   
         @effort_frank = FactoryGirl.create(:sponsored_project_effort, :sponsored_project_allocation => @allocation_frank)
         @effort_fagan = FactoryGirl.create(:sponsored_project_effort, :sponsored_project_allocation => @allocation_fagan)
       end
   
       specify { SponsoredProjectAllocation.should respond_to(:emails_staff_requesting_confirmation_for_allocations)}
   
       it 'should email faculty that have not confirmed, but not email faculty that have already confirmed' do
         @effort_frank.confirmed = false
         @effort_frank.save
         @effort_fagan.confirmed = true
         @effort_fagan.save
   
         mailer = double("mailer")
         mailer.stub(:deliver)
         SponsoredProjectEffortMailer.should_receive(:monthly_staff_email).with(@faculty_frank, @effort_frank.month, @effort_frank.year).and_return(mailer)
         SponsoredProjectEffortMailer.should_not_receive(:monthly_staff_email).with(@faculty_fagan, @effort_fagan.month, @effort_fagan.year)
         SponsoredProjectAllocation.emails_staff_requesting_confirmation_for_allocations
       end
   
       it 'should not email faculty who have been emailed recently' do
         @effort_frank.confirmed == false
         @effort_frank.save
         @faculty_frank.sponsored_project_effort_last_emailed = Date.today - 20
         @faculty_frank.save
   
         @effort_fagan.confirmed == false
         @effort_fagan.save
         @faculty_fagan.sponsored_project_effort_last_emailed = 1.hour.ago
         @faculty_fagan.save
   
         mailer = double("mailer")
         mailer.stub(:deliver)
         SponsoredProjectEffortMailer.should_receive(:monthly_staff_email).with(@faculty_frank, @effort_frank.month, @effort_frank.year).and_return(mailer)
         SponsoredProjectEffortMailer.should_not_receive(:monthly_staff_email).with(@faculty_fagan, @effort_fagan.month, @effort_fagan.year)
         SponsoredProjectAllocation.emails_staff_requesting_confirmation_for_allocations
       end
   
     end
   
   end

================================================================================
 ./spec/models/sponsored_project_effort_spec.rb
================================================================================
   require 'spec_helper'
   
   describe SponsoredProjectEffort do
   
     it 'can be created' do
       lambda {
         FactoryGirl.create(:sponsored_project_effort)
       }.should change(SponsoredProjectEffort, :count).by(1)
     end
   
   
     context "is not valid" do
   
       [:current_allocation, :year, :month, :sponsored_project_allocation_id, :confirmed].each do |attr|
         it "without #{attr}" do
           subject.should_not be_valid
           subject.errors[attr].should_not be_empty
         end
       end
   
       [:actual_allocation, :current_allocation, :year, :month].each do |attr|
         it "when #{attr} is non-numerical" do
           sponsored_project_effort = FactoryGirl.build(:sponsored_project_effort, attr => "test")
           sponsored_project_effort.should_not be_valid
         end
       end
   
       [:actual_allocation, :current_allocation, :year, :month].each do |attr|
         it "when #{attr} is a negative number" do
           sponsored_project_effort = FactoryGirl.build(:sponsored_project_effort, attr => -1)
           sponsored_project_effort.should_not be_valid
         end
       end
   
       it "when a duplicate effort for the same month, year and project allocation" do
         original = FactoryGirl.create(:sponsored_project_effort)
         duplicate = SponsoredProjectEffort.new()
         duplicate.month = original.month
         duplicate.year = original.year
         duplicate.sponsored_project_allocation_id = original.sponsored_project_allocation_id
         duplicate.should_not be_valid
       end
     end
   
     context "associations --" do
       it 'belongs to a sponsored project allocation' do
         subject.should respond_to(:sponsored_project_allocation)
       end
   
       it 'belongs to a sponsored project current allocation' do
         sponsored_project_people = FactoryGirl.create(:sponsored_project_allocation)
         sponsored_project_people.current_allocation.should_not be_nil
       end
     end
   
     context "with custom creators" do
       it "responds to new_from_sponsored_project_allocation" do
         SponsoredProjectEffort.should respond_to(:new_from_sponsored_project_allocation)
       end
   
       it "creates new from sponsored project allocation" do
         allocation = FactoryGirl.create(:sponsored_project_allocation)
         sponsored_project_effort = SponsoredProjectEffort.new_from_sponsored_project_allocation(allocation)
   
         sponsored_project_effort.current_allocation.should == allocation.current_allocation
         sponsored_project_effort.actual_allocation.should == allocation.current_allocation
         sponsored_project_effort.confirmed.should == false
   
         sponsored_project_effort.month.should == 1.month.ago.month
         sponsored_project_effort.year.should == 1.month.ago.year
       end
   
       it "won't create a duplicate for same month and allocation" do
         allocation = FactoryGirl.create(:sponsored_project_allocation)
         successful_sponsored_project_effort = SponsoredProjectEffort.new_from_sponsored_project_allocation(allocation)
         failed_sponsored_project_effort = SponsoredProjectEffort.new_from_sponsored_project_allocation(allocation)
   
         efforts = SponsoredProjectEffort.find_all_by_month_and_year_and_sponsored_project_allocation_id(1.month.ago.month, 1.month.ago.year, allocation.id)
         efforts.length.should == 1
       end
     end
   
     context "with named scopes" do
       before(:each) do
         @faculty_frank = FactoryGirl.create(:faculty_frank)
         @faculty_fagan = FactoryGirl.create(:faculty_fagan)
   
         @allocation_frank = FactoryGirl.create(:sponsored_project_allocation, :user => @faculty_frank)
         @allocation_fagan = FactoryGirl.create(:sponsored_project_allocation, :user => @faculty_fagan)
   
         @effort_frank = FactoryGirl.create(:sponsored_project_effort, :sponsored_project_allocation => @allocation_frank)
         @effort_fagan = FactoryGirl.create(:sponsored_project_effort, :sponsored_project_allocation => @allocation_fagan)
       end
   
       it "responds to month_under_inspection_for_a_given_user" do
         SponsoredProjectEffort.should respond_to(:month_under_inspection_for_a_given_user)
       end
   
       it "finds all effort for the current month for a given user" do
         efforts = [@effort_frank]
         SponsoredProjectEffort.month_under_inspection_for_a_given_user(@faculty_frank.id).should == efforts
       end
   
       it "responds to for_all_users_for_a_given_month" do
         SponsoredProjectEffort.should respond_to(:for_all_users_for_a_given_month)
       end
   
       it "finds all effort for the current month for all users" do
         efforts = [@effort_frank, @effort_fagan]
   
         SponsoredProjectEffort.for_all_users_for_a_given_month(@effort_frank.month, @effort_frank.year).should == efforts
       end    
     end
   
     context "emails the business manager" do
   
       specify { SponsoredProjectEffort.should respond_to(:emails_business_manager)}
   
       it "successfully" do
         @effort = FactoryGirl.create(:sponsored_project_effort)
         SponsoredProjectEffortMailer.should_receive(:deliver_changed_allocation_email_to_business_manager)
         SponsoredProjectEffort.emails_business_manager(@effort.id)
       end
   
     end
   
   
   
   end

================================================================================
 ./spec/models/sponsored_project_spec.rb
================================================================================
   require 'spec_helper'
   require "models/archived_behavior"
   
   describe SponsoredProject do
   
     it 'can be created' do
       lambda {
         FactoryGirl.create(:sponsored_project)
       }.should change(SponsoredProject, :count).by(1)
     end
   
     context "is not valid" do
   
       [:name, :sponsor_id].each do |attr|
         it "without #{attr}" do
           subject.should_not be_valid
           subject.errors[attr].should_not be_empty
         end
       end
   
       it "without is_archived" do
         subject.is_archived = nil
         subject.should_not be_valid
         subject.errors[:is_archived].should_not be_empty
       end
     end
   
     it 'name must be unique' do
       project = FactoryGirl.create(:sponsored_project)
       non_unique_project = SponsoredProject.new(:name => project.name)
       non_unique_project.should_not be_valid
     end
     
   
     context "associations --" do
       it 'belongs to sponsor' do
         subject.should respond_to(:sponsor)
       end
   
       it 'belongs to a sponsor name' do
         project = FactoryGirl.create(:sponsored_project)
         project.save
         project.sponsor.name.should_not be_empty
       end
     end
   
     describe "objects" do
       before(:each) do
         @archived = FactoryGirl.create(:sponsored_project, :is_archived => true)
         @current = FactoryGirl.create(:sponsored_project, :is_archived => false)
       end
   
       it_should_behave_like "archived objects"
     end
   end

================================================================================
 ./spec/models/sponsored_project_sponsor_spec.rb
================================================================================
   require "spec_helper"
   require "models/archived_behavior"
   
   describe SponsoredProjectSponsor do
   
     it 'can be created' do
       lambda {
         FactoryGirl.create(:sponsored_project_sponsor)
       }.should change(SponsoredProjectSponsor, :count).by(1)
     end
   
     context "is not valid" do
   
       [:name].each do |attr|
         it "without #{attr}" do
           subject.should_not be_valid
           subject.errors[attr].should_not be_empty
         end
       end
   
       it "without is_archived" do
         subject.is_archived = nil
         subject.should_not be_valid
         subject.errors[:is_archived].should_not be_empty
       end
     end
   
     it 'name must be unique' do
       sponsor = FactoryGirl.create(:sponsored_project_sponsor)
       non_unique_project = SponsoredProjectSponsor.new(:name => sponsor.name)
       non_unique_project.should_not be_valid
     end
   
   
     describe "objects" do
       before(:each) do
          @archived =  FactoryGirl.create(:sponsored_project_sponsor, :is_archived => true)
          @current =  FactoryGirl.create(:sponsored_project_sponsor, :is_archived => false)
       end
   
       it_should_behave_like "archived objects"
     end  
   
   
   end

================================================================================
 ./spec/models/suggestion_spec.rb
================================================================================
   require 'spec_helper'
   
   describe Suggestion do
   
     it 'can be created' do
       lambda {
         FactoryGirl.create(:suggestion)
       }.should change(Suggestion, :count).by(1)
     end
   
    context "is not valid" do
   
       [:comment].each do |attr|
         it "without #{attr}" do
           subject.should_not be_valid
           subject.errors[attr].should_not be_empty
         end
       end
     end
   
     context "is editable" do
       before(:each) do
         @admin_andy = FactoryGirl.create(:admin_andy)
         @faculty_frank = FactoryGirl.create(:faculty_frank)
         @student_sam = FactoryGirl.create(:student_sam)
         @saying = FactoryGirl.create(:suggestion, :user => @student_sam)
       end
   
   
       it "by an admin" do
         @saying.should be_editable(@admin_andy)
       end
   
       it "by the author" do
         @saying.should be_editable(@student_sam)
       end
   
       it "but not by anyone else" do
         @saying.should_not be_editable(@faculty_frank)
       end
   
     end
   
   end

================================================================================
 ./spec/models/team_model_spec.rb
================================================================================
   require 'spec_helper'
   
   describe Team do
   
     context 'updates google mailing list' do
       before do
         @team = FactoryGirl.create(:team_triumphant)
         @team.updating_email = false
         @count = Delayed::Job.count
       end
   
       context 'when the team name changes' do
         before do
           @team.name = "Team Awesome"
           @team.save
         end
         it 'adds an asynchronous request' do
           Delayed::Job.count.should > @count
         end
         it 'marks the state transition' do
           @team.updating_email.should == true
         end
         it 'updates the course mailing list' do
           @team.course.updating_email.should == true
         end
       end
   
       context 'when the members changes' do
         before do
           @student = FactoryGirl.create(:student_sally)
           @team.members_override = [@student.human_name]
           @team.save
         end
         it 'adds an asynchronous request' do
           Delayed::Job.count.should > @count
         end
         it 'marks the state transition' do
           @team.updating_email.should == true
         end
         it 'updates the course mailing list' do
           @team.course.updating_email.should == true
         end
       end
   
       context 'but not when the faculty changes' do
         before do
           @team.primary_faculty_id = 1
           @team.save
         end
         it 'does not add an asynchronous request' do
           Delayed::Job.count.should == @count
         end
         it 'a state transition does not happen' do
           @team.updating_email.should == false
         end
       end
     end
   
   
   
   
     it 'can be created' do
       lambda {
         FactoryGirl.create(:team)
       }.should change(Team, :count).by(1)
     end
   
     context "has peer evaluation date" do
       it "first email that is copied from the course's peer evaluation first email date if it exists" do
         course = FactoryGirl.create(:course, :peer_evaluation_first_email => Date.today)
         team = FactoryGirl.create(:team, :course_id => course.id)
   
         team.peer_evaluation_first_email.to_date.should == course.peer_evaluation_first_email
       end
   
       it "first email that is not overwritten if the faculty has already specified a peer evaluation date" do
         course = FactoryGirl.create(:course, :peer_evaluation_first_email => Date.today)
         team = FactoryGirl.create(:team, :course_id => course.id, :peer_evaluation_first_email => 4.hours.from_now)
         course.peer_evaluation_first_email = 1.day.ago
         team.save
         team.peer_evaluation_first_email == 4.hours.from_now
       end
   
       it "second email that is copied from the course's peer evaluation second email date if it exists" do
         course = FactoryGirl.create(:course, :peer_evaluation_second_email => Date.today)
         team = FactoryGirl.create(:team, :course_id => course.id)
   
         team.peer_evaluation_second_email.to_date.should == course.peer_evaluation_second_email
       end
   
       it "second email that is not overwritten if the faculty has already specified a peer evaluation date" do
         course = FactoryGirl.create(:course, :peer_evaluation_second_email => Date.today)
         team = FactoryGirl.create(:team, :course_id => course.id, :peer_evaluation_second_email => 4.hours.from_now)
         course.peer_evaluation_second_email = 1.day.ago
         team.save
         team.peer_evaluation_second_email == 4.hours.from_now
       end
   
   
     end
   
     #When modifying this test, please examine the same for course
     context "when adding users to a team by providing their names as strings" do
       before(:each) do
          @team = FactoryGirl.build(:team)
          @student_sam = FactoryGirl.build(:student_sam_user, :id => rand(100))
          @student_sally = FactoryGirl.build(:student_sally_user, :id => rand(100) + 100)
          User.stub(:find_by_human_name).with(@student_sam .human_name).and_return(@student_sam )
          User.stub(:find_by_human_name).with(@student_sally.human_name).and_return(@student_sally)
          User.stub(:find_by_human_name).with("Someone not in the system").and_return(nil)
     end
   
       it "validates that the people are in the system" do
         @team.members_override = [@student_sam.human_name, @student_sally.human_name]
         @team.validate_team_members
         @team.should be_valid
       end
   
       it "for people not in the system, it sets an error" do
         @team.members_override = [@student_sam.human_name, "Someone not in the system", @student_sally.human_name]
         @team.validate_team_members
         @team.should_not be_valid
         @team.errors[:base].should include("Person Someone not in the system not found")
       end
   
       it "assigns them to the people association" do
         @team.members_override = [@student_sam.human_name, @student_sally.human_name]
         @team.update_members
         @team.members[0].should == @student_sam
         @team.members[1].should == @student_sally
       end
     end
   
     context "is_person_on_team?" do
   
      before(:each) do
         @faculty_frank = FactoryGirl.create(:faculty_frank_user)
         @student_sam = FactoryGirl.create(:student_sam_user)
         @student_sally = FactoryGirl.create(:student_sally_user)
         @course = FactoryGirl.create(:course)
         @team = FactoryGirl.create(:team, :course_id => @course.id, :name => "Dracula", :members => [@student_sam, @student_sally])
       end
   
       it "correctly determines whether a user is on the team" do
         @team.is_user_on_team?(@student_sam).should be_true
         @team.is_user_on_team?(@student_sally).should be_true
         @team.is_user_on_team?(@faculty_frank).should be_false
       end
     end
   
   #these tests are the same with course
    context 'generated email address' do
      it 'should use the short name if available' do
        team = FactoryGirl.build(:team_triumphant, :course => FactoryGirl.build(:mfse_fall_2011))
        team.update_email_address
        team.email.should == "fall-2011-team-triumphant@" + GOOGLE_DOMAIN
      end
   
      it 'should convert unusual characters to ones that google can handle' do
        team = FactoryGirl.build(:team_triumphant, :course => FactoryGirl.build(:mfse_fall_2011))
        team.name = "A T & T"
        team.update_email_address
        team.email.should == "fall-2011-a-t-and-t@" + GOOGLE_DOMAIN
      end
    end
   
   
   end

================================================================================
 ./spec/models/user_preference_spec.rb
================================================================================
   require 'spec_helper'
   
   describe UserPreference do
     pending "add some examples to (or delete) #{__FILE__}"
   end

================================================================================
 ./spec/models/user_spec.rb
================================================================================
   require 'spec_helper'
   require "cancan/matchers"
   
   describe User do
   
     before do
       User.delete_all
       # this list must not be sorted alphabetically
       @faculty_frank = FactoryGirl.create(:faculty_frank)
       @faculty_fagan = FactoryGirl.create(:faculty_fagan)
       @admin_andy = FactoryGirl.create(:admin_andy)
   
     end
   
     describe "abilities" do
       subject { ability }
       let(:ability){ Ability.new(user) }
   
   
       context "when is a contracts manager" do
         let(:user){ FactoryGirl.create(:contracts_manager_user) }
         it{ should be_able_to(:manage, SponsoredProjectAllocation.new) }
         it{ should be_able_to(:manage, SponsoredProjectEffort.new) }
         it{ should be_able_to(:manage, SponsoredProjectSponsor.new) }
         it{ should be_able_to(:manage, SponsoredProject.new) }
       end
     end
   
     describe 'list of user related information' do
   
       before do
         @student_sam = FactoryGirl.create(:student_sam, :graduation_year=>"2012", :masters_program=>"SE")
       end
   
       it 'should get list of all graduation years available in the database'  do
         User.get_all_years.should include("2012")
       end
       it 'should get list of all programs available in the database' do
         User.get_all_programs.should include("SE")
       end
   
     end
   
   
   
   
     describe "user's teams" do
   
       it "should format teams" do
         @team_triumphant = FactoryGirl.create(:team_triumphant)
         teams = [@team_triumphant, @team_triumphant]
         subject.formatted_teams(teams).should == "Team Triumphant, Team Triumphant"
   #      teams = [FactoryGirl.create(:team, :name => "Team Awesome"), FactoryGirl.create(:team, :name => "Team Beautiful")]
   #      subject.formatted_teams(teams).should == "Team Awesome, Team Beautiful"
       end
     end
   
   
     context "photo upload" do
       before(:each) do
         @student_sam = FactoryGirl.create(:student_sam)
       end
   
         it "accepts PNG files for the first photo" do
           @student_sam.photo_first = File.new(File.join(Rails.root, 'spec', 'fixtures', 'sample_photo.png'))
           @student_sam.should be_valid
         end
   
         it "accepts GIF files for the first photo" do
           @student_sam.photo_first = File.new(File.join(Rails.root, 'spec', 'fixtures', "sample_photo.gif"))
           @student_sam.should be_valid
         end
   
         it "should update image_uri after photo_first is uploaded if the selection is the first one", :skip_on_build_machine => true do
           @student_sam.photo_first = File.new(File.join(Rails.root, 'spec', 'fixtures', "sample_photo.jpg"))
           @student_sam.photo_selection = "first"
           @student_sam.save!
           @student_sam.image_uri.should eql(@student_sam.photo_first.url(:profile).split('?')[0])
         end
   
         it "accepts PNG files for the second photo" do
           @student_sam.photo_second = File.new(File.join(Rails.root, 'spec', 'fixtures', 'sample_photo.png'))
           @student_sam.should be_valid
         end
   
         it "accepts GIF files for the second photo" do
           @student_sam.photo_second = File.new(File.join(Rails.root, 'spec', 'fixtures', "sample_photo.gif"))
           @student_sam.should be_valid
         end
   
         it "should update image_uri after photo_first is uploaded if the selection is the second one", :skip_on_build_machine => true do
           @student_sam.photo_second = File.new(File.join(Rails.root, 'spec', 'fixtures', "sample_photo.jpg"))
           @student_sam.photo_selection = "second"
           @student_sam.save!
           @student_sam.image_uri.should eql(@student_sam.photo_second.url(:profile).split('?')[0])
         end
   
         it "accepts PNG files for the custom photo" do
           @student_sam.photo_custom = File.new(File.join(Rails.root, 'spec', 'fixtures', 'sample_photo.png'))
           @student_sam.should be_valid
         end
   
         it "accepts GIF files for the custom photo" do
           @student_sam.photo_custom = File.new(File.join(Rails.root, 'spec', 'fixtures', "sample_photo.gif"))
           @student_sam.should be_valid
         end
   
         it "should update image_uri after photo_first is uploaded if the selection is the custom one", :skip_on_build_machine => true do
           @student_sam.photo_custom = File.new(File.join(Rails.root, 'spec', 'fixtures', "sample_photo.jpg"))
           @student_sam.photo_selection = "custom"
           @student_sam.save!
           @student_sam.image_uri.should eql(@student_sam.photo_custom.url(:profile).split('?')[0])
         end
   
         it "should update image_uri after photo_first is uploaded if the selection is the custom one", :skip_on_build_machine => true do
           @student_sam.photo_selection = "anonymous"
           @student_sam.save!
           @student_sam.image_uri.should eql("/assets/mascot.jpg")
         end
     end
   
     context "webiso account" do
   
        it "defaults to user.update_webiso_account if blank" do
          user = User.new
          user.update_webiso_account
          (Time.at(Time.now.to_f) - Time.at(Float(user.webiso_account))).should be < 1.second
        end
   
      end
     describe 'Custom Finders' do
   
         it "should have a named scope staff" do
           Person.should respond_to(:staff)
         end
   
         it 'finds all staff' do
           #Person.staff.should =~ [@admin_andy, @faculty_frank]
           staff = Person.staff
           staff.length.should == 3
           staff.include?(@admin_andy).should be_true
           staff.include?(@faculty_fagan).should be_true
           staff.include?(@faculty_frank).should be_true
         end
   
         it 'ordered by human name' do
           staff = Person.staff
           staff[0].should == @admin_andy
           staff[1].should == @faculty_fagan
           staff[2].should == @faculty_frank
         end
   
   
       end
   
   
   
       describe "permission levels" do
         before(:each) do
           @student_sam = FactoryGirl.create(:student_sam)
         end
   
         it "can respond to " do
           subject.should respond_to(:permission_level_of)
         end
   
         it "faculty can do faculty and admin activities" do
           @faculty_frank.permission_level_of(:admin).should == false
           @faculty_frank.permission_level_of(:staff).should == true
           @faculty_frank.permission_level_of(:student).should == true
         end
   
         it "admin can do all activities" do
           @admin_andy.permission_level_of(:admin).should == true
           @admin_andy.permission_level_of(:staff).should == true
           @admin_andy.permission_level_of(:student).should == true
         end
   
         it "student can only do student activities" do
           @student_sam.permission_level_of(:admin).should == false
           @student_sam.permission_level_of(:staff).should == false
           @student_sam.permission_level_of(:student).should == true
         end
       end
   
       describe "emailed_recently" do
         before(:each) do
           @student_sam = FactoryGirl.create(:student_sam)
         end
   
         context "for effort logs" do
           it "should be false if they've never received an email" do
             @student_sam.effort_log_warning_email = nil
             @student_sam.emailed_recently(:effort_log).should == false
           end
   
           it "should be false if they were emailed a while ago" do
             @student_sam.effort_log_warning_email = 4.days.ago
             @student_sam.emailed_recently(:effort_log).should == false
           end
   
           it "should be true if they were just emailed" do
             @student_sam.effort_log_warning_email = 1.hour.ago
             @student_sam.emailed_recently(:effort_log).should == true
           end
         end
   
         context "for sponsored project effort" do
           it "should be false if they've never received an email" do
             @student_sam.sponsored_project_effort_last_emailed = nil
             @student_sam.emailed_recently(:sponsored_project_effort).should == false
           end
   
           it "should be false if they were emailed a while ago" do
             @student_sam.sponsored_project_effort_last_emailed = 4.days.ago
             @student_sam.emailed_recently(:sponsored_project_effort).should == false
           end
   
           it "should be true if they were just emailed" do
             @student_sam.sponsored_project_effort_last_emailed = 1.hour.ago
             @student_sam.emailed_recently(:sponsored_project_effort).should == true
           end
         end
   
       end
   
       context "is versioned" do
   
         before(:each) do
           @student_sam = FactoryGirl.create(:student_sam)
           @version_number = @student_sam.version
         end
   
         it "normally" do
           @student_sam.first_name = "New"
           @student_sam.save
           @student_sam.version.should == (@version_number+1)
         end
   
         it "except when effort log email was sent" do
           @student_sam.effort_log_warning_email = Time.now
           @student_sam.save
           @student_sam.version.should == (@version_number)
         end
   
         it "except when sponsored project email was sent" do
           @student_sam.sponsored_project_effort_last_emailed = Time.now
           @student_sam.save
           @student_sam.version.should == (@version_number)
         end
   
       end
   
       describe "person's registered courses" do
         # TODO: courses registered - as not tested in the course model
   
       end
   
       context "twiki name parsing" do
         it "finds the correct first and last name" do
           twiki_names = {}
           twiki_names["StudentSam"] = ["Student", "Sam"]
           twiki_names["TestUser4"] = ["Test", "User4"]
           twiki_names["DenaHaritosTsamitis"] = ["Dena", "HaritosTsamitis"]
           twiki_names["GordonMcCreight"] = ["Gordon", "McCreight"]
   
           twiki_names.each do |twiki_name, expected_names|
             names = Person.parse_twiki(twiki_name)
             assert_equal(names[0], expected_names[0])
             assert_equal(names[1], expected_names[1])
           end
         end
   
       end
   
   
       context "can create_google_email(password)" do
         before(:each) do
           @student_sam = FactoryGirl.create(:student_sam)
         end
   
         it " is successful", :skip_on_build_machine => true  do
           ProvisioningApi.any_instance.stub(:create_user).and_return(:some_value)
           password = "just4now"
           @student_sam.email = "student.sam@sandbox.sv.cmu.edu"
           status = @student_sam.create_google_email(password)
           status.should_not be_is_a(String) #If it is a string, should be error message
         end
   
         it " errors when no email is provided" do
           ProvisioningApi.any_instance.stub(:create_user).and_return("Empty email address")
           password = "just4now"
           @student_sam.email = ""
           status = @student_sam.create_google_email(password)
           status.should == "Empty email address"
           status.should be_is_a(String)
         end
       end
   
   
     context "registered_for_these_courses_during_current_semester" do
   
       it "a student is 'registered' if we have data from the HUB" do
         @student_sam = FactoryGirl.create(:student_sam)
         @course = FactoryGirl.create(:fse_current_semester)
         @student_sam.registered_courses = [@course]
         @student_sam.save
         @student_sam.registered_for_these_courses_during_current_semester.should == [@course]
       end
   
       it "a student is 'registered' if the faculty has put the student on a team" do
         @team_triumphant = FactoryGirl.create(:team_triumphant)
         @course = @team_triumphant.course
         @student = @team_triumphant.members[0]
         @student.registered_for_these_courses_during_current_semester.should == [@course]
       end
   
   
     end
   
     context "should check if profile is valid" do
       before(:each) do
         @student_sam = FactoryGirl.build(:student_sam, is_active: true)
       end
       it "- profile should be invalid if bio/social profile and telephone number fields are missing" do
         @student_sam.send(:update_is_profile_valid)  
         @student_sam.is_profile_valid.should == false
       end
       it "- profile should valid if biography text and one telephone number present" do
         @student_sam.biography = "This is a fake biography. This text should represent pure awesomeness about the individual. populate accordingly."
         @student_sam.telephone1 = "9999999"
         @student_sam.send(:update_is_profile_valid)
         @student_sam.is_profile_valid.should == true
       end
       it "- profile should valid if one social profile and one telephone number present" do
         @student_sam.facebook = "sam_fb_id"
         @student_sam.telephone1 = "9999999"
         @student_sam.send(:update_is_profile_valid)
         @student_sam.is_profile_valid.should == true
       end
       it "notify about missing fields should send out an email" do
         @student_sam.send(:update_is_profile_valid)  
         ActionMailer::Base.delivery_method = :test
         ActionMailer::Base.perform_deliveries = true
         ActionMailer::Base.deliveries = []
         @student_sam.notify_about_missing_field(:biography, "Please update your profile page on whiteboard. You can provide biography information or even just a link to your social profile.")
         ActionMailer::Base.deliveries.size.should == 1
       end
     end
   
     # carrot and stick functionality
     context "should maintain an updated profile" do
       before(:each) do
         @student_sam = FactoryGirl.create(:student_sam)
         @student_sam.is_profile_valid = false
       end
       it "- student should be redirected if first_access is more than 4 weeks ago" do
         #@student_sam.first_access= DateTime.strptime('01/01/2010 12:00:00', '%d/%m/%Y %H:%M:%S')
         @student_sam.people_search_first_accessed_at = Time.now - 5.weeks
         @student_sam.should_be_redirected?.should == true
       end
       it "- student should not be redirected if first_access is less than 4 weeks ago" do
         @student_sam.people_search_first_accessed_at = Time.now - 3.weeks
         @student_sam.should_be_redirected?.should == false
       end
     end
   
     describe "notifies when there are expired accounts" do
       before(:each) do
         ActionMailer::Base.delivery_method = :test
         ActionMailer::Base.perform_deliveries = true
         ActionMailer::Base.deliveries = []
       end
       it "should send email to IT about expired accounts within the last month" do
         @student_sam = FactoryGirl.create(:student_sam, is_active: true, expires_at: Date.today - 1.day)
         @student_sally = FactoryGirl.create(:student_sally, is_active: true, expires_at: Date.today - 1.month)
         User.notify_it_about_expired_accounts()
         ActionMailer::Base.deliveries.size.should == 1
         ActionMailer::Base.deliveries.first.to_s.should include Rails.application.routes.url_helpers.user_url(@student_sam, :host => "whiteboard.sv.cmu.edu").to_s
         ActionMailer::Base.deliveries.first.to_s.should include Rails.application.routes.url_helpers.user_url(@student_sally, :host => "whiteboard.sv.cmu.edu").to_s
       end
   
       it "should NOT send email for accounts that do not expire" do
         @student_sam = FactoryGirl.create(:student_sam, is_active: true, expires_at: nil)
         User.notify_it_about_expired_accounts()
         ActionMailer::Base.deliveries.size.should == 0
       end
   
       it "should NOT send email for accounts expired more than month ago but should DO send email for accounts expired within one month ago" do
         @student_sam = FactoryGirl.create(:student_sam, is_active: true, expires_at: Date.today - 1.month - 1.day)
         @student_sally = FactoryGirl.create(:student_sally, is_active: true, expires_at: Date.today - 1.month + 1.day)
         User.notify_it_about_expired_accounts()
         ActionMailer::Base.deliveries.size.should == 1
         ActionMailer::Base.deliveries.first.to_s.should_not include Rails.application.routes.url_helpers.user_url(@student_sam, :host => "whiteboard.sv.cmu.edu").to_s
         ActionMailer::Base.deliveries.first.to_s.should include Rails.application.routes.url_helpers.user_url(@student_sally, :host => "whiteboard.sv.cmu.edu").to_s
       end
   
       it "should NOT send for inactive accounts" do
         @student_sam = FactoryGirl.create(:student_sam, is_active: false, expires_at: Date.today - 1.day)
         User.notify_it_about_expired_accounts()
         ActionMailer::Base.deliveries.size.should == 0
       end
   
     end
   
     # More tests
     # Effort log should only be set for person that is_student - tested in effort_log
     # Graduation_year should be set for person that is_student
   
   
   end

================================================================================
 ./spec/requests/assignments_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "Assignments" do
     before do
   
       visit ('/')
       @faculty_fagan = FactoryGirl.create(:faculty_fagan)
       login_with_oauth @faculty_fagan
       #@course = FactoryGirl.create(:fse)
       @assignment=FactoryGirl.create(:assignment_fse)
       @course = @assignment.course
       @course.faculty << @faculty_fagan
   
     end
     describe "GET /assignments" do
       it "should load the page with assignment details" do
         # Run the generator again with the --webrat flag if you want to use webrat methods/matchers
         visit (course_assignments_path(@course))
!!       page.should have_content(@assignment.name)
!!       page.should have_content(@assignment.task_number)
       end
   
       #it "should load the page with assignment details" do
       #  # Run the generator again with the --webrat flag if you want to use webrat methods/matchers
       #  visit (course_assignments_path(@course))
       #  click_link "Edit"
       #  edit_course_assignment_path(@course,@assignment).should eq(current_path)
       #  page.body.should have_content(@assignment.name)
       #  page.should have_content(@assignment.due_date)
       #end
   
   
       it "should load the page with assignment details" do
         # Run the generator again with the --webrat flag if you want to use webrat methods/matchers
         visit (course_assignments_path(@course))
!!       click_link "Delete"
!!       page.should_not have_content(@assignment.name)
       end
   
   
   
   
     end
   end

================================================================================
 ./spec/requests/courses_spec.rb
================================================================================
   require "spec_helper"
   
   describe "courses" do
   
      before do
      visit('/')
      @user = FactoryGirl.create(:student_sam)
      @semester = AcademicCalendar.current_semester()
      @year = Date.today.year
      login_with_oauth @user
      click_link "#{@semester} #{@year}" " Courses"
     end
   
     context "current courses" do
   
       it "renders current courses page" do
!!       page.should have_content("#{@semester} #{@year}" " Courses")
!!       page.should have_selector("input#filterBoxOne")
!!       page.should have_link("course selections")
       end
   
       it "defaults to a listing of all courses in the semester" do
!!         page.should have_selector("#courses_for_a_semester")
       end
   
       it "toggles to a visual representation of courses" do
!!       click_link "Show courses by minis"
!!       page.should have_selector("#courses_by_length")
       end
   
     end
   
     context "all courses" do
       it 'renders all courses' do
!!       click_link "Courses"
!!       page.should have_content("All Courses")
!!       page.should have_link("See current semester")
      end
   
     end
   
   end

================================================================================
 ./spec/requests/deliverables_spec.rb
================================================================================
   require "spec_helper"
   
   describe "deliverables" do
     before do
   
       @assignment = FactoryGirl.create(:assignment_team)
       @team_deliverable = FactoryGirl.create(:team_deliverable)
       @user = @team_deliverable.team.members[0]
       @grade =  FactoryGirl.create(:grade_visible, :course_id => @assignment.course.id)
       Assignment.stub(:list_assignments_for_student).with(@user.id, :current).and_return([@assignment])
       Assignment.stub(:list_assignments_for_student).with(@user.id, :past).and_return([@assignment])
       @assignment.stub(:deliverables).and_return([@team_deliverable])
       @assignment.stub(:get_student_grade).with(@user.id).and_return(@grade)
       @assignment.stub(:get_student_deliverable).with(@user.id).and_return(@team_deliverable)
       @assignment.stub(:maximum_score).and_return(20.0)
       @deliverableAttachment=DeliverableAttachment.create(:attachment_file_name=>"hi",:deliverable_id=>@team_deliverable.id,:submitter_id=>@user.id)
   
     end
   
     after do
       #@team_deliverable.delete
       #@user.delete
       #@deliverableAttachment.delete
     end
   
     context "As a student" do
       before do
        visit('/')
        login_with_oauth @user
        click_link "My Deliverables"
       end
   
       context "My deliverables" do
         it "renders my deliverables page" do
!!         page.should have_content("Listing Deliverables")
!!         page.should have_link("New deliverable")
         end
   
         it "lets the user create new deliverable"  do
!!         click_link "New deliverable"
!!         page.should have_content("New deliverable")
!!         page.should have_selector("select#deliverable_course_id")
!!         page.should have_button("Create")
         end
       end
   
       #turing
       it "I can see who graded me" do
!!       @faculty_frank = FactoryGirl.create(:faculty_frank_user)
!!       @assignment1 = FactoryGirl.create(:assignment_team)
!!       @grade1 = FactoryGirl.create(:last_graded_visible, :course_id => @assignment1.course.id,:assignment_id => @assignment1.id, :last_graded_by => @faculty_frank.id, :student_id =>@user.id)
!!       @team_deliverable.course = @assignment1.course
!!       @team_deliverable.assignment = @assignment1
!!       @team_deliverable.creator = @user
!!       Assignment.stub(:list_assignments_for_student).with(@user.id, :current).and_return([@assignment1])
!!       Assignment.stub(:list_assignments_for_student).with(@user.id, :past).and_return([@assignment1])
!!       @assignment1.stub(:get_student_grade).with(@user.id).and_return(@grade1)
!!       Grade.stub(:get_grade).and_return(@grade1)
!!       @assignment1.stub(:maximum_score).and_return(20.0)
!!       click_link "Resubmit"
!!       page.should have_content("Graded by")
!!       page.should have_content(@faculty_frank.human_name)
   
       end
   
       it " I can not be able to view professor's notes" do
!!       grade = @grade.score + "/" + @assignment.maximum_score.to_s
!!       page.should have_content(grade)
!!       click_link "Resubmit"
     #   visit deliverable_path(@team_deliverable)
   
     #    page.should have_content("Attachment Version History")
!!       page.should have_content("History")
!!       page.should_not have_content("Professor's Notes")
!!       page.should_not have_content("My private notes")
       end
   
   
       context "when I submit an assignment," do
         before {
!!         @assignment = FactoryGirl.create(:assignment)
!!         @course_mfse = FactoryGirl.create(:mfse)
!!         Registration.create(user_id: @user.id, course_id: @assignment.course.id)
         }
   
         it "I see all my registered courses " do
           # Add one for the empty option
!!         visit new_deliverable_path
!!         page.should have_selector("select#deliverable_course_id > option", count: @user.registered_for_these_courses_during_current_semester.count)
         end
   
         context "with course_id and assignment_id from the url" do
           before {
!!           visit new_deliverable_path(course_id: @assignment.course.id, assignment_id: @assignment.id)
           }
   
           it "it should save when an attachment is present", :skip_on_build_machine => true do
!!           attach_file 'deliverable_attachment_attachment', Rails.root + 'spec/fixtures/sample_assignment.txt'
!!           expect { click_button 'Create' }.to change(Deliverable, :count).by(1)
           end
   
           it "should not save when there is no attachment" do
!!           expect { click_button 'Create' }.to_not change(Deliverable, :count)
   
!!           page.should have_selector("h1", text: "New deliverable")
!!           page.should have_selector(".ui-state-error")
           end
         end
   
         it "without course_id and assignment_id selected, then it should not save" do
!!         visit new_deliverable_path
!!         expect { click_button 'Create' }.to change(Deliverable, :count).by(0)
   
!!         page.should have_selector("h1", text: "New deliverable")
!!         page.should have_selector(".ui-state-error")
         end
       end
     end
   
   
     context "As a professor" do
       before do
         @faculty = FactoryGirl.create(:faculty_frank_user)
         login_with_oauth @faculty
!!       @team_deliverable.course.faculty = [@faculty]
!!       @course = FactoryGirl.create(:fse)
!!       @faculty_assignment = FactoryGirl.create(:faculty_assignment, :course_id => @course.id,
                                                  :user_id => @faculty.id)
!!       @team_deliverable.course = @course
!!       @student_sam = FactoryGirl.create(:student_sam)
   
!!       @team_turing =  FactoryGirl.create(:team_turing, :course => @course)
!!       @team_turing.members = [@student_sam]
   
!!       @team_test =  FactoryGirl.create(:team_test, :course=>@course)
!!       @team_assignment = FactoryGirl.create(:team_turing_assignment, :team => @team_turing, :user => @student_sam)
   
!!       @assignment_team_turing_1 = FactoryGirl.create(:assignment_1,:course => @course)
!!       @assignment_team_turing_2 = FactoryGirl.create(:assignment_2,:course => @course)
!!       @assignment_team_test_1 = FactoryGirl.create(:assignment_1,:course => @course)
   
!!       @grade_assignment_team_turing_1 = FactoryGirl.create(:grade_invisible, :course => @course,:assignment =>
             @assignment_team_turing_1, :last_graded_by => @faculty.id, :student =>@student_sam)
   
!!       @team_turing_deliverable_1 = FactoryGirl.create(:team_turing_deliverable_1,:course => @course, :team =>
             @team_turing, :assignment => @assignment_team_turing_1, :attachment_versions => [], :creator => @student_sam,
             :grade_status => "ungraded")
!!       @team_turing_deliverable_2 = FactoryGirl.create(:team_turing_deliverable_2,:course => @course, :team =>
             @team_turing,:assignment => @assignment_team_turing_2, :attachment_versions => [],  :creator => @student_sam,
                                                         :grade_status => "ungraded")
!!       @team_test_deliverable_1 = FactoryGirl.create(:team_test_deliverable_1,:course => @course, :team =>
             @team_test,:assignment => @assignment_team_test_1, :attachment_versions => [], :grade_status => "ungraded")
   
   
!!       @attachment_team_turing_deliverable_1 =  FactoryGirl.create(:attachment_1, :deliverable =>
             @team_turing_deliverable_1, :submitter => @student_sam)
!!       @attachment_team_turing_deliverable_2 =  FactoryGirl.create(:attachment_1, :deliverable =>
             @team_turing_deliverable_2, :submitter => @student_sam)
!!       @attachment_team_test_deliverable_1 =  FactoryGirl.create(:attachment_1, :deliverable =>
             @team_test_deliverable_1, :submitter => @student_sam)
   
!!       @attachment_team_turing_deliverable_1.attachment_file_name = "Attachment 1"
!!       @attachment_team_turing_deliverable_2.attachment_file_name = "Attachment 2"
!!       @attachment_team_test_deliverable_1.attachment_file_name = "Attachment 3"
   
!!       @team_turing_deliverable_1.attachment_versions << @attachment_team_turing_deliverable_1
!!       @team_turing_deliverable_2.attachment_versions << @attachment_team_turing_deliverable_2
!!       @team_test_deliverable_1.attachment_versions << @attachment_team_test_deliverable_1
       end
   
       after do
         @faculty.delete
       end
   
       it "I should be able to view only my teams deliverables", :js => true do
!!       visit course_deliverables_path(@course)
   
!!       page.should have_content("Task 1")
!!       page.should have_content("Task 2")
!!       page.should_not have_content("Task 3")
   
!!       page.should have_content("Team Turing")
!!       page.should_not have_content("Team Test")
   
!!       page.should have_link("Assignment 1")
!!       page.should have_link("Assignment 2")
!!       page.should_not have_link("Assignment 3")
   
       end
   
       it "I should be able see the ungraded icon as default", :js => true do
!!       visit course_deliverables_path(@course)
   
!!       page.should have_xpath("//img[contains(@src, \"deliverables_ungraded.png\")]")
   
       end
   
       it "I should be able to click deliverable to open accordion and check content of grading page", :js => true do
!!       visit course_deliverables_path(@course)
!!       find("#deliverable_" + @team_turing_deliverable_1.id.to_s).click
!!       page.should have_content("History")
!!       page.should have_content("Professor's Notes")
!!       page.should have_content("My first deliverable")
!!       page.should have_content("Graded by")
!!       page.should have_content("Send a copy to myself")
!!       page.should have_button("Save as Draft")
!!       page.should have_button("Finalize and Email")
   
       end
   
       it "I should be able to see who last graded in the grading page", :js => true do
!!       visit course_deliverables_path(@course)
!!       find("#deliverable_" + @team_turing_deliverable_1.id.to_s).click
!!       page.should have_content("Graded by")
!!       page.should have_link(@faculty.human_name.to_s, href: person_path(@faculty.twiki_name))
       end
   
       it "I should be able to see default message for last graded by in the grading page if not graded", :js => true do
!!       visit course_deliverables_path(@course)
!!       find("#deliverable_" + @team_turing_deliverable_2.id.to_s).click
!!       page.should have_content("Graded by")
!!       page.should_not have_link(@faculty.human_name.to_s, href: person_path(@faculty.twiki_name))
       end
     end
   
     it "test user" do
       @student1 = FactoryGirl.create(:student_sam_user)
       @student2 = FactoryGirl.create(:student_sam_user)
       @student1.should == @student2
     end
   
     context "Professor deliverables" do
       context "grading team deliverable" do
         before {
!!         @team = @team_deliverable.team
!!         @assignment = FactoryGirl.create(:assignment, is_team_deliverable: true, course: @team.course)
!!         Registration.create(user_id: @user.id, course_id: @assignment.course.id)
!!         login_with_oauth @user
!!         visit new_deliverable_path(course_id: @assignment.course.id, assignment_id: @assignment.id)
!!         attach_file 'deliverable_attachment_attachment', Rails.root + 'spec/fixtures/sample_assignment.txt'
!!         click_button "Create"
!!         @professor = FactoryGirl.create(:faculty_frank_user)
!!         @assignment.course.faculty_assignments_override = [@professor.human_name]
!!         @assignment.course.update_faculty
   #        Course.any_instance.stub(:faculty).and_return([@professor])
!!         visit "/logout"
!!         login_with_oauth @professor
           # visit deliverable_feedback_path(Deliverable.last)  #if we separate out the feedback page
!!         visit deliverable_path(Deliverable.last)
           #save_and_open_page
!!         page.should have_content("Grade Team Deliverable")
         }
   
         #it "should provide feedback and a grade to each student in the team" do
         #  fill_in "deliverable_deliverable_grades_attributes_0_grade", with: 10
         #  click_button "Submit"
         #  Deliverable.last.deliverable_grades.first.number_grade.should == 10.0
         #  Deliverable.last.status.should == 'Graded'
         #end
         #
         #it "should save as draft" do
         #  fill_in "deliverable_deliverable_grades_attributes_0_grade", with: 10
         #  click_button "Save as draft"
         #  Deliverable.last.deliverable_grades.first.number_grade.should == 10.0
         #  Deliverable.last.status.should == 'Draft'
         #end
       end
   
       #context "grading individual deliverables" do
       #  before {
       #    @assignment = FactoryGirl.create(:assignment, is_team_deliverable: false)
       #    Registration.create(user_id: @user.id, course_id: @assignment.course.id)
       #    login_with_oauth @user
       #    visit new_deliverable_path(course_id: @assignment.course.id, assignment_id: @assignment.id)
       #    attach_file 'deliverable_attachment_attachment', Rails.root + 'spec/fixtures/sample_assignment.txt'
       #    click_button "Create"
       #    @professor = FactoryGirl.create(:faculty_frank_user)
       #    @assignment.course.faculty_assignments_override = [@professor.human_name]
       #    @assignment.course.update_faculty
       #    login_with_oauth @professor
       #  }
       #
       #  it "should provide feedback and a grade to the student" do
       #    visit deliverable_feedback_path(Deliverable.last)
       #    page.should have_content("Grade Individual Deliverable")
       #    fill_in "deliverable_deliverable_grades_attributes_0_grade", with: 10
       #    click_button "Submit"
       #    Deliverable.last.deliverable_grades.first.number_grade.should == 10.0
       #    Deliverable.last.status.should == 'Graded'
       #  end
       #
       #  it "should save as draft" do
       #    visit deliverable_feedback_path(Deliverable.last)
       #    page.should have_content("Grade Individual Deliverable")
       #    fill_in "deliverable_deliverable_grades_attributes_0_grade", with: 10
       #    click_button "Save as draft"
       #    Deliverable.last.deliverable_grades.first.number_grade.should == 10.0
       #    Deliverable.last.status.should == 'Draft'
       #  end
       #
       #  context "unallowed access" do
       #    before {
       #      @dwight = FactoryGirl.create(:faculty_dwight_user)
       #      login_with_oauth @dwight
       #    }
       #
       #    it "should not allow unassigned faculty to grade" do
       #      visit deliverable_feedback_path(Deliverable.last)
       #      page.should have_selector('.ui-state-error')
       #    end
       #  end
       #end
     end
   end

================================================================================
 ./spec/requests/effort_log_spec.rb
================================================================================
   require "spec_helper"
   
   describe "effort logs" do
   
     before do
      @user = FactoryGirl.create(:student_sam)
      login_with_oauth @user
      visit('/effort_logs')
     end
   
     context "shows effort logs" do
   
       it "renders effort logs page" do
   
!!       page.should have_content("Listing Effort Logs")
!!       page.should have_content("Week number")
!!       page.should have_content("Starting on")
!!       page.should have_content("Effort")
!!       page.should have_link("New effort log") || have_link("edit")
!!       page.should have_link("Back")
!!       if has_link?("Show")
!!          click_link "Show"
!!          page.should have_content("Show Effort Log")
         end
       end
     end
   
     #context "new effort log" do
     #
     #  it "renders new effort log page" do
     #    if has_link?("New effort log")
     #       click_link "New effort log"
     #       page.should have_content("New Effort Log")
     #       page.should have_button("Create")
     #       page.should have_link("Back")
     #    end
     #  end
     #  it "creates the effort log" do
     #    if has_link?("New effort log")
     #       click_link "New effort log"
     #      click_button "Create"
     #      page.should have_content("EffortLog was successfully created.")
     #    end
     #  end
     #end
   
   
   
     context "edit effort log" do
       it "renders editing effort log page" do
   
!!       if has_link?("Edit")
!!         click_link "Edit"
!!         page.should have_content("Editing Effort Log")
!!         page.should have_button("Update")
!!         page.should have_link("Add another line")
!!         page.should have_link("Show")
!!         page.should have_link("Back")
         end
   
       end
   
       it "updates the effort log and links to previous page" do
   
!!       if has_link?("Edit")
!!         click_link "Edit"
!!         page.should have_link("Update")
         end
   
       end
     end
   
   end

================================================================================
 ./spec/requests/effort_reports_spec.rb
================================================================================
   require "spec_helper"
   
   describe "effort reports" do
   
     before do
       @user = FactoryGirl.create(:student_sam)
       login_with_oauth @user
       visit('/effort_reports')
     end
   
     context "shows effort reports" do
   
       it "renders effort reports page" do
!!       page.should have_content("Effort Reports")
!!       page.should have_content("Campus View")
!!       page.should have_content("Course View")
!!       page.should have_link("Pick a course")
   
       end
     end
   end

================================================================================
 ./spec/requests/guest_signs_in_spec.rb
================================================================================
   require 'spec_helper'
   
   describe 'A user visiting the site', :type => :request do
   
     context 'when not logged in' do
       it 'welcomes the user' do
         visit root_path
         page.should have_content('Silicon Valley Campus')
       end
     end
     
     context 'when logged in' do
        before do
          @user = FactoryGirl.create(:student_sam)
          login_with_oauth @user
        end
   
        it 'only shows content to a logged in user' do
          visit people_path
!!        page.should have_content('Phone book')
        end
   
        it 'has a logout link' do
         visit('/')
         page.should have_link("Logout " "#{@user.first_name}")
        end
   
        # does not show flash here
        #it 'knows who am I' do
        #  visit('/')
        #  page.should have_content("#{@user.email}")
        #end
     end
   
     context 'when logged in' do
        before do
           @user =  FactoryGirl.create(:faculty_frank)
           login_with_oauth @user
           visit my_teams_path(@user.id)
        end
   
        it 'only shows content to a logged in user' do
!!        page.should have_content('My Teams')
        end
     end
   
     context 'when logged in' do
        before do
          login_with_oauth FactoryGirl.create(:admin_andy)
        end
   
        it 'only shows content to a logged in user' do
          visit sponsored_projects_path
!!        page.should have_content('Sponsored Projects')
        end
     end
   end
   

================================================================================
 ./spec/requests/jobs_spec.rb
================================================================================
   require "spec_helper"
   
   
   describe "Jobs" do
   
     context "When the user is on the new job page" do
       before do
         visit '/'
         @user = FactoryGirl.create(:faculty_frank)
         login_with_oauth @user
         click_link "Jobs"
!!       click_link "Post a job"
       end
   
       it "The job sponsors includes the current user" do
!!       find_field('supervisors[]').value.should eq 'Faculty Frank'
       end
   
       context "And the user fills in no fields" do
         before do
!!         click_button('Create Job')
         end
   
         it "Then job is not created" do
!!         page.should have_content("Title can't be blank")
         end
       end
   
       context "And the user fills in required fields" do
         before do
!!         fill_in "Title", :with => "My awesome project"
!!         click_button('Create Job')
         end
   
         it "Then job is created" do
!!         page.should have_content("Job was successfully created")
         end
       end
     end
   
     context "When the user is on the job list page" do
       before do
        @job = FactoryGirl.create(:job, :funding_description => "Major Funding from Major Corp.")
        visit '/'
       end
   
       it "The funding details should only be visible to staff" do
         @user = FactoryGirl.create(:faculty_frank_user)
         login_with_oauth @user
   
         click_link "Jobs"
!!       page.should have_content("Major Funding from Major Corp.")
       end
   
       it "The funding details should not be visible to students" do
         @student_sam = FactoryGirl.create(:student_sam_user)
         login_with_oauth @student_sam
   
         click_link "Jobs"
!!       page.should have_no_content("Major Funding from Major Corp.")
       end
   
       context 'supervisor' do
         it "can edit a job they posted" do
           @faculty_frank_user = FactoryGirl.create(:faculty_frank_user)
           @job.supervisors << @faculty_frank_user
           @job.save
   
           login_with_oauth @faculty_frank_user
           click_link "Jobs"
   
!!         page.should have_link('Edit', :href => edit_job_path(@job))
         end
   
         it "cannot edit a job they didn't post" do
           visit "/logout"
           visit '/'
           @faculty_fagan_user = FactoryGirl.create(:faculty_fagan_user)
   
           login_with_oauth @faculty_fagan_user
           click_link "Jobs"
   
!!         visit edit_job_path(@job)
!!         page.should have_content("You don't have permission to update job.")
         end
       end
     end
   
     context "When the user is on the edit job page" do
       before do
         visit '/'
         @faculty_fagan_user = FactoryGirl.create(:faculty_fagan_user)
         login_with_oauth @faculty_fagan_user
         @job = FactoryGirl.create(:job, :supervisors => [@faculty_fagan_user])
         @student_sam = FactoryGirl.create(:student_sam_user)
       end
       it "they can add employees" do
         visit edit_job_path(@job)
!!       click_link "Add a student"
!!       fill_in "people_name", :with => "Student Sam"
!!       click_button('Update Job')
   
!!       page.should have_content("Job was successfully updated.")
!!       page.should have_content("#{@job.title} (Student Sam)")
       end
       it "they can remove employees" do
         @job.employees << @student_sam
         @job.save
         visit edit_job_path(@job)
!!       within("#employees_in_a_collection") do
!!         click_on("remove")
         end
!!       click_button('Update Job')
!!       page.should have_no_content("#{@job.title} (Student Sam)")
       end
   
     end
   
   
   
   end

================================================================================
 ./spec/requests/pages_spec.rb
================================================================================
   require "spec_helper"
   
   describe "Pages" do
   
     context "with permission" do
       it "'world' : are visible to anyone" do
         @page = FactoryGirl.create(:page, :viewable_by => 'world')
         visit (page_path(@page))
         page.should have_content(@page.title)
         page.should have_content(@page.tab_one_contents)
       end
   
       context "'users' :" do
         before(:each) do
           @page = FactoryGirl.create(:page, :viewable_by => 'users')
         end
         it "are viewable by registered users" do
           visit ('/')
           @user = FactoryGirl.create(:student_sam)
           login_with_oauth @user
   
           visit (page_path(@page))
   #        save_and_open_page
           page.should have_content(@page.title)
!!         page.should have_content(@page.tab_one_contents)
         end
         it "are not viewable by non-registered users" do
           visit "/logout"
           visit (page_path(@page))
           page.should have_content("You don't have permission to do this action.")
         end
       end
   
       context "'staff' :" do
         before(:each) do
           @page = FactoryGirl.create(:page, :viewable_by => 'staff')
         end
         it "are viewable by staff and faculty" do
           visit ('/')
           @faculty_fagan = FactoryGirl.create(:faculty_fagan)
           login_with_oauth @faculty_fagan
   
           visit (page_path(@page))
           page.should have_content(@page.title)
!!         page.should have_content(@page.tab_one_contents)
         end
         it "are not viewable by all registered users" do
           visit ('/')
           @user = FactoryGirl.create(:student_sam)
           login_with_oauth @user
           visit (page_path(@page))
           page.should have_content("You don't have permission to do this action.")
         end
         it "are not viewable by public users" do
           visit "/logout"
           visit (page_path(@page))
           page.should have_content("You don't have permission to do this action.")
         end
       end
     end
   end

================================================================================
 ./spec/requests/people_search_spec.rb
================================================================================
   require "rspec"
     require "spec_helper"
   
     describe "PeopleSearch" do
   
       #before do
       #  @user = FactoryGirl.create(:student_sam)
       #  login_with_oauth(@user)
       #  #@user.program = "SE"
       #  #@user.program
       #end
   
     end

================================================================================
 ./spec/requests/phone_book_spec.rb
================================================================================
   require "spec_helper"
   
   describe "phone book" do
   
     before do
      visit('/')
      @user = FactoryGirl.create(:student_sam)
      login_with_oauth @user
      click_link "People"
     end
   
     context "shows phone book" do
   
       it "renders phone book page" do
!!       page.should have_content("Phone book")
!!       page.should have_selector("input#filterBoxOne")
         # page.should have_link("See conference rooms")
         # page.should have_link("See photo book")
   
       end
   
       it "renders phone book page" do
!!       page.should have_content("Phone book")
!!       page.should have_selector("input#filterBoxOne")
         # page.should have_link("See conference rooms")
         # page.should have_link("See photo book")
   
       end
   
       # it "renders photo book" do
       #   page.should have_link("See photo book")
       #   click_link "See photo book"
       #   page.should have_content("Photo Book")
       #   page.should have_link("See people")
       #   click_link "See people"
       #   page.should have_content("Phone book")
       # end
   
       it "lets the admin create a new person" do
!!       @user = FactoryGirl.create(:admin_andy)
!!       login_with_oauth @user
!!       click_link "People"
       end
   
     end
   
   end

================================================================================
 ./spec/requests/routes_spec.rb
================================================================================
   require "spec_helper"
   
   describe "models with punctuation" do
   
     #This doesn't work yet because we aren't logged in -- get capybara to work first
     #it "mailing lists" do
     #  get "/mailing_lists/edu-staff@sv.cmu.edu"
     #  response.should render_template(:show)
     #end
   end

================================================================================
 ./spec/requests/search_spec.rb
================================================================================
   require "spec_helper"
   
   describe "Search" do
     context "When the user searches for" do
       before(:each) do
         visit '/'
         @user = FactoryGirl.create(:student_sam)
         login_with_oauth @user
         click_button('searchSubmit')
       end
   
       it "nothing - page should render" do
!!       current_path.should == search_index_path
       end
   
       it "valid string - page should show the results", :skip_on_build_machine => true do
!!       fill_in "query", :with => "Search String"
!!       click_button('searchSubmit')
!!       page.should have_content('Your search for "Search String" returned 0 results')
       end
   
       describe "invalid string" do
         it "like '-+_' - the page should not tank", :skip_on_build_machine => true do
!!         fill_in "query", :with => "-+_"
!!         click_button('searchSubmit')
!!         current_path.should == search_index_path
!!         page.should have_content('Search for: ')
         end
         it "like '-%20%3C/p%3E%20-' - the page should not tank", :skip_on_build_machine => true do
!!         fill_in "query", :with => "-%20%3C/p%3E%20-"
!!         click_button('searchSubmit')
!!         page.should have_content('Your search for "-%20%3C/p%3E%20-" returned 0 results')
         end
       end
     end
   end

================================================================================
 ./spec/requests/teams_spec.rb
================================================================================
   require "spec_helper"
   
   describe "teams" do
   
      before do
      visit('/')
      @team = FactoryGirl.create(:team_triumphant)
      @user = @team.members[0]
      login_with_oauth @user
      click_link "My Teams"
      end
   
     context "my teams" do
   
       it "renders my teams" do
!!       page.should have_content("My Teams")
!!       page.should have_content("#{@user.human_name}")
   
!!       if @user.is_student?
!!          page.should have_content("is a team member")
         end
   
!!       if @user.is_staff?
!!          page.should have_content("is teaching the course")
         end
       end
   
       it "shows correct teams" do
!!       Team.any_instance.stub(:show_addresses_for_mailing_list).and_return(["email"])
!!       page.should have_link("#{@team.name}")
!!       page.should have_link("Show")
!!       click_link "Show"
!!       page.should have_content("Name: " "#{@team.name}")
       end
   
     end
   
   
   end

================================================================================
 ./spec/services/people_in_a_collection_spec.rb
================================================================================
   require 'spec_helper'
   require_relative '../../app/services/people_in_a_collection.rb'
   
   describe PeopleInACollection do
   
       context "when adding faculty to a course by providing their names as strings" do
         before(:each) do
           @course = FactoryGirl.build(:course)
   
           @faculty_frank = FactoryGirl.build(:faculty_frank, :id => rand(100))
           @faculty_fagan = FactoryGirl.build(:faculty_fagan, :id => rand(100) + 100)
           User.stub(:find_by_human_name).with(@faculty_frank.human_name).and_return(@faculty_frank)
           User.stub(:find_by_human_name).with(@faculty_fagan.human_name).and_return(@faculty_fagan)
           User.stub(:find_by_human_name).with("Someone not in the system").and_return(nil)
         end
   
         it "validates that the people are in the system" do
           @course.faculty_assignments_override = [@faculty_frank.human_name, @faculty_fagan.human_name]
           @course.validate_members :faculty_assignments_override
           @course.valid?
           @course.should be_valid
           tmp = 1
         end
   
         it "for people not in the system, it sets an error" do
           @course.faculty_assignments_override = [@faculty_frank.human_name, "Someone not in the system", @faculty_fagan.human_name]
           @course.validate_members :faculty_assignments_override
           @course.should_not be_valid
           @course.errors[:base].should include("Person Someone not in the system not found")
         end
   
         it "assigns them to the faculty association" do
           @course.faculty_assignments_override = [@faculty_frank.human_name, @faculty_fagan.human_name]
           @course.update_faculty
           @course.update_collection_members :faculty_assignments_override, :faculty
   
           @course.faculty[0].should == @faculty_frank
           @course.faculty[1].should == @faculty_fagan
         end
       end
   
   end

================================================================================
 ./spec/views/assignments/edit.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "assignments/edit.html.erb" do
     before(:each) do
!!     @assignment = assign(:assignment, stub_model(Assignment))
     end
   
     xit "renders the edit assignment form" do
!!     render
   
       # Run the generator again with the --webrat flag if you want to use webrat matchers
!!     assert_select "form", :action => assignments_path(@assignment), :method => "post" do
       end
     end
   end

================================================================================
 ./spec/views/assignments/index.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "assignments/index.html.erb" do
     before(:each) do
!!     assign(:assignments, [
         stub_model(Assignment),
         stub_model(Assignment)
       ])
     end
   
     xit "renders a list of assignments" do
!!     render
     end
   end

================================================================================
 ./spec/views/assignments/new.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "assignments/new.html.erb" do
     before(:each) do
!!     assign(:assignment, stub_model(Assignment).as_new_record)
     end
   
     xit "renders new assignment form" do
!!     render
   
       # Run the generator again with the --webrat flag if you want to use webrat matchers
!!     assert_select "form", :action =>course_assignments_path, :method => "post" do
       end
     end
   end

================================================================================
 ./spec/views/courses/configure.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "courses/configure.html.erb" do
     before(:each) do
       current_user = FactoryGirl.build(:faculty_frank)
       @course = assign(:course, stub_model(Course,
           :name => "something",
           :semester => "Fall",
           :year => "2011",
           :mini => "Both",
         :new_record? => false
       ))
     end
   
     it "renders the configure course form" do
       render
   
       rendered.should have_selector("form", :action => course_path(@course), :method => "post")
     end
   end

================================================================================
 ./spec/views/courses/edit.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "courses/edit.html.erb" do
     before(:each) do
   
       current_user = FactoryGirl.build(:faculty_frank)
       @course = assign(:course, stub_model(Course,
           :name => "something",
         :new_record? => false
       ))
       @course.stub(:faculty).and_return([stub_model(Person)])
       assign(:course_numbers, [stub_model(CourseNumber)])
     end
   
     it "renders the edit course form" do
       render
   
       rendered.should have_selector("form", :action => course_path(@course), :method => "post")
     end
   end

================================================================================
 ./spec/views/courses/index.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "courses/index.html.erb" do
     before(:each) do
       login(FactoryGirl.create(:student_sam))
       assign(:courses, [
         stub_model(Course,:name => "course1"),
         stub_model(Course,:name => "course2")
       ])
       assign(:semester_length_courses, [
         stub_model(Course,:name => "semester1"),
         stub_model(Course,:name => "semester2")
       ])
       assign(:mini_a_courses, [
         stub_model(Course,:name => "mini_a_1"),
         stub_model(Course,:name => "mini_a_2")
       ])
       assign(:mini_b_courses, [
         stub_model(Course,:name => "mini_b_1"),
         stub_model(Course,:name => "mini_b_2")
       ])
       assign(:registered_for_these_courses_during_current_semester, [
           stub_model(Course, :name => "student_course1"),
           stub_model(Course, :name => "student_course2")
       ])
       assign(:teaching_these_courses_during_current_semester, [
           stub_model(Course, :name => "instructor_course1"),
           stub_model(Course, :name => "instructor_course2")
       ])
       assign(:all_courses, true)
     end
   
     context "renders a list of courses" do
       it "in a div" do
         render
         rendered.should have_selector("#courses_for_a_semester")
       end
   
       it "contains a list of all courses for this semester" do
         render
         rendered.should have_content("course1")
         rendered.should have_content("course2")
       end
     end
   
     context "renders a visual representation of courses" do
   
       before(:each) do
         assign(:semester, AcademicCalendar.current_semester)
         assign(:year, Date.today.year)
       end
   
       it "in a div" do
         render :partial => "courses/index_courses_by_length.html.erb", :locals => {:style => nil, :state => "length"}
         rendered.should have_selector("#courses_by_length")
       end
   
       it "contains a list of semester courses" do
         render :partial => "courses/index_courses_by_length.html.erb", :locals => {:style => nil, :state => "length"}
         rendered.should have_content("semester1")
         rendered.should have_content("semester2")
       end
   
       it "contains a list of mini a courses" do
         render :partial => "courses/index_courses_by_length.html.erb", :locals => {:style => nil, :state => "length"}
         rendered.should have_content("mini_a_1")
         rendered.should have_content("mini_a_2")
       end
   
       it "contains a list of mini b courses" do
         render :partial => "courses/index_courses_by_length.html.erb", :locals => {:style => nil, :state => "length"}
         rendered.should have_content("mini_b_1")
         rendered.should have_content("mini_b_2")
       end
   
     end
   
   end

================================================================================
 ./spec/views/courses/new.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "courses/new.html.erb" do
     before(:each) do
       current_user = FactoryGirl.build(:faculty_frank)
       course = stub_model(Course).as_new_record
       course.stub(:people).and_return([stub_model(Person)])
       assign(:course, course)
       assign(:course_numbers, [stub_model(CourseNumber)])
   
     end
   
     it "renders new page form" do
       render
   
       rendered.should have_selector("form", :action => courses_path, :method => "post")
     end
   
    it 'should have fields' do
      render
   
       rendered.should have_selector('form') do |f|
!!       f.should have_selector("input[name='course[number]']")
!!       f.should have_selector("select[name='course[semester]']")
!!       f.should have_selector("input[name='course[year]']")
       end
     end
   
     it 'should have defaults (ie current year)'
   
   end

================================================================================
 ./spec/views/courses/show.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "courses/show.html.erb" do
     before(:each) do
       current_user = FactoryGirl.create(:student_sam)
       login(current_user)
       assign(:course, FactoryGirl.create(:course))
     end
   
     it "renders attributes in <p>" do
       render
     end
   end

================================================================================
 ./spec/views/effort_logs/new.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "effort_logs/new.html.erb" do
     before do
       assign(:day_labels, [1..7])
       course = FactoryGirl.create(:fse)
       assign(:courses, [course])
       assign(:task_types, [TaskType.create!])
       assign(:today_column, 1)
     end
   
     context 'with errors' do
       before do
   	  @current_user = FactoryGirl.build(:faculty_frank)
         effort_log = EffortLog.new(:year => nil, :week_number => 12, :sum => 8, :user => @current_user)
         assign(:effort_log, effort_log)
         effort_log.valid?
       end
       it "renders any error messages" do
         render
         rendered.should have_selector("div#error_explanation")
       end
     end
   
     context 'without errors' do
       before do
   	  @current_user = FactoryGirl.build(:faculty_frank)
         effort_log = EffortLog.new(:year => 2011, :week_number => 12, :sum => 8, :user => @current_user)
         assign(:effort_log, effort_log)
         effort_log.valid?
       end
       it 'does not render any error messages' do
         render
         rendered.should_not have_selector("div#error_explanation")
       end
     end
   
     context 'when the current user is an admin' do
       before do
         @current_user = FactoryGirl.create(:admin_andy)
         login(@current_user)
         effort_log = EffortLog.new(:year => 2011, :week_number => 12, :sum => 8, :user_id => @current_user.id)
         assign(:effort_log, effort_log)
       end
       it 'allows editing the person' do
         render
         rendered.should have_selector("input#effort_log_user_id")
       end
     end
   end

================================================================================
 ./spec/views/mailing_lists/index.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe 'mailing_lists/index' do
     before(:each) do
       login(FactoryGirl.create(:student_sam))
       assign(:mailing_lists, ["staff-faculty@sv.cmu.edu", "allstudents@sv.cmu.edu"])
     end
   
     it "renders a list of mailing lists" do
       render
     end
   
   
   end

================================================================================
 ./spec/views/mailing_lists/show.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "mailing_lists/show.html.erb" do
     before(:each) do
       current_user = FactoryGirl.build(:student_sam)
       assign(:mailing_list, "staff-faculty@sv.cmu.edu")
       assign(:members, ["andrew.carnegie@west.cmu.edu", "andrew.mellon@west.cmu.edu"] )
     end
   
     it "renders mailing list members" do
       render
     end
   end

================================================================================
 ./spec/views/page_comments/edit.html.erb_spec.rb
================================================================================
   require "rspec"
   
   describe "My behaviour" do
   
     it "should do something" do
   
       #To change this template use File | Settings | File Templates.
   #    true.should == false
     end
   end

================================================================================
 ./spec/views/pages/_editable_form.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe 'pages/_editable_form.html.erb' do
     before do
   
       login(FactoryGirl.create(:faculty_frank))
       assign(:page, FactoryGirl.build(:page))
       assign(:courses, [
         stub_model(Course),
         stub_model(Course)
       ])
       view.should_receive(:button_name).at_least(1).times.and_return("Update")
       view.should_receive(:enable_auto_save).at_least(1).times.and_return(false)
       view.should_receive(:enable_timeout).at_least(1).times.and_return(false)
       render
     end
   
     it 'should have title fields' do
         rendered.should have_selector('form') do |f|
!!       f.should have_selector("input[name='page[title]']")
!!       f.should have_selector("textarea[name='page[tab_one_contents]']")
       end
     end
   end

================================================================================
 ./spec/views/pages/edit.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "pages/edit.html.erb" do
     before(:each) do
       login(FactoryGirl.create(:faculty_frank))
       @page = assign(:page, stub_model(Page,
           :url => "something",
         :new_record? => false
       ))
       assign(:courses, [
         stub_model(Course),
         stub_model(Course)
       ])
     end
   
     it "renders the edit page form" do
       render
   
       rendered.should have_selector("form", :action => page_path(@page), :method => "post")
     end
   end

================================================================================
 ./spec/views/pages/index.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "pages/index.html.erb" do
     before(:each) do
       assign(:pages, [
         stub_model(Page,:url => "something"),
         stub_model(Page,:url => "something2")
       ])
     end
   
     it "renders a list of pages" do
       render
     end
   end

================================================================================
 ./spec/views/pages/new.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "pages/new.html.erb" do
     before(:each) do
       login(FactoryGirl.create(:faculty_frank))
       assign(:page, stub_model(Page).as_new_record)
       assign(:courses, [
         stub_model(Course),
         stub_model(Course)
       ])
     end
   
     it "renders new page form" do
       render
   
       rendered.should have_selector("form", :action => pages_path, :method => "post")
     end
   end

================================================================================
 ./spec/views/pages/show.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "pages/show.html.erb" do
     before(:each) do
       login(FactoryGirl.create(:student_sam))
       Page.any_instance.stub(:update_search_index)
       Page.any_instance.stub(:delete_from_search)
       assign(:page, FactoryGirl.create(:ppm))
     end
   
     it "renders attributes in <p>" do
       render
     end
   
     it "should show when the last edit occurred"
   
   end

================================================================================
 ./spec/views/password_resets/new.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "password_resets/new.html.erb" do
     pending "add some examples to (or delete) #{__FILE__}"
   end

================================================================================
 ./spec/views/people/edit.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "people/edit.html.erb" do
   
     describe "Login as a normal user" do
       before(:each) do
         person = FactoryGirl.create(:student_sam)
         login(person)
         @person = assign(:person, person)
       end
   
       it "renders the edit page form" do
         render
         rendered.should have_selector("form", :action => person_path(@person), :method => "post")
         rendered.should have_selector("#photo-first .use-this-photo")
         rendered.should have_selector("#photo-second .use-this-photo")
         rendered.should have_selector("#photo-custom .use-this-photo")
         rendered.should have_selector("#photo-anonymous .use-this-photo")
       end
   
       it "Has the option to upload the custom photo" do
         render
         rendered.should have_selector("#photo-custom .upload-new-photo")
       end
   
       it "Has no option to upload the first photo and second photo" do
         render
         rendered.should_not have_selector("#photo-first .upload-new-photo")
         rendered.should_not have_selector("#photo-second .upload-new-photo")
       end
     end
     
     describe "Login as a admin user" do
       before(:each) do
         person = FactoryGirl.create(:admin_andy)
         login(person)
         @person = assign(:person, person)
       end
   
       it "Has the option to upload the custom photo" do
         render
         rendered.should have_selector("#photo-custom .upload-new-photo")
       end
   
       it "Has options to upload the first photo and second photo" do
         render
         rendered.should have_selector("#photo-first .upload-new-photo")
         rendered.should have_selector("#photo-second .upload-new-photo")
       end
     end
   
   
   end

================================================================================
 ./spec/views/people/index.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe 'people/index.html.erb' do
     before(:each) do
       person = FactoryGirl.create(:student_sam)
       login(person)
       @person = assign(:person, person)
       @people = [FactoryGirl.build(:student_sally, :id => 1), FactoryGirl.build(:faculty_frank, :id => 2)] 
     end
   
     it "renders the index page" do
       render
     end
   
     it "should have first name, last name, contact details and the program" do
       render
       rendered.should have_content("First name")
       rendered.should have_content("Last name")
       rendered.should have_content("Contact Details")
       rendered.should have_content("Program")
     end
   
   end

================================================================================
 ./spec/views/people/show.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "people/show.html.erb" do
   
       describe "Can not see last login location if not admin" do
           before(:each) do
               person = FactoryGirl.create(:student_sam, :linked_in => "iamsam", :facebook => "iamsam", :twitter => "iamsam", :google_plus => "https://plus.google.com/u/1/1234567890/", :github => "iamsam")
               login(person)
               assign(:person, person)
           end
   
           it "renders the page" do
               render
               render.should_not have_content('Last signed in')
           end
       end
   
   
       describe "Can see last login location if admin" do
           before(:each) do
               person = FactoryGirl.create(:admin_andy)
               login(person)
               assign(:person, person)
           end
   
           it "renders the page" do
               render
               render.should have_content('Last signed in')
           end
       end
   
   end

================================================================================
 ./spec/views/sponsored_project_allocations/edit.html.erb_spec.rb
================================================================================
   #require 'spec_helper'
   #
   #describe "sponsored_project_allocations/edit.html.erb" do
   #  before(:each) do
   #    @allocation = assign(:allocation, stub_model(SponsoredProjectAllocation, :new_record? => false))
   #    assign(:projects, [FactoryGirl.build(:sponsored_project)])
   #    assign(:people, [FactoryGirl.build(:faculty_frank), FactoryGirl.build(:admin_andy)])
   #  end
   #
   #  it "renders edit allocation form" do
   #    render
   #
   #    response.should have_selector("form", :action => sponsored_project_allocations_path(@allocation), :method => "post")
   #
   #  end
   #
   #  it "renders a list of sponsors to pick from" do
   #    #Todo , make this test more interesting in rails 3
   #    render
   #
   #    response.should have_selector("select")
   #  end
   #end

================================================================================
 ./spec/views/sponsored_project_allocations/index.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe 'sponsored_project_allocations/index' do
     before(:each) do
       allocation = FactoryGirl.create(:sponsored_project_allocation)
   
       assign(:allocations, [
           allocation
       ])
     end
   
     it "renders a list of allocations" do
       render
     end
     
   
   end

================================================================================
 ./spec/views/sponsored_project_allocations/new.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "sponsored_project_allocations/new" do
   
     before(:each) do
       assign(:allocation, stub_model(SponsoredProjectAllocation).as_new_record)
   
       assign(:projects, [FactoryGirl.build(:sponsored_project)])
       assign(:users, [FactoryGirl.build(:faculty_frank_user), FactoryGirl.build(:admin_andy_user)])
     end
   
     it "renders new allocation form" do
       render
   
       rendered.should have_selector("form", :action => sponsored_project_allocations_path, :method => "post")
     end
   
     it "renders a list of projects to pick from" do
       #Todo , make this test more interesting in rails 3
       render
   
       rendered.should have_selector("select")
     end
   
     it "renders a list of people to pick from" do
       #Todo , make this test more interesting in rails 3
       render
   
       rendered.should have_selector("select")
     end
   
   end

================================================================================
 ./spec/views/sponsored_project_efforts/edit.html.erb_spec.rb
================================================================================
   #require 'spec_helper'
   #
   #describe "sponsored_project_efforts/edit.html.erb" do
   #  before(:each) do
   #
   #    @efforts = assign(:efforts, [FactoryGirl.create(:sponsored_project_effort)])
   #    @person = @efforts[0].sponsored_project_allocation.person
   ##    @effort = assign(:effort, stub_model(SponsoredProjectEffort, :new_record? => false))
   #  end
   #
   #  it "renders edit effort form" do
   #    render :id => @person.twiki_name
   #
   ##    response.should have_selector("form", :action => sponsored_project_effort_path(@efforts[0].sponsored_project_allocation.person.twiki_name), :method => "post")
   #
   #  end
   #
   #
   #end

================================================================================
 ./spec/views/sponsored_project_efforts/index.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe 'sponsored_project_efforts/index' do
     before(:each) do
       effort = FactoryGirl.create(:sponsored_project_effort)
   
       assign(:efforts, [
           effort
       ])
       assign(:month, 3)
       assign(:year, 2010)
     end
   
     it "renders a list of efforts" do
       render
     end
   
   
   end

================================================================================
 ./spec/views/sponsored_project_sponsors/edit.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "sponsored_project_sponsors/edit.html.erb" do
     before(:each) do
       @sponsor = assign(:sponsor, stub_model(SponsoredProjectSponsor, :new_record? => false))
     end
   
     it "renders edit sponsor form" do
       render
   
       rendered.should have_selector("form", :action => sponsored_project_sponsors_path(@sponsor), :method => "post")
   
     end
   end

================================================================================
 ./spec/views/sponsored_project_sponsors/new.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "sponsored_project_sponsors/new.html.erb" do
     before(:each) do
       assign(:sponsor, stub_model(SponsoredProjectSponsor).as_new_record)
     end
   
     it "renders new sponsor form" do
       render
   
       rendered.should have_selector("form", :action => sponsored_project_sponsors_path, :method => "post")
     end
   
   end

================================================================================
 ./spec/views/sponsored_projects/edit.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "sponsored_projects/edit.html.erb" do
     before(:each) do
       @project = assign(:project, stub_model(SponsoredProject, :new_record? => false))
       assign(:sponsors, [FactoryGirl.build(:sponsored_project_sponsor), FactoryGirl.build(:sponsored_project_sponsor)])
     end
   
     it "renders edit project form" do
       render
   
       rendered.should have_selector("form", :action => sponsored_projects_path(@project), :method => "post")
   
     end
   
     it "renders a list of sponsors to pick from" do
       #Todo , make this test more interesting in rails 3
       render
   
       rendered.should have_selector("select")
     end
   end

================================================================================
 ./spec/views/sponsored_projects/index.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "sponsored_projects/index.html.erb" do
     before(:each) do
       sponsored_project = FactoryGirl.build(:sponsored_project, :id => 1)
       
       assign(:projects, [
         sponsored_project,
         sponsored_project
       ])
       assign(:sponsors, [
         stub_model(SponsoredProjectSponsor),
         stub_model(SponsoredProjectSponsor)
       ])
     end
   
     it "renders a list of sponsored projects" do
       render
     end
   end

================================================================================
 ./spec/views/sponsored_projects/new.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "sponsored_projects/new.html.erb" do
     before(:each) do
       assign(:project, stub_model(SponsoredProject).as_new_record)
   
       assign(:sponsors, [FactoryGirl.build(:sponsored_project_sponsor), FactoryGirl.build(:sponsored_project_sponsor)])
     end
   
     it "renders new project form" do
       render
   
       rendered.should have_selector("form", :action => sponsored_projects_path, :method => "post")
     end
   
     it "renders a list of sponsors to pick from" do
       #Todo , make this test more interesting in rails 3
       render
   
       rendered.should have_selector("select")
     end
   end

================================================================================
 ./spec/views/system/index.html.erb_spec.rb
================================================================================
   require 'spec_helper'
   
   describe "system/index.html.erb" do
     before(:each) do
       login(FactoryGirl.create(:student_sam))
     end
   
     it "renders the system page" do
       render
     end
   end

